print(diagnosis)
def merge(keys,maladies):
res = collections.defaultdict(int)
counter=0
for illness in keys:
counter +=1
for symptom in maladies[illness].keys():
res[symptom] += maladies[illness][symptom]
for key in res.keys():
if res[key] > 1 :
res[key] = 1
if res[key] < -1 :
res[key] = -1
return res
maldies_set = set(maladies.keys())
for keys in itertools.permutations(maldies_set,2):
key_list = list(keys)
key_list.sort()
if key_list not in diagnosis:
#print(key_list)
merged_spec = merge(key_list,maladies)
match, mismatch, score = diagnoser(patient, merged_spec)
#print(f"match:{match:<1}, missed:{mismatch:<2}, total:{score:<2} score for {key_list}")
if score > diag_score:
diag_score = score
diagnosis = []
if score >= diag_score:
diagnosis.append(key_list)
#print(f"match:{match:<1}, missed:{mismatch:<2}, total:{score:<2} score for {key_list}")
#print(merged_spec)
#print(patient)
print(diagnosis)
#print(maladies['Zetad'])
#print(maladies['Epsicusus'])
#merged_spec = merge(('Zetad', 'Betatosis'),maladies)
#print(dict(merged_spec))
#print(patient )
#| label: medical diagnosis challange - MVP solution
import itertools
import collections
from collections import defaultdict
patient = {k:v for (k,v) in zip(letters ,(0,1,-1,0,0,-1,0,-1))}
# a metric based diagnosis
def diagnoser(patient,illness):
# takes a patient spec and an illness spec
# return a distance between patient and illness spec
match,mismatch,score = 0,0,0
for k in patient.keys():
if patient[k] == illness[k] and not patient[k] == 0:
match += 1
if not patient[k] == illness[k]:
mismatch += 1
score = match - mismatch
return match,mismatch,score
# next we find the best diagnosis for the for the patient
diag_score=0
diagnosis=[]
match,mismatch,score = diagnoser(patient, patient)
print(f"expected score for solution: {score}")
for illness in maladies.keys():
match,mismatch,score = diagnoser(patient, maladies[illness])
print(f"match:{match:<1}, missed:{mismatch:<2}, total:{score:<2} score for {illness}")
if score > diag_score:
diag_score = score
diagnosis = []
if score >= diag_score:
diagnosis.append(illness)
print(diagnosis)
def merge(keys,maladies):
res = collections.defaultdict(int)
counter=0
for illness in keys:
counter +=1
for symptom in maladies[illness].keys():
res[symptom] += maladies[illness][symptom]
for key in res.keys():
if res[key] > 1 :
res[key] = 1
if res[key] < -1 :
res[key] = -1
return res
maldies_set = set(maladies.keys())
for keys in itertools.permutations(maldies_set,2):
key_list = list(keys)
key_list.sort()
if key_list not in diagnosis:
#print(key_list)
merged_spec = merge(key_list,maladies)
match, mismatch, score = diagnoser(patient, merged_spec)
#print(f"match:{match:<1}, missed:{mismatch:<2}, total:{score:<2} score for {key_list}")
if score > diag_score:
diag_score = score
diagnosis = []
if score >= diag_score:
diagnosis.append(key_list)
print(f"partial: match:{match:<1}, missed:{mismatch:<2}, total:{score:<2} score for {key_list}")
print(diagnosis)
#| label: medical diagnosis challange - MVP solution
import itertools
import collections
from collections import defaultdict
patient = {k:v for (k,v) in zip(letters ,(0,1,-1,0,0,-1,0,-1))}
# a metric based diagnosis
def diagnoser(patient,illness):
# takes a patient spec and an illness spec
# return a distance between patient and illness spec
match,mismatch,score = 0,0,0
for k in patient.keys():
if patient[k] == illness[k] and not patient[k] == 0:
match += 1
if not patient[k] == illness[k]:
mismatch += 1
score = match - mismatch
return match,mismatch,score
# next we find the best diagnosis for the for the patient
# diag_score=0
# diagnosis=[]
match,mismatch,score = diagnoser(patient, patient)
print(f"expected score for solution: {score}")
# for illness in maladies.keys():
#   match,mismatch,score = diagnoser(patient, maladies[illness])
#   print(f"match:{match:<1}, missed:{mismatch:<2}, total:{score:<2} score for {illness}")
#   if score > diag_score:
#     diag_score = score
#     diagnosis = []
#   if score >= diag_score:
#     diagnosis.append(illness)
print(diagnosis)
def merge(keys,maladies):
res = collections.defaultdict(int)
counter=0
for illness in keys:
counter +=1
for symptom in maladies[illness].keys():
res[symptom] += maladies[illness][symptom]
for key in res.keys():
if res[key] > 1 :
res[key] = 1
if res[key] < -1 :
res[key] = -1
return res
diag_score=0
diagnosis=[]
maldies_set = set(maladies.keys())
for comb_len in range(2):
for keys in itertools.combinations(maldies_set,comb_len):
key_list = list(keys)
key_list.sort()
if key_list not in diagnosis:
#print(key_list)
merged_spec = merge(key_list,maladies)
match, mismatch, score = diagnoser(patient, merged_spec)
#print(f"match:{match:<1}, missed:{mismatch:<2}, total:{score:<2} score for {key_list}")
if score > diag_score:
diag_score = score
diagnosis = []
if score >= diag_score:
diagnosis.append(key_list)
print(f"partial: match:{match:<1}, missed:{mismatch:<2}, total:{score:<2} score for {key_list}")
print(diagnosis)
#| label: medical diagnosis challange - MVP solution
import itertools
import collections
from collections import defaultdict
patient = {k:v for (k,v) in zip(letters ,(0,1,-1,0,0,-1,0,-1))}
# a metric based diagnosis
def diagnoser(patient,illness):
# takes a patient spec and an illness spec
# return a distance between patient and illness spec
match,mismatch,score = 0,0,0
for k in patient.keys():
if patient[k] == illness[k] and not patient[k] == 0:
match += 1
if not patient[k] == illness[k]:
mismatch += 1
score = match - mismatch
return match,mismatch,score
# next we find the best diagnosis for the for the patient
# diag_score=0
# diagnosis=[]
match,mismatch,score = diagnoser(patient, patient)
print(f"expected score for solution: {score}")
# for illness in maladies.keys():
#   match,mismatch,score = diagnoser(patient, maladies[illness])
#   print(f"match:{match:<1}, missed:{mismatch:<2}, total:{score:<2} score for {illness}")
#   if score > diag_score:
#     diag_score = score
#     diagnosis = []
#   if score >= diag_score:
#     diagnosis.append(illness)
print(diagnosis)
def merge(keys,maladies):
res = collections.defaultdict(int)
counter=0
for illness in keys:
counter +=1
for symptom in maladies[illness].keys():
res[symptom] += maladies[illness][symptom]
for key in res.keys():
if res[key] > 1 :
res[key] = 1
if res[key] < -1 :
res[key] = -1
return res
diag_score=0
diagnosis=[]
maldies_set = set(maladies.keys())
for comb_len in range(3):
for keys in itertools.combinations(maldies_set,comb_len):
key_list = list(keys)
key_list.sort()
if key_list not in diagnosis:
#print(key_list)
merged_spec = merge(key_list,maladies)
match, mismatch, score = diagnoser(patient, merged_spec)
#print(f"match:{match:<1}, missed:{mismatch:<2}, total:{score:<2} score for {key_list}")
if score > diag_score:
diag_score = score
diagnosis = []
if score >= diag_score:
diagnosis.append(key_list)
print(f"partial: match:{match:<1}, missed:{mismatch:<2}, total:{score:<2} score for {key_list}")
print(diagnosis)
#| label: medical diagnosis challange - MVP solution
import itertools
import collections
from collections import defaultdict
patient = {k:v for (k,v) in zip(letters ,(0,1,-1,0,0,-1,0,-1))}
# a metric based diagnosis
def diagnoser(patient,illness):
# takes a patient spec and an illness spec
# return a distance between patient and illness spec
match,mismatch,score = 0,0,0
for k in patient.keys():
if patient[k] == illness[k] and not patient[k] == 0:
match += 1
if not patient[k] == illness[k]:
mismatch += 1
score = match - mismatch
return match,mismatch,score
# next we find the best diagnosis for the for the patient
# diag_score=0
# diagnosis=[]
match,mismatch,score = diagnoser(patient, patient)
print(f"expected score for solution: {score}")
# for illness in maladies.keys():
#   match,mismatch,score = diagnoser(patient, maladies[illness])
#   print(f"match:{match:<1}, missed:{mismatch:<2}, total:{score:<2} score for {illness}")
#   if score > diag_score:
#     diag_score = score
#     diagnosis = []
#   if score >= diag_score:
#     diagnosis.append(illness)
print(diagnosis)
def merge(keys,maladies):
res = collections.defaultdict(int)
counter=0
for illness in keys:
counter +=1
for symptom in maladies[illness].keys():
res[symptom] += maladies[illness][symptom]
for key in res.keys():
if res[key] > 1 :
res[key] = 1
if res[key] < -1 :
res[key] = -1
return res
diag_score=0
diagnosis=[]
maldies_set = set(maladies.keys())
for comb_len in range(4):
for keys in itertools.combinations(maldies_set,comb_len):
key_list = list(keys)
key_list.sort()
if key_list not in diagnosis:
#print(key_list)
merged_spec = merge(key_list,maladies)
match, mismatch, score = diagnoser(patient, merged_spec)
#print(f"match:{match:<1}, missed:{mismatch:<2}, total:{score:<2} score for {key_list}")
if score > diag_score:
diag_score = score
diagnosis = []
if score >= diag_score:
diagnosis.append(key_list)
print(f"partial: match:{match:<1}, missed:{mismatch:<2}, total:{score:<2} score for {key_list}")
print(diagnosis)
#| label: medical diagnosis challange - MVP solution
import itertools
import collections
from collections import defaultdict
patient = {k:v for (k,v) in zip(letters ,(0,1,-1,0,0,-1,0,-1))}
# a metric based diagnosis
def diagnoser(patient,illness):
# takes a patient spec and an illness spec
# return a distance between patient and illness spec
match,mismatch,score = 0,0,0
for k in patient.keys():
if patient[k] == illness[k] and not patient[k] == 0:
match += 1
if not patient[k] == illness[k]:
mismatch += 1
score = match - mismatch
return match,mismatch,score
# next we find the expected coverage for a diagnosis given the patient
_,_,expected_score = diagnoser(patient, patient)
print(f"expected score for patient : {expected_score}")
print(diagnosis)
def merge(keys,maladies):
res = collections.defaultdict(int)
counter=0
for illness in keys:
counter +=1
for symptom in maladies[illness].keys():
res[symptom] += maladies[illness][symptom]
for key in res.keys():
if res[key] > 1 :
res[key] = 1
if res[key] < -1 :
res[key] = -1
return res
diag_score=0
diagnosis=[]
maldies_set = set(maladies.keys())
for comb_len in range(3):
for keys in itertools.combinations(maldies_set,comb_len):
key_list = list(keys)
key_list.sort()
if key_list not in diagnosis:
#print(key_list)
merged_spec = merge(key_list,maladies)
match, mismatch, score = diagnoser(patient, merged_spec)
#print(f"match:{match:<1}, missed:{mismatch:<2}, total:{score:<2} score for {key_list}")
if score > diag_score:
diag_score = score
diagnosis = []
if score == expected_score:
print("reached expected score")
if score >= diag_score:
diagnosis.append(key_list)
print(f"partial: match:{match:<1}, missed:{mismatch:<2}, total:{score:<2} score for {key_list}")
print(diagnosis)
#| label: medical diagnosis challange - MVP solution
import itertools
import collections
from collections import defaultdict
patient = {k:v for (k,v) in zip(letters ,(0,1,-1,0,0,-1,0,-1))}
# a metric based diagnosis
def diagnoser(patient,illness):
# takes a patient spec and an illness spec
# return a distance between patient and illness spec
match,mismatch,score = 0,0,0
for k in patient.keys():
if patient[k] == illness[k] and not patient[k] == 0:
match += 1
if not patient[k] == illness[k]:
mismatch += 1
score = match - mismatch
return match,mismatch,score
# next we find the expected coverage for a diagnosis given the patient
_,_,expected_score = diagnoser(patient, patient)
print(f"expected score for patient : {expected_score}")
print(diagnosis)
def merge(keys,maladies):
res = collections.defaultdict(int)
counter=0
for illness in keys:
counter +=1
for symptom in maladies[illness].keys():
res[symptom] += maladies[illness][symptom]
for key in res.keys():
if res[key] > 1 :
res[key] = 1
if res[key] < -1 :
res[key] = -1
return res
diag_score=0
diagnosis=[]
maldies_set = set(maladies.keys())
for comb_len in range(3):
for keys in itertools.combinations(maldies_set,comb_len):
key_list = list(keys)
key_list.sort()
if key_list not in diagnosis:
#print(key_list)
merged_spec = merge(key_list,maladies)
match, mismatch, score = diagnoser(patient, merged_spec)
#print(f"match:{match:<1}, missed:{mismatch:<2}, total:{score:<2} score for {key_list}")
if score > diag_score:
diag_score = score
diagnosis = []
if score >= diag_score:
diagnosis.append(key_list)
if score == expected_score:
status="full"
else:
status="partial"
print(f"{status} total:{score:<2} matches:{match:<1}, missed:{mismatch:<2},  for {key_list}")
print(diagnosis)
#| label: medical diagnosis challange - MVP solution
import itertools
import collections
from collections import defaultdict
patient = {k:v for (k,v) in zip(letters ,(0,1,-1,0,0,-1,0,-1))}
# a metric based diagnosis
def diagnoser(patient,illness):
# takes a patient spec and an illness spec
# return a distance between patient and illness spec
match,mismatch,score = 0,0,0
for k in patient.keys():
if patient[k] == illness[k] and not patient[k] == 0:
match += 1
if not patient[k] == illness[k]:
mismatch += 1
score = match - mismatch
return match,mismatch,score
# next we find the expected coverage for a diagnosis given the patient
_,_,expected_score = diagnoser(patient, patient)
print(f"expected score for patient : {expected_score}")
print(diagnosis)
def merge(keys,maladies):
res = collections.defaultdict(int)
counter=0
for illness in keys:
counter +=1
for symptom in maladies[illness].keys():
res[symptom] += maladies[illness][symptom]
for key in res.keys():
if res[key] > 1 :
res[key] = 1
if res[key] < -1 :
res[key] = -1
return res
diag_score=0
diagnosis=[]
maldies_set = set(maladies.keys())
for comb_len in range(3):
for keys in itertools.combinations(maldies_set,comb_len):
key_list = list(keys)
key_list.sort()
if key_list not in diagnosis:
#print(key_list)
merged_spec = merge(key_list,maladies)
match, mismatch, score = diagnoser(patient, merged_spec)
#print(f"match:{match:<1}, missed:{mismatch:<2}, total:{score:<2} score for {key_list}")
if score > diag_score:
diag_score = score
diagnosis = []
if score >= diag_score:
diagnosis.append(key_list)
if score == expected_score:
status="full"
else:
status="partial"
print(f"{status} diagnosis metrics: score:{score:<2} hits:{match:<1}, misses:{mismatch:<2}, for {key_list}")
print(diagnosis)
#| label: medical diagnosis challange - MVP solution
import itertools
import collections
from collections import defaultdict
patient = {k:v for (k,v) in zip(letters ,(0,1,-1,0,0,-1,0,-1))}
# a metric based diagnosis
def diagnoser(patient,illness):
# takes a patient spec and an illness spec
# return a distance between patient and illness spec
match,mismatch,score = 0,0,0
for k in patient.keys():
if patient[k] == illness[k] and not patient[k] == 0:
match += 1
if not patient[k] == illness[k]:
mismatch += 1
score = match - mismatch
return match,mismatch,score
# next we find the expected coverage for a diagnosis given the patient
_,_,expected_score = diagnoser(patient, patient)
print(f"expected score for patient : {expected_score}")
print(diagnosis)
def merge(keys,maladies):
res = collections.defaultdict(int)
counter=0
for illness in keys:
counter +=1
for symptom in maladies[illness].keys():
res[symptom] += maladies[illness][symptom]
for key in res.keys():
if res[key] > 1 :
res[key] = 1
if res[key] < -1 :
res[key] = -1
return res
diag_score=0
diagnosis=[]
maldies_set = set(maladies.keys())
for comb_len in range(3):
for keys in itertools.combinations(maldies_set,comb_len):
key_list = list(keys)
key_list.sort()
if key_list not in diagnosis:
#print(key_list)
merged_spec = merge(key_list,maladies)
match, mismatch, score = diagnoser(patient, merged_spec)
#print(f"match:{match:<1}, missed:{mismatch:<2}, total:{score:<2} score for {key_list}")
if score > diag_score:
diag_score = score
diagnosis = []
if score >= diag_score:
diagnosis.append(key_list)
if score == expected_score:
status="full"
else:
status="partial"
print(f"{status:<5} diagnosis metrics: score:{score:<2} hits:{match:<1}, misses:{mismatch:<2}, for {key_list}")
print(diagnosis)
