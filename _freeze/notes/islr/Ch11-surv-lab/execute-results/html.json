{
  "hash": "f18f44f9b1e55cea9e949b090df0f534",
  "result": {
    "engine": "jupyter",
    "markdown": "---\njupyter:\n  jupytext:\n    cell_metadata_filter: '-all'\n    main_language: python\n    notebook_metadata_filter: '-all'\n  kernelspec:\n    display_name: Python 3\n    language: python\n    name: python3\n---\n\n\n\n\n\n# Survival Analysis\n\n<a target=\"_blank\" href=\"https://colab.research.google.com/github/intro-stat-learning/ISLP_labs/blob/v2.2/Ch11-surv-lab.ipynb\">\n<img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/>\n</a>\n\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/intro-stat-learning/ISLP_labs/v2.2?labpath=Ch11-surv-lab.ipynb)\n\n In this lab, we perform survival analyses on three separate data\nsets. In  Section~\\ref{brain.cancer.sec} we analyze the  `BrainCancer` \ndata  that was first described in Section~\\ref{sec:KM}. In Section~\\ref{time.to.pub.sec}, we examine the  `Publication` \ndata  from Section~\\ref{sec:pub}. Finally,  Section~\\ref{call.center.sec}  explores\na simulated call-center data set.\n\nWe begin by importing some of our libraries at this top\nlevel. This makes the code more readable, as scanning the first few\nlines of the notebook tell us what libraries are used in this\nnotebook.\n\n::: {#fa82a354 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:54.685557Z\",\"iopub.status.busy\":\"2024-06-04T23:19:54.685198Z\",\"iopub.status.idle\":\"2024-06-04T23:19:55.549394Z\",\"shell.execute_reply\":\"2024-06-04T23:19:55.549100Z\"}' execution_count=1}\n``` {.python .cell-code}\nfrom matplotlib.pyplot import subplots\nimport numpy as np\nimport pandas as pd\nfrom ISLP.models import ModelSpec as MS\nfrom ISLP import load_data\n```\n:::\n\n\nWe  also collect the new imports\nneeded for this lab.\n\n::: {#7d889aa8 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:55.551082Z\",\"iopub.status.busy\":\"2024-06-04T23:19:55.550950Z\",\"iopub.status.idle\":\"2024-06-04T23:19:55.640426Z\",\"shell.execute_reply\":\"2024-06-04T23:19:55.640185Z\"}' execution_count=2}\n``` {.python .cell-code}\nfrom lifelines import \\\n     (KaplanMeierFitter,\n      CoxPHFitter)\nfrom lifelines.statistics import \\\n     (logrank_test,\n      multivariate_logrank_test)\nfrom ISLP.survival import sim_time\n```\n:::\n\n\n## Brain Cancer Data\n\nWe begin with the `BrainCancer` data set, contained in the `ISLP` package.\n\n::: {#4a963beb .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:55.642112Z\",\"iopub.status.busy\":\"2024-06-04T23:19:55.642009Z\",\"iopub.status.idle\":\"2024-06-04T23:19:55.647994Z\",\"shell.execute_reply\":\"2024-06-04T23:19:55.647761Z\"}' execution_count=3}\n``` {.python .cell-code}\nBrainCancer = load_data('BrainCancer')\nBrainCancer.columns\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nIndex(['sex', 'diagnosis', 'loc', 'ki', 'gtv', 'stereo', 'status', 'time'], dtype='object')\n```\n:::\n:::\n\n\nThe rows index the 88 patients, while the 8 columns contain the predictors and outcome variables.\nWe first briefly examine the data.\n\n::: {#e59b6ab3 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:55.649419Z\",\"iopub.status.busy\":\"2024-06-04T23:19:55.649331Z\",\"iopub.status.idle\":\"2024-06-04T23:19:55.651992Z\",\"shell.execute_reply\":\"2024-06-04T23:19:55.651800Z\"}' execution_count=4}\n``` {.python .cell-code}\nBrainCancer['sex'].value_counts()\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nsex\nFemale    45\nMale      43\nName: count, dtype: int64\n```\n:::\n:::\n\n\n\n::: {#96e8245f .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:55.653141Z\",\"iopub.status.busy\":\"2024-06-04T23:19:55.653065Z\",\"iopub.status.idle\":\"2024-06-04T23:19:55.655301Z\",\"shell.execute_reply\":\"2024-06-04T23:19:55.655136Z\"}' execution_count=5}\n``` {.python .cell-code}\nBrainCancer['diagnosis'].value_counts()\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\ndiagnosis\nMeningioma    42\nHG glioma     22\nOther         14\nLG glioma      9\nName: count, dtype: int64\n```\n:::\n:::\n\n\n\n::: {#cf2f5af0 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:55.656326Z\",\"iopub.status.busy\":\"2024-06-04T23:19:55.656246Z\",\"iopub.status.idle\":\"2024-06-04T23:19:55.658308Z\",\"shell.execute_reply\":\"2024-06-04T23:19:55.658119Z\"}' execution_count=6}\n``` {.python .cell-code}\nBrainCancer['status'].value_counts()\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nstatus\n0    53\n1    35\nName: count, dtype: int64\n```\n:::\n:::\n\n\n\nBefore beginning an analysis, it is important to know how the\n`status` variable has been coded.  Most software\nuses the convention that a `status` of 1 indicates an\nuncensored observation (often death), and a `status` of 0 indicates a censored\nobservation. But some scientists might use the opposite coding. For\nthe  `BrainCancer`  data set 35 patients died before the end of\nthe study, so we are using the conventional coding.\n\nTo begin the analysis, we re-create  the Kaplan-Meier survival curve shown in Figure~\\ref{fig:survbrain}. The main\npackage we will use for survival analysis\nis `lifelines`.\nThe variable  `time`  corresponds to $y_i$, the time to the $i$th event (either censoring or\ndeath). The first argument to `km.fit` is the event time, and the\nsecond argument is the censoring variable, with a 1 indicating an observed\nfailure time. The `plot()` method produces a survival curve with pointwise confidence\nintervals. By default, these are  90% confidence intervals, but this can be changed\nby setting the `alpha` argument to one minus the desired\nconfidence level.\n\n::: {#06057175 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:55.659492Z\",\"iopub.status.busy\":\"2024-06-04T23:19:55.659420Z\",\"iopub.status.idle\":\"2024-06-04T23:19:55.846265Z\",\"shell.execute_reply\":\"2024-06-04T23:19:55.845461Z\"}' execution_count=7}\n``` {.python .cell-code}\nfig, ax = subplots(figsize=(8,8))\nkm = KaplanMeierFitter()\nkm_brain = km.fit(BrainCancer['time'], BrainCancer['status'])\nkm_brain.plot(label='Kaplan Meier estimate', ax=ax)\n```\n\n::: {.cell-output .cell-output-display}\n![](Ch11-surv-lab_files/figure-html/cell-8-output-1.png){width=645 height=651}\n:::\n:::\n\n\nNext we create Kaplan-Meier survival curves that are stratified by\n`sex`, in order to reproduce  Figure~\\ref{fig:survbrain2}.\nWe  do this using the `groupby()` method of  a  dataframe.\nThis  method returns a generator that can\nbe  iterated over in the `for` loop. In this case,\nthe  items  in the `for` loop are  2-tuples  representing\nthe groups: the first entry is the  value\nof the grouping column  `sex` while the  second  value\nis the dataframe consisting of all  rows in the\ndataframe matching that value of `sex`.\nWe will want to use this data below\nin the log-rank test,  hence we store this\ninformation in the dictionary `by_sex`. Finally,\nwe have also used the notion of\n *string interpolation* to automatically\nlabel the  different lines in the  plot. String\ninterpolation is a powerful technique to format strings ---\n`Python` has many ways to facilitate such operations.\n\n::: {#b3f92a34 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:55.849368Z\",\"iopub.status.busy\":\"2024-06-04T23:19:55.849075Z\",\"iopub.status.idle\":\"2024-06-04T23:19:55.960684Z\",\"shell.execute_reply\":\"2024-06-04T23:19:55.960431Z\"}' execution_count=8}\n``` {.python .cell-code}\nfig, ax = subplots(figsize=(8,8))\nby_sex = {}\nfor sex, df in BrainCancer.groupby('sex'):\n    by_sex[sex] = df\n    km_sex = km.fit(df['time'], df['status'])\n    km_sex.plot(label='Sex=%s' % sex, ax=ax)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/tmp/ipykernel_35942/3279415391.py:3: FutureWarning:\n\nThe default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](Ch11-surv-lab_files/figure-html/cell-9-output-2.png){width=645 height=651}\n:::\n:::\n\n\nAs discussed in Section~\\ref{sec:logrank}, we can perform a\nlog-rank test to compare the survival of males to females. We use\nthe `logrank_test()` function from the `lifelines.statistics` module.\nThe first two arguments are the event times, with the second\ndenoting the corresponding (optional) censoring indicators.\n\n::: {#93021a44 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:55.962264Z\",\"iopub.status.busy\":\"2024-06-04T23:19:55.962134Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.004551Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.004317Z\"}' execution_count=9}\n``` {.python .cell-code}\nlogrank_test(by_sex['Male']['time'],\n             by_sex['Female']['time'],\n             by_sex['Male']['status'],\n             by_sex['Female']['status'])\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <tbody>\n    <tr>\n      <th>t_0</th>\n      <td>-1</td>\n    </tr>\n    <tr>\n      <th>null_distribution</th>\n      <td>chi squared</td>\n    </tr>\n    <tr>\n      <th>degrees_of_freedom</th>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>test_name</th>\n      <td>logrank_test</td>\n    </tr>\n  </tbody>\n</table>\n</div><table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>test_statistic</th>\n      <th>p</th>\n      <th>-log2(p)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1.44</td>\n      <td>0.23</td>\n      <td>2.12</td>\n    </tr>\n  </tbody>\n</table>\n```\n:::\n:::\n\n\n\nThe resulting $p$-value is $0.23$, indicating no evidence of a\ndifference in survival between the two sexes.\n\nNext, we  use the `CoxPHFitter()`  estimator\nfrom `lifelines` to fit Cox proportional hazards models.\nTo begin, we consider a model that uses  `sex`  as the only predictor.\n\n::: {#8ef58e04 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.005821Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.005710Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.022741Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.022512Z\"}' execution_count=10}\n``` {.python .cell-code}\ncoxph = CoxPHFitter # shorthand\nsex_df = BrainCancer[['time', 'status', 'sex']]\nmodel_df = MS(['time', 'status', 'sex'],\n              intercept=False).fit_transform(sex_df)\ncox_fit = coxph().fit(model_df,\n                      'time',\n                      'status')\ncox_fit.summary[['coef', 'se(coef)', 'p']]\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>coef</th>\n      <th>se(coef)</th>\n      <th>p</th>\n    </tr>\n    <tr>\n      <th>covariate</th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>sex[Male]</th>\n      <td>0.407668</td>\n      <td>0.342004</td>\n      <td>0.233262</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe first argument to `fit` should be a data frame containing\nat least the event time (the second argument `time` in this case),\nas well as an optional censoring variable (the argument `status` in this case).\nNote also that the Cox model does not include an intercept, which is why\nwe used the `intercept=False` argument to `ModelSpec` above.\nThe `summary()` method delivers many columns; we chose to abbreviate its output here.\nIt is possible to obtain the likelihood ratio test comparing this model to the one\nwith no features as follows:\n\n::: {#3b342b51 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.024051Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.023976Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.028225Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.027998Z\"}' execution_count=11}\n``` {.python .cell-code}\ncox_fit.log_likelihood_ratio_test()\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <tbody>\n    <tr>\n      <th>null_distribution</th>\n      <td>chi squared</td>\n    </tr>\n    <tr>\n      <th>degrees_freedom</th>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>test_name</th>\n      <td>log-likelihood ratio test</td>\n    </tr>\n  </tbody>\n</table>\n</div><table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>test_statistic</th>\n      <th>p</th>\n      <th>-log2(p)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1.44</td>\n      <td>0.23</td>\n      <td>2.12</td>\n    </tr>\n  </tbody>\n</table>\n```\n:::\n:::\n\n\nRegardless of which test we use, we see that there is no clear\nevidence for a difference in survival between males and females.  As\nwe learned in this chapter, the score test from the Cox model is\nexactly equal to the log rank test statistic!\n\nNow we fit a  model that makes use of additional predictors. We first note\nthat one of our `diagnosis` values is missing, hence\nwe drop that observation before continuing.\n\n::: {#d70d9f26 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.029525Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.029451Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.055622Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.055386Z\"}' execution_count=12}\n``` {.python .cell-code}\ncleaned = BrainCancer.dropna()\nall_MS = MS(cleaned.columns, intercept=False)\nall_df = all_MS.fit_transform(cleaned)\nfit_all = coxph().fit(all_df,\n                      'time',\n                      'status')\nfit_all.summary[['coef', 'se(coef)', 'p']]\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>coef</th>\n      <th>se(coef)</th>\n      <th>p</th>\n    </tr>\n    <tr>\n      <th>covariate</th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>sex[Male]</th>\n      <td>0.183748</td>\n      <td>0.360358</td>\n      <td>0.610119</td>\n    </tr>\n    <tr>\n      <th>diagnosis[LG glioma]</th>\n      <td>-1.239530</td>\n      <td>0.579555</td>\n      <td>0.032455</td>\n    </tr>\n    <tr>\n      <th>diagnosis[Meningioma]</th>\n      <td>-2.154566</td>\n      <td>0.450524</td>\n      <td>0.000002</td>\n    </tr>\n    <tr>\n      <th>diagnosis[Other]</th>\n      <td>-1.268870</td>\n      <td>0.617672</td>\n      <td>0.039949</td>\n    </tr>\n    <tr>\n      <th>loc[Supratentorial]</th>\n      <td>0.441195</td>\n      <td>0.703669</td>\n      <td>0.530665</td>\n    </tr>\n    <tr>\n      <th>ki</th>\n      <td>-0.054955</td>\n      <td>0.018314</td>\n      <td>0.002693</td>\n    </tr>\n    <tr>\n      <th>gtv</th>\n      <td>0.034293</td>\n      <td>0.022333</td>\n      <td>0.124661</td>\n    </tr>\n    <tr>\n      <th>stereo[SRT]</th>\n      <td>0.177778</td>\n      <td>0.601578</td>\n      <td>0.767597</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n The `diagnosis` variable has been coded so that the baseline\ncorresponds to HG glioma. The results indicate that the risk associated with HG glioma\nis more than eight times (i.e. $e^{2.15}=8.62$) the risk associated\nwith meningioma. In other words, after adjusting for the other\npredictors, patients with HG glioma have much worse survival compared\nto those with meningioma.  In addition, larger values of the Karnofsky\nindex, `ki`, are associated with lower risk, i.e. longer survival.\n\nFinally, we plot estimated survival curves for each diagnosis category,\nadjusting for the other predictors.  To make these plots, we set the\nvalues of the other predictors equal to the mean for quantitative variables\nand equal to the mode for categorical. To do this, we use the\n`apply()` method across rows (i.e. `axis=0`) with a function\n`representative` that checks if a column is categorical\nor not.\n\n::: {#20ed8808 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.056935Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.056860Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.059439Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.059190Z\"}' execution_count=13}\n``` {.python .cell-code}\nlevels = cleaned['diagnosis'].unique()\ndef representative(series):\n    if hasattr(series.dtype, 'categories'):\n        return pd.Series.mode(series)\n    else:\n        return series.mean()\nmodal_data = cleaned.apply(representative, axis=0)\n```\n:::\n\n\nWe make four\ncopies of the column means and assign the `diagnosis` column to be the four different\ndiagnoses.\n\n::: {#ffef3971 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.060778Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.060701Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.065090Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.064856Z\"}' execution_count=14}\n``` {.python .cell-code}\nmodal_df = pd.DataFrame(\n              [modal_data.iloc[0] for _ in range(len(levels))])\nmodal_df['diagnosis'] = levels\nmodal_df\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>sex</th>\n      <th>diagnosis</th>\n      <th>loc</th>\n      <th>ki</th>\n      <th>gtv</th>\n      <th>stereo</th>\n      <th>status</th>\n      <th>time</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Female</td>\n      <td>Meningioma</td>\n      <td>Supratentorial</td>\n      <td>80.91954</td>\n      <td>8.687011</td>\n      <td>SRT</td>\n      <td>0.402299</td>\n      <td>27.188621</td>\n    </tr>\n    <tr>\n      <th>0</th>\n      <td>Female</td>\n      <td>HG glioma</td>\n      <td>Supratentorial</td>\n      <td>80.91954</td>\n      <td>8.687011</td>\n      <td>SRT</td>\n      <td>0.402299</td>\n      <td>27.188621</td>\n    </tr>\n    <tr>\n      <th>0</th>\n      <td>Female</td>\n      <td>LG glioma</td>\n      <td>Supratentorial</td>\n      <td>80.91954</td>\n      <td>8.687011</td>\n      <td>SRT</td>\n      <td>0.402299</td>\n      <td>27.188621</td>\n    </tr>\n    <tr>\n      <th>0</th>\n      <td>Female</td>\n      <td>Other</td>\n      <td>Supratentorial</td>\n      <td>80.91954</td>\n      <td>8.687011</td>\n      <td>SRT</td>\n      <td>0.402299</td>\n      <td>27.188621</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe then construct the model matrix based on the model specification `all_MS` used to fit\nthe model, and name the rows according to the levels of `diagnosis`.\n\n::: {#47b5ff20 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.066333Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.066235Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.073007Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.072802Z\"}' execution_count=15}\n``` {.python .cell-code}\nmodal_X = all_MS.transform(modal_df)\nmodal_X.index = levels\nmodal_X\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>sex[Male]</th>\n      <th>diagnosis[LG glioma]</th>\n      <th>diagnosis[Meningioma]</th>\n      <th>diagnosis[Other]</th>\n      <th>loc[Supratentorial]</th>\n      <th>ki</th>\n      <th>gtv</th>\n      <th>stereo[SRT]</th>\n      <th>status</th>\n      <th>time</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Meningioma</th>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>80.91954</td>\n      <td>8.687011</td>\n      <td>1.0</td>\n      <td>0.402299</td>\n      <td>27.188621</td>\n    </tr>\n    <tr>\n      <th>HG glioma</th>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>80.91954</td>\n      <td>8.687011</td>\n      <td>1.0</td>\n      <td>0.402299</td>\n      <td>27.188621</td>\n    </tr>\n    <tr>\n      <th>LG glioma</th>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>80.91954</td>\n      <td>8.687011</td>\n      <td>1.0</td>\n      <td>0.402299</td>\n      <td>27.188621</td>\n    </tr>\n    <tr>\n      <th>Other</th>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>1.0</td>\n      <td>80.91954</td>\n      <td>8.687011</td>\n      <td>1.0</td>\n      <td>0.402299</td>\n      <td>27.188621</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe can use the `predict_survival_function()` method to obtain the estimated survival function.\n\n::: {#4e560f69 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.074287Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.074217Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.079015Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.078796Z\"}' execution_count=16}\n``` {.python .cell-code}\npredicted_survival = fit_all.predict_survival_function(modal_X)\npredicted_survival\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Meningioma</th>\n      <th>HG glioma</th>\n      <th>LG glioma</th>\n      <th>Other</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0.07</th>\n      <td>0.997947</td>\n      <td>0.982430</td>\n      <td>0.994881</td>\n      <td>0.995029</td>\n    </tr>\n    <tr>\n      <th>1.18</th>\n      <td>0.997947</td>\n      <td>0.982430</td>\n      <td>0.994881</td>\n      <td>0.995029</td>\n    </tr>\n    <tr>\n      <th>1.41</th>\n      <td>0.995679</td>\n      <td>0.963342</td>\n      <td>0.989245</td>\n      <td>0.989555</td>\n    </tr>\n    <tr>\n      <th>1.54</th>\n      <td>0.995679</td>\n      <td>0.963342</td>\n      <td>0.989245</td>\n      <td>0.989555</td>\n    </tr>\n    <tr>\n      <th>2.03</th>\n      <td>0.995679</td>\n      <td>0.963342</td>\n      <td>0.989245</td>\n      <td>0.989555</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>65.02</th>\n      <td>0.688772</td>\n      <td>0.040136</td>\n      <td>0.394181</td>\n      <td>0.404936</td>\n    </tr>\n    <tr>\n      <th>67.38</th>\n      <td>0.688772</td>\n      <td>0.040136</td>\n      <td>0.394181</td>\n      <td>0.404936</td>\n    </tr>\n    <tr>\n      <th>73.74</th>\n      <td>0.688772</td>\n      <td>0.040136</td>\n      <td>0.394181</td>\n      <td>0.404936</td>\n    </tr>\n    <tr>\n      <th>78.75</th>\n      <td>0.688772</td>\n      <td>0.040136</td>\n      <td>0.394181</td>\n      <td>0.404936</td>\n    </tr>\n    <tr>\n      <th>82.56</th>\n      <td>0.688772</td>\n      <td>0.040136</td>\n      <td>0.394181</td>\n      <td>0.404936</td>\n    </tr>\n  </tbody>\n</table>\n<p>85 rows × 4 columns</p>\n</div>\n```\n:::\n:::\n\n\nThis returns a data frame,\nwhose plot methods yields the different survival curves. To avoid clutter in\nthe plots, we do not display confidence intervals.\n\n::: {#8f60d029 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.080399Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.080330Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.151344Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.151104Z\"}' execution_count=17}\n``` {.python .cell-code}\nfig, ax = subplots(figsize=(8, 8))\npredicted_survival.plot(ax=ax);\n```\n\n::: {.cell-output .cell-output-display}\n![](Ch11-surv-lab_files/figure-html/cell-18-output-1.png){width=645 height=633}\n:::\n:::\n\n\n\n## Publication Data\nThe  `Publication`  data   presented in Section~\\ref{sec:pub}  can be\nfound in the `ISLP` package.\nWe first reproduce Figure~\\ref{fig:lauersurv}  by plotting the Kaplan-Meier curves\nstratified on the  `posres`  variable, which records whether the\nstudy had a positive or negative result.\n\n::: {#bdeb4c50 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.152821Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.152701Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.230052Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.229811Z\"}' execution_count=18}\n``` {.python .cell-code}\nfig, ax = subplots(figsize=(8,8))\nPublication = load_data('Publication')\nby_result = {}\nfor result, df in Publication.groupby('posres'):\n    by_result[result] = df\n    km_result = km.fit(df['time'], df['status'])\n    km_result.plot(label='Result=%d' % result, ax=ax)\n```\n\n::: {.cell-output .cell-output-display}\n![](Ch11-surv-lab_files/figure-html/cell-19-output-1.png){width=645 height=651}\n:::\n:::\n\n\nAs discussed previously, the $p$-values from fitting Cox’s\nproportional hazards model to the `posres` variable are quite\nlarge, providing no evidence of a difference in time-to-publication\nbetween studies with positive versus negative results.\n\n::: {#49436819 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.231448Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.231371Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.253732Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.253504Z\"}' execution_count=19}\n``` {.python .cell-code}\nposres_df = MS(['posres',\n                'time',\n                'status'],\n                intercept=False).fit_transform(Publication)\nposres_fit = coxph().fit(posres_df,\n                         'time',\n                         'status')\nposres_fit.summary[['coef', 'se(coef)', 'p']]\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>coef</th>\n      <th>se(coef)</th>\n      <th>p</th>\n    </tr>\n    <tr>\n      <th>covariate</th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>posres</th>\n      <td>0.148076</td>\n      <td>0.161625</td>\n      <td>0.359579</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n\nHowever, the results change dramatically when we include other\npredictors in the model. Here we exclude the funding mechanism\nvariable.\n\n::: {#2300f301 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.255073Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.255003Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.284350Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.284045Z\"}' execution_count=20}\n``` {.python .cell-code}\nmodel = MS(Publication.columns.drop('mech'),\n           intercept=False)\ncoxph().fit(model.fit_transform(Publication),\n            'time',\n            'status').summary[['coef', 'se(coef)', 'p']]\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>coef</th>\n      <th>se(coef)</th>\n      <th>p</th>\n    </tr>\n    <tr>\n      <th>covariate</th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>posres</th>\n      <td>0.570773</td>\n      <td>0.175960</td>\n      <td>1.179610e-03</td>\n    </tr>\n    <tr>\n      <th>multi</th>\n      <td>-0.040860</td>\n      <td>0.251194</td>\n      <td>8.707842e-01</td>\n    </tr>\n    <tr>\n      <th>clinend</th>\n      <td>0.546183</td>\n      <td>0.262000</td>\n      <td>3.709944e-02</td>\n    </tr>\n    <tr>\n      <th>sampsize</th>\n      <td>0.000005</td>\n      <td>0.000015</td>\n      <td>7.507005e-01</td>\n    </tr>\n    <tr>\n      <th>budget</th>\n      <td>0.004386</td>\n      <td>0.002465</td>\n      <td>7.515984e-02</td>\n    </tr>\n    <tr>\n      <th>impact</th>\n      <td>0.058318</td>\n      <td>0.006676</td>\n      <td>2.426306e-18</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe see that there are a number of statistically significant variables,\nincluding whether the trial focused on a clinical endpoint, the impact\nof the study, and whether the study had positive or negative results.\n\n## Call Center Data\n\nIn this section, we will simulate survival data using the relationship\nbetween cumulative hazard and\nthe survival function explored in Exercise \\ref{ex:all3}.\nOur simulated data will represent the observed\nwait times (in seconds) for 2,000 customers who have phoned a call\ncenter.  In this context, censoring occurs if a customer hangs up\nbefore his or her call is answered.\n\nThere are three covariates: `Operators` (the number of call\ncenter operators available at the time of the call, which can range\nfrom $5$ to $15$), `Center` (either A, B, or C), and\n`Time` of day (Morning, Afternoon, or Evening). We generate data\nfor these covariates so that all possibilities are equally likely: for\ninstance, morning, afternoon and evening calls are equally likely, and\nany number of operators from $5$ to $15$ is equally likely. \n\n::: {#9863b353 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.285647Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.285576Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.288228Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.287999Z\"}' execution_count=21}\n``` {.python .cell-code}\nrng = np.random.default_rng(10)\nN = 2000\nOperators = rng.choice(np.arange(5, 16),\n                       N,\n                       replace=True)\nCenter = rng.choice(['A', 'B', 'C'],\n                    N,\n                    replace=True)\nTime = rng.choice(['Morn.', 'After.', 'Even.'],\n                   N,\n                   replace=True)\nD = pd.DataFrame({'Operators': Operators,\n                  'Center': pd.Categorical(Center),\n                  'Time': pd.Categorical(Time)})\n```\n:::\n\n\nWe then build a model matrix (omitting the intercept)\n\n::: {#0f3094ef .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.289419Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.289350Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.295467Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.295239Z\"}' execution_count=22}\n``` {.python .cell-code}\nmodel = MS(['Operators',\n            'Center',\n            'Time'],\n           intercept=False)\nX = model.fit_transform(D)\n```\n:::\n\n\nIt is worthwhile to take a peek at the model matrix `X`, so\nthat we can be sure that we understand how the variables have been coded. By default,\nthe levels of categorical variables are sorted and, as usual, the first column of the one-hot encoding\nof the variable is dropped.\n\n::: {#851b7ea4 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.296977Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.296905Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.300297Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.300080Z\"}' execution_count=23}\n``` {.python .cell-code}\nX[:5]\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Operators</th>\n      <th>Center[B]</th>\n      <th>Center[C]</th>\n      <th>Time[Even.]</th>\n      <th>Time[Morn.]</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>13</td>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>15</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>7</td>\n      <td>1.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>7</td>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>13</td>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>1.0</td>\n      <td>0.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNext,  we specify the coefficients and the hazard function.\n\n::: {#bc08643a .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.301604Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.301530Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.305801Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.305262Z\"}' execution_count=24}\n``` {.python .cell-code}\ntrue_beta = np.array([0.04, -0.3, 0, 0.2, -0.2])\ntrue_linpred = X.dot(true_beta)\nhazard = lambda t: 1e-5 * t\n```\n:::\n\n\nHere, we have set the coefficient associated with `Operators` to\nequal $0.04$; in other words, each additional operator leads to a\n$e^{0.04}=1.041$-fold increase in the “risk” that the call will be\nanswered, given the `Center` and `Time` covariates. This\nmakes sense: the greater the number of operators at hand, the shorter\nthe wait time! The coefficient associated with `Center == B` is\n$-0.3$, and `Center == A` is treated as the baseline. This means\nthat the risk of a call being answered at Center B is 0.74 times the\nrisk that it will be answered at Center A; in other words, the wait\ntimes are a bit longer at Center B.\n\nRecall from Section~\\ref{Ch2-statlearn-lab:loading-data} the use of `lambda`\nfor creating short functions on the fly.\nWe use the function\n`sim_time()` from the `ISLP.survival` package. This function\nuses the relationship between the survival function\nand cumulative hazard $S(t) = \\exp(-H(t))$ and the specific\nform of the cumulative hazard function in the Cox model\nto simulate data based on values of the linear predictor\n`true_linpred` and the cumulative hazard. \n We need to provide the cumulative hazard function, which we do here.\n\n::: {#2a9c717e .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.310515Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.310277Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.313678Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.312612Z\"}' execution_count=25}\n``` {.python .cell-code}\ncum_hazard = lambda t: 1e-5 * t**2 / 2\n```\n:::\n\n\nWe are now ready to generate data under the Cox proportional hazards\nmodel. We truncate the maximum time to 1000 seconds to keep\nsimulated wait times reasonable. The function\n`sim_time()` takes a linear predictor,\na cumulative hazard function and a\nrandom number generator.\n\n::: {#7dc2610c .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.316852Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.316648Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.419919Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.419384Z\"}' execution_count=26}\n``` {.python .cell-code}\nW = np.array([sim_time(l, cum_hazard, rng)\n              for l in true_linpred])\nD['Wait time'] = np.clip(W, 0, 1000)\n```\n:::\n\n\nWe now simulate our censoring variable, for which we assume\n90% of calls were answered (`Failed==1`) before the\ncustomer hung up (`Failed==0`).\n\n::: {#fa9cd321 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.423676Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.423359Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.434279Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.433259Z\"}' execution_count=27}\n``` {.python .cell-code}\nD['Failed'] = rng.choice([1, 0],\n                         N,\n                         p=[0.9, 0.1])\nD[:5]\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Operators</th>\n      <th>Center</th>\n      <th>Time</th>\n      <th>Wait time</th>\n      <th>Failed</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>13</td>\n      <td>C</td>\n      <td>After.</td>\n      <td>525.064979</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>15</td>\n      <td>A</td>\n      <td>Even.</td>\n      <td>254.677835</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>7</td>\n      <td>B</td>\n      <td>Morn.</td>\n      <td>487.739224</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>7</td>\n      <td>C</td>\n      <td>Morn.</td>\n      <td>308.580292</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>13</td>\n      <td>C</td>\n      <td>Even.</td>\n      <td>154.174608</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n\n::: {#f0679404 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.437399Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.437090Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.442236Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.441064Z\"}' execution_count=28}\n``` {.python .cell-code}\nD['Failed'].mean()\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n0.9075\n```\n:::\n:::\n\n\nWe now plot  Kaplan-Meier survival curves. First, we stratify by `Center`.\n\n::: {#9a505728 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.445459Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.445197Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.618294Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.618033Z\"}' execution_count=29}\n``` {.python .cell-code}\nfig, ax = subplots(figsize=(8,8))\nby_center = {}\nfor center, df in D.groupby('Center'):\n    by_center[center] = df\n    km_center = km.fit(df['Wait time'], df['Failed'])\n    km_center.plot(label='Center=%s' % center, ax=ax)\nax.set_title(\"Probability of Still Being on Hold\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/tmp/ipykernel_35942/141205229.py:3: FutureWarning:\n\nThe default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\nText(0.5, 1.0, 'Probability of Still Being on Hold')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](Ch11-surv-lab_files/figure-html/cell-30-output-3.png){width=645 height=671}\n:::\n:::\n\n\nNext, we stratify by `Time`.\n\n::: {#ee98c701 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.619764Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.619647Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.725906Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.725634Z\"}' execution_count=30}\n``` {.python .cell-code}\nfig, ax = subplots(figsize=(8,8))\nby_time = {}\nfor time, df in D.groupby('Time'):\n    by_time[time] = df\n    km_time = km.fit(df['Wait time'], df['Failed'])\n    km_time.plot(label='Time=%s' % time, ax=ax)\nax.set_title(\"Probability of Still Being on Hold\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/tmp/ipykernel_35942/1980626088.py:3: FutureWarning:\n\nThe default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\nText(0.5, 1.0, 'Probability of Still Being on Hold')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](Ch11-surv-lab_files/figure-html/cell-31-output-3.png){width=645 height=671}\n:::\n:::\n\n\nIt seems that calls at Call Center B take longer to be answered than\ncalls at Centers A and C. Similarly, it appears that wait times are\nlongest in the morning and shortest in the evening hours. We can use a\nlog-rank test to determine whether these differences are statistically\nsignificant using the function `multivariate_logrank_test()`.\n\n::: {#bc7212e8 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.727330Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.727224Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.739716Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.739485Z\"}' execution_count=31}\n``` {.python .cell-code}\nmultivariate_logrank_test(D['Wait time'],\n                          D['Center'],\n                          D['Failed'])\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <tbody>\n    <tr>\n      <th>t_0</th>\n      <td>-1</td>\n    </tr>\n    <tr>\n      <th>null_distribution</th>\n      <td>chi squared</td>\n    </tr>\n    <tr>\n      <th>degrees_of_freedom</th>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>test_name</th>\n      <td>multivariate_logrank_test</td>\n    </tr>\n  </tbody>\n</table>\n</div><table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>test_statistic</th>\n      <th>p</th>\n      <th>-log2(p)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>20.30</td>\n      <td>&lt;0.005</td>\n      <td>14.65</td>\n    </tr>\n  </tbody>\n</table>\n```\n:::\n:::\n\n\n\nNext, we consider the  effect of `Time`.\n\n::: {#6a2165a5 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.741062Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.740984Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.753655Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.753435Z\"}' execution_count=32}\n``` {.python .cell-code}\nmultivariate_logrank_test(D['Wait time'],\n                          D['Time'],\n                          D['Failed'])\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <tbody>\n    <tr>\n      <th>t_0</th>\n      <td>-1</td>\n    </tr>\n    <tr>\n      <th>null_distribution</th>\n      <td>chi squared</td>\n    </tr>\n    <tr>\n      <th>degrees_of_freedom</th>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>test_name</th>\n      <td>multivariate_logrank_test</td>\n    </tr>\n  </tbody>\n</table>\n</div><table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>test_statistic</th>\n      <th>p</th>\n      <th>-log2(p)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>49.90</td>\n      <td>&lt;0.005</td>\n      <td>35.99</td>\n    </tr>\n  </tbody>\n</table>\n```\n:::\n:::\n\n\n\nAs in the case of a categorical variable with 2 levels, these\nresults are similar to the likelihood ratio test\nfrom the Cox proportional hazards model. First, we\nlook at the results for  `Center`.\n\n::: {#c5a9cea6 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.755032Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.754959Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.856726Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.856494Z\"}' execution_count=33}\n``` {.python .cell-code}\nX = MS(['Wait time',\n        'Failed',\n        'Center'],\n        intercept=False).fit_transform(D)\nF = coxph().fit(X, 'Wait time', 'Failed')\nF.log_likelihood_ratio_test()\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <tbody>\n    <tr>\n      <th>null_distribution</th>\n      <td>chi squared</td>\n    </tr>\n    <tr>\n      <th>degrees_freedom</th>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>test_name</th>\n      <td>log-likelihood ratio test</td>\n    </tr>\n  </tbody>\n</table>\n</div><table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>test_statistic</th>\n      <th>p</th>\n      <th>-log2(p)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>20.58</td>\n      <td>&lt;0.005</td>\n      <td>14.85</td>\n    </tr>\n  </tbody>\n</table>\n```\n:::\n:::\n\n\n\nNext, we look at the results for `Time`.\n\n::: {#84710b8a .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.858260Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.858163Z\",\"iopub.status.idle\":\"2024-06-04T23:19:56.951866Z\",\"shell.execute_reply\":\"2024-06-04T23:19:56.951640Z\"}' execution_count=34}\n``` {.python .cell-code}\nX = MS(['Wait time',\n        'Failed',\n        'Time'],\n       intercept=False).fit_transform(D)\nF = coxph().fit(X, 'Wait time', 'Failed')\nF.log_likelihood_ratio_test()\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <tbody>\n    <tr>\n      <th>null_distribution</th>\n      <td>chi squared</td>\n    </tr>\n    <tr>\n      <th>degrees_freedom</th>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>test_name</th>\n      <td>log-likelihood ratio test</td>\n    </tr>\n  </tbody>\n</table>\n</div><table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>test_statistic</th>\n      <th>p</th>\n      <th>-log2(p)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>48.12</td>\n      <td>&lt;0.005</td>\n      <td>34.71</td>\n    </tr>\n  </tbody>\n</table>\n```\n:::\n:::\n\n\n\nWe find that differences between centers are highly significant, as\nare differences between times of day.\n\nFinally, we fit Cox's proportional hazards model to the data.\n\n::: {#9b536066 .cell execution='{\"iopub.execute_input\":\"2024-06-04T23:19:56.953169Z\",\"iopub.status.busy\":\"2024-06-04T23:19:56.953096Z\",\"iopub.status.idle\":\"2024-06-04T23:19:57.089908Z\",\"shell.execute_reply\":\"2024-06-04T23:19:57.089269Z\"}' execution_count=35}\n``` {.python .cell-code}\nX = MS(D.columns,\n       intercept=False).fit_transform(D)\nfit_queuing = coxph().fit(\n                  X,\n                 'Wait time',\n                 'Failed')\nfit_queuing.summary[['coef', 'se(coef)', 'p']]\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>coef</th>\n      <th>se(coef)</th>\n      <th>p</th>\n    </tr>\n    <tr>\n      <th>covariate</th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Operators</th>\n      <td>0.043934</td>\n      <td>0.007520</td>\n      <td>5.143589e-09</td>\n    </tr>\n    <tr>\n      <th>Center[B]</th>\n      <td>-0.236060</td>\n      <td>0.058113</td>\n      <td>4.864162e-05</td>\n    </tr>\n    <tr>\n      <th>Center[C]</th>\n      <td>0.012231</td>\n      <td>0.057518</td>\n      <td>8.316096e-01</td>\n    </tr>\n    <tr>\n      <th>Time[Even.]</th>\n      <td>0.268845</td>\n      <td>0.057797</td>\n      <td>3.294956e-06</td>\n    </tr>\n    <tr>\n      <th>Time[Morn.]</th>\n      <td>-0.148217</td>\n      <td>0.057334</td>\n      <td>9.733557e-03</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n\nThe $p$-values for Center B and evening time\nare very small. It is also clear that the\nhazard --- that is, the instantaneous risk that a call will be\nanswered --- increases with the number of operators. Since we\ngenerated the data ourselves, we know that the true coefficients for\n `Operators`, `Center = B`, `Center = C`, \n`Time = Even.` and `Time = Morn.`   are $0.04$, $-0.3$,\n$0$,   $0.2$, and $-0.2$, respectively. The coefficient estimates\nfrom the fitted Cox model are fairly accurate.\n\n",
    "supporting": [
      "Ch11-surv-lab_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}