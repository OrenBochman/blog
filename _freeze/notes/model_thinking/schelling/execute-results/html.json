{
  "hash": "3004719e275b8775e03a4a139294dba1",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ndraft: true\ntitle: mesa tests\n---\n\nSo this is supposed to become a python Shiney app for the schelling model\nusing mesa modeling environment.\n\n\n\nBut I soon decided to just try to get the demo notebook from [here](https://github.com/projectmesa/mesa-examples/blob/main/examples/schelling/analysis.ipynb) running!\n\n\n## Schelling Segregation Model\n\n### Background\n\nThe Schelling (1971) segregation model is a classic of agent-based modeling, demonstrating how agents following simple rules lead to the emergence of qualitatively different macro-level outcomes. Agents are randomly placed on a grid. There are two types of agents, one constituting the majority and the other the minority. All agents want a certain number (generally, 3) of their 8 surrounding neighbors to be of the same type in order for them to be happy. Unhappy agents will move to a random available grid space. While individual agents do not have a preference for a segregated outcome (e.g. they would be happy with 3 similar neighbors and 5 different ones), the aggregate outcome is nevertheless heavily segregated.\n\n## Implementation\n\nThis is a demonstration of running a Mesa model in an IPython Notebook. The actual model and agent code are implemented in `model.py`, in the same directory as this notebook. \n\nBelow, we will import the model class, instantiate it, run it, and plot the time series of the number of happy agents.\n\n```\n$ # This will install the \"mesa_models\" package\n!pip install --quiet --upgrade mesa \n!pip install -U -e git+https://github.com/projectmesa/mesa-examples#egg=mesa-models\n```\n\n::: {#bcb3bf56 .cell execution_count=1}\n``` {.python .cell-code}\nimport seaborn as sns\n\nimport matplotlib.pyplot as plt\nimport mesa_models \nfrom mesa_models.schelling.model import Schelling   \n\n%matplotlib inline\n```\n:::\n\n\nNow we instantiate a model instance: a 10x10 grid, with an 80% change of an agent being placed in each cell, approximately 20% of agents set as minorities, and agents wanting at least 3 similar neighbors.\n\n::: {#ef8da130 .cell execution_count=2}\n``` {.python .cell-code}\n#model = Schelling(height=10, width=10, homophily=0.8, radius=0.2, density=3, minority_pc=0.2, seed=None)\n\n# this model crashes\n#model = Schelling(10, 10, 0.8, 0.2, 3)\n\n# this should fix the bug from a change in the order of the variables\nmodel = Schelling(height=10, width=10,homophily=3,density=0.8,minority_pc=0.2)\n\nwhile model.running and model.schedule.steps < 100:\n    model.step()\n\nprint(model.schedule.steps)  # Show how many steps have actually run\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n100\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n/home/oren/work/blog/env/lib/python3.10/site-packages/mesa/time.py:82: FutureWarning:\n\nThe AgentSet is experimental. It may be changed or removed in any and all future releases, including patch releases.\nWe would love to hear what you think about this new feature. If you have any thoughts, share them with us here: https://github.com/projectmesa/mesa/discussions/1919\n\n```\n:::\n:::\n\n\nThe model has a DataCollector object, which checks and stores how many agents are happy at the end of each step. It can also generate a pandas DataFrame of the data it has collected:\n\n::: {#41deea6e .cell execution_count=3}\n``` {.python .cell-code}\nmodel_out = model.datacollector.get_model_vars_dataframe()\n```\n:::\n\n\n::: {#fc834f4b .cell execution_count=4}\n``` {.python .cell-code}\nmodel_out.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>happy</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>64</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>63</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>62</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>68</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nFinally, we can plot the 'happy' series:\n\n::: {#af2eab49 .cell execution_count=5}\n``` {.python .cell-code}\nmodel_out.happy.plot()\n```\n\n::: {.cell-output .cell-output-display}\n![](schelling_files/figure-html/cell-6-output-1.png){width=566 height=411}\n:::\n:::\n\n\nFor testing purposes, here is a table giving each agent's x and y values at each step.\n\n\n\n```python\n#| eval: False\n## the agent does not seem to have any tracking for x and y!?\n## so this fails\nx_positions = model.datacollector.get_agent_vars_dataframe()\n```\n\n```python\nx_positions.head()\n```\n\n\n## Effect of Homophily on segregation\n\nNow, we can do a parameter sweep to see how segregation changes with homophily.\n\nFirst, we create a function which takes a model instance and returns what fraction of agents are segregated -- that is, have no neighbors of the opposite type.\n\n",
    "supporting": [
      "schelling_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}