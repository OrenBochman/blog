{
  "hash": "cc8a83cb4f8d2137216ddaffb27730bf",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Vitter Algorithm\"\nsubtitle: \"Paper Review\"\ndate: 2025-01-01\ncategories: [review,compositionality,neural networks,signaling systems,language evolution]\nkeywords: \n    compositionality\n    naive compositionality\n    language emergence\n    deep learning\n    neural networks\n    signaling systems \n    emergent languages\n    topographic similarity\n    positional disentanglement\n    bag-of-symbols disentanglement\n    information gap disentanglement    \nbibliography: ./bibliography.bib\n---\n\n::: {#d12ac104 .cell execution_count=1}\n``` {.python .cell-code}\nimport heapq\n\nclass Node:\n    def __init__(self, char, freq):\n        self.char = char\n        self.freq = freq\n        self.left = None\n        self.right = None\n\n    def __lt__(self, other):\n        return self.freq < other.freq\n\ndef build_huffman_tree(chars_freq):\n    \"\"\"\n    Builds the Huffman tree for given character frequencies.\n\n    Args:\n        chars_freq: A dictionary of characters and their frequencies.\n\n    Returns:\n        The root of the Huffman tree.\n    \"\"\"\n    nodes = []\n    for char, freq in chars_freq.items():\n        heapq.heappush(nodes, Node(char, freq))\n\n    while len(nodes) > 1:\n        left = heapq.heappop(nodes)\n        right = heapq.heappop(nodes)\n        parent = Node(None, left.freq + right.freq)\n        parent.left = left\n        parent.right = right\n        heapq.heappush(nodes, parent)\n\n    return nodes[0]\n\ndef encode_char(root, char, code=''):\n    \"\"\"\n    Encodes a character using Huffman codes.\n\n    Args:\n        root: The root of the Huffman tree.\n        char: The character to encode.\n        code: The current code (initially empty).\n\n    Returns:\n        The Huffman code for the character.\n    \"\"\"\n    if root is None:\n        return ''\n\n    if root.char == char:\n        return code\n\n    left_code = encode_char(root.left, char, code + '0')\n    if left_code != '':\n        return left_code\n\n    right_code = encode_char(root.right, char, code + '1')\n    return right_code\n\ndef decode_char(root, code):\n    \"\"\"\n    Decodes a Huffman code to get the character.\n\n    Args:\n        root: The root of the Huffman tree.\n        code: The Huffman code to decode.\n\n    Returns:\n        The decoded character.\n    \"\"\"\n    current = root\n    for bit in code:\n        if bit == '0':\n            current = current.left\n        else:\n            current = current.right\n\n    if current.char is not None:\n        return current.char\n\ndef encode_message(root, message):\n    \"\"\"\n    Encodes a message using Huffman codes.\n\n    Args:\n        root: The root of the Huffman tree.\n        message: The message to encode.\n\n    Returns:\n        The encoded message.\n    \"\"\"\n    encoded_message = ''\n    for char in message:\n        encoded_message += encode_char(root, char)\n    return encoded_message\n\ndef decode_message(root, encoded_message):\n    \"\"\"\n    Decodes a Huffman-encoded message.\n\n    Args:\n        root: The root of the Huffman tree.\n        encoded_message: The encoded message.\n\n    Returns:\n        The decoded message.\n    \"\"\"\n    decoded_message = ''\n    current = root\n    for bit in encoded_message:\n        if bit == '0':\n            current = current.left\n        else:\n            current = current.right\n\n        if current.char is not None:\n            decoded_message += current.char\n            current = root\n\n    return decoded_message\n\n# Example usage\nchars_freq = {'a': 45, 'b': 13, 'c': 12, 'd': 16, 'e': 9, 'f': 5}\nroot = build_huffman_tree(chars_freq)\n\nmessage = \"abcdef\"\nencoded_message = encode_message(root, message)\nprint(\"Encoded message:\", encoded_message)\n\ndecoded_message = decode_message(root, encoded_message)\nprint(\"Decoded message:\", decoded_message)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEncoded message: 010110011111011100\nDecoded message: abcdef\n```\n:::\n:::\n\n\n",
    "supporting": [
      "vitter_files"
    ],
    "filters": [],
    "includes": {}
  }
}