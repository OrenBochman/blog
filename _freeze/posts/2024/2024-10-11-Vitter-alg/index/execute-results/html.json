{
  "hash": "80abea448553ac8a12819c5d2ba8c910",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ndate: 2024-10-11\nupdated: 2025-08-27\ntitle: \"Vitter's Algorithm\"\nsubtitle: \"Adaptive Huffman coding for online learning of compositional languages\"\ndescription: \"This article explores Vitter's Algorithm and its application in online learning and communication within multi-agent systems.\"\ncategories: [algorithm, compositionality, signaling systems,  language evolution]\nkeywords: [compositionality, naive compositionality, language emergence, signaling systems, emergent languages]\nbibliography: ./bibliography.bib\ncache: false\nimage: /images/cover.png\n\n---\n\nIn this article I researched Vitter's Algorithm. However the main point of this article is trying to place this algorithm as a component for planning for online learning and communication in multi-agent systems.\n\n## Online Learning of and Encoder decoder for complex states.\n\nWe have demonstrated how agents can rapidly acquire adaptive signaling systems. We have looked at how they can use Bayesian urn models to infer an optimal permutation under changing conditions. Moving on seems like crossing a massive chasm. The next step is how to generalize from simple to complex states. \n\nIntuitively we want to see if the agents can learn to evolve a grammar for encoding and decoding a large body of messages based on a smaller code book.\nIf we view this as an RL problem we might wonder if they can learn an optimal policy for encoding and decoding messages.\n\nOne problem in evolving a grammar for complex states is that poor early choices have long lasting impact on the agent's ability to communicate effectively. \n\nMy way to view the such choices are as symmetry breakings i.e. we decide pick some subset of all complex signaling systems at every step. Some choices are\nlexical but other are structural (e.g. grammar or morphology) and they will require making consistent choices. This sounds like a classic planning problem in RL.\n\n## Planning \n\nThe agents have goals beyond communications which require coordination these goals will likely shape the optimality of the language.\n\nI consider at this point I might consider four setting for complex languages:\n\n1. All states and their distributions are known to sender and receiver (fully observable) \n2. all states and their distributions are known to sender only (closed world)\n3. state and their distributions are learned from experience (steady state partially observed life long learning)\n4. states and their distributions evolve over time (partially observed non-stationary environment with life long learning)\n\nThe fully observed setting are a bit deceptive here as the lewis signaling game is based on information asymmetry. The agents may have a prior knowledge of the continuum of states but only the sender sees the current states at any point. In the last two options the states might be modeled via a Hoffe urn process that can generate new states over time. \n\nIn a bayesian view of such a world we are moving from parametric to non parametric world model. (For our language/state classifier the distinction is that for non-parametric the number of parameters in our tree is now potentially infinite though it may be easier to think of a tree that can always grow another branch or a restaurant that can always add another table or a stick that can always be broken further)\n\nBut the main point here is that the first three setting are more likely have a DSL as thier optimal language. While the last setting which is typicaly bundled with multiple evolving goals. AKA is best handled by a GNL - Generalist Natural Language.\n\nHowever in terms of the outcome if sender and reciever don't plan thier language they may still be optimal by luck. \nAlso with an RL algorithm agents should be able to recover from poor choices eventually. More so if they use a bayesian belief system to revise thier value functions.\n\n\n### An algorithmic interlude\n\nLet's take a little timeout and consider the problem of language planning.\n\nSuppose our states fit nicely in a table. We might think of a language that looks like a table.\n\n\n$$\n<f_1,f_2,f_3,...f_n> \\to <s_1,s_2,s_3,...s_n>\n$$\n\n- where f are fields and s are words\n\nwe would need unique symbols for each instance of $s\\in s_i$ or we could use lump them together as languages like german and turkish lump many words together so might do this\n\n$$\n<f_1,f_2,f_3,...f_n> \\to s_{\\{1...n\\}}\n$$\n\nThis could reduce the number of symbols we need to learn substantially from the power set of product of sub-states to the number of states. Though if our table is big there may still be much to learn.\n\nThe down side to this approach is that it would take a long time to learn this language by trial and error. The main issue here being that there are very many possible states and given $s_{\\{1...n\\}}$ might match. Also the student doesn't have any real advantage from learning a subset of the language. This is in fact the classic lewis signaling game. \n\nSo how can we do better? First we might be able to factor the table into smaller tables.\nPerhaps the first table might be correspond to NP and the second to VP. \n\n$$\n<f_1,f_2,f_3,...f_n> \\to np_{\\{1...l\\}},vp_{\\{l+1...k\\}}\n$$\n\nand to complete the language we might require a grammar that aggregates\n\n$$\ns_{\\{1...n\\}} \\equiv <np_{\\{1...l\\}},vp_{\\{l+1...k\\}}>\n$$\n\nNow we have $|n_p|*|v_p|$ symbols but perhaps some $n_p$ and $v_p$ are very rare and better yet most combinations never come up. This means we only need to learn the top $n_p$ and $v_p$ and we can get an almost perfect score at the lewis game.\n\nBut the main benefit is that we learned to top few $n_p$ and $v_p$ much sooner than the first $s_i$. What if we could do better? Isn't there a decomposition for $n_p$ and $v_p$?\n\n$$\nnp_{\\{1...n\\}} \\equiv <det_1,n_l>\n$$\n\nand \n$$\nv_p \\equiv \n\\begin{cases}\n  <v_1>--             & \\text(intransitive) \\\\\n  <v_1, n_2>       & \\text(transitive) \\\\\n  <v_1, v_2, n_2>  & \\text(modal, etc)\n\\end{cases} \n$$\n\nand we might continue by having rules for $v_p$ and $n_p$ with morphologies.\n\nWhile there is now more to learn we can learn it faster because we have to coordinate on much smaller set of sub-states, before we can (potentially) get any payoffs....\n\nIn fact we can start to get the full benefits of this grammar once we have learned to use a few items from each slot. We might be so lucky that some of the slots like determiners have only two options and that there are only a handful of pronouns.\n\nAnd since we are planning a whole language we can make everything nice and regular and we can make semantics composable from a small set of semantic atoms we use to construct our lexicon.  \n\nOk so we have sketched a case for learning a language like english which decomposes any structured construct into the smallest factors. \n\nThis has a potential for fantastic saving in the learning side of things. But to reap these benefits we might want to change the lewis game a bit. \n\nWe want to keep its main form though: States are seen by the sender, rewards are symmetric. But we want to allow the sender to send simpler messages corresponding to a partial state. Actually we have seen this idea before in papers with multiple sends sensing a partial states and the receiver learning the full language.\n\nNow the sender might send a full state like $s_a = <det_1,n_2, v_3, n_4>$ but instead he would send a bunch of messages drawn from the power set. In this case $<det_1>$ would not get much reward say $\\frac{1}{10}$ as it is a syntax word and carries little semantics on its own. But $<n_2>$ might get a third  for $<v_3, n_4>$ might get a half.  We would of course need to normalize this to add to one. But we have actually done something useful in terms of RL we have allowed for rewards signals for partial success which as we wanted speeds up learning by allowing more frequent updates of the value function.\n\nThe reward might be shaped on the saliency of the sub-states to the survival of the agents or more broadly by its likelihood of allowing the agents to achieve their shared tasks faster. This is harder to do. I think information theoretic scheme or even $\\frac{TF}{IDF}$ based scheme might be easy to implement and intuit about. (Here D refers to states.)\n\nBesides getting these partial rewards, the receiver might get an attempt to decode each of the partial states in turn. We might want to stop him on the first mistake but perhaps he should get to try all the partial states, this might maximize learning down the road, particularly if the agents track beliefs, perhaps via a TOM (theory of mind).\n\nWhere f1 to fn are features of the state and s1 to sm are symbols in the language.\n\n\n1. English vs Turkish\n2. Language of Logic\n3. Trial and error\n4. Dreaming trial and error - MCMC with importance sampling\n5. Equivalence classes of language - Markov Equivalence.\n6. If Emergence is accelerated via learnability than it should be used to prioritize planning.\n7. A causal view - of planning and learnability.\n8. A theory of mind - ToM and planning in a bayesian setting.\n\n\n\n### Infinite use of finite means\n\nNatural languages are characterized as \"making Infinite use of finite means\". This is a product of thier recursive structure. \n\nThe communication task of agents in a lewis signaling games and often  restricted to communicating a the current state of the world. S\n\nSo we might consider that if the agents have seen some 'sufficient' set of states they might come up with a similar subset of possible language to coordinate on. One imagines that this might also be true if they have seen two non overlapping but compatible sufficient set of states.\n\nSo if the agents can enumerate the emergent languages wrt their sufficient states subset the algorithm we need is one to coordinate on a subset of languages that are compatible for the current available space. An primitive RL alg here would just need to allow updating thier beliefs on the compatibility of rules and atoms. The rules are used more frequently so grammar should become synchronized faster and the atoms i.e. lexicon might be learned more slowly.\n\n### planning, evolution and minimalism.\n\n\n\nThe grammar should allow a way to capture the \nThe idea is that the agents should be able to learn some tricks \n\nWhen agent spontaneously create a complex signaling system perhaps the main problem they face is a how to convert the complex state into a linear sequence of atomic symbols that can be sent over a noisy channel and then recover the state on the other side. This is often called leaning a protocol. \n\nOne path to solve this is to use a RNN. RNN are very powerful - they introduce orders of magnitude greater complexity into the problem than the actual coordination task\n\nThis is best done using a prefix code and can be implemented with Huffman coding. However some issues arise in the real world that make the Huffman coding inadequate and require greater flexibility.\n\n1. how can agents adapt to unseen sub-states without having to recalculate the entire code book which they have worked so hard to coordinate upon.\n2. how can agents adapt to changes in the frequency distribution of states over time.\n\nThis is **Vitter algorithm** - an algorithm for encoding and decoding messages based on using **Huffman prefix codes**. But it is a an adaptive version of the Huffman coding algorithm, which means that it can update the code book as it processes the message. \n\nThis is useful when the frequency distribution of characters in the message changes over time.\n\n\n\n```pseudocode\n#| html-indent-size: \"1.2em\"\n#| html-comment-delimiter: \"//\"\n#| html-line-number: true\n#| html-line-number-punc: \":\"\n#| html-no-end: false\n#| pdf-placement: \"htb!\"\n#| pdf-line-number: true\n\n\\begin{algorithm}[h]\n\\caption{Vitter's Adaptive Huffmaning algorithm}\n\\begin{algorithmic}[1]\n\\Procedure{AdaptiveHuffmanEncode}{}\n  \\State Initialize\n  \\State readSymbol($X$)\n  \\While{$X \\neq EOF$}\n    \\If{firstReadOf($X$)}\n      \\State output(code of ZERO)\n      \\State output(code of node $X$)\n      \\State create new node $U$ with next node ZERO and new node $X$\n      \\State updateTree($U$)\n    \\Else\n      \\State output(code of node $X$)\n      \\State updateTree(node $X$)\n    \\EndIf\n    \\State readSymbol($X$)\n  \\EndWhile\n\\EndProcedure\n\\State \n\\Procedure{updateTree}{$U$}\n  \\While{$U \\neq root$}\n    \\State $b :=$ block of nodes preceding node $U$\n    \\If{\n        (($U$ is leaf) \\and ($b$ is block of inner nodes) \\and (value $U$ == value $b$)) \n      \\or (($U$ is inner node) \\and ($b$ is block of leaves) \\and (value $U$ == value $b - 1$))}\n      \\State slide $U$ in front of block $b$\n      \\State increment value of $U$\n      \\If{$U$ is leaf}\n        \\State $U := parent(U)$\n      \\Else\n        \\State $U := parent(U \\text{ before slide})$\n      \\EndIf\n    \\Else\n      \\State increment value $U$\n      \\State $U := parent(U)$\n    \\EndIf\n  \\EndWhile\n  \\State increment value $U$\n\\EndProcedure\n\\end{algorithmic}\n\\end{algorithm}\n```\n\n\n\n\nWhy and when does this confer a significant advantage?\n\nFor complex lewis signaling games we need some way to convert the state of the world chosen by nature into a message that the sender can send to the receiver.\n\nSome options that came to mind are:\n\n1. Enumeration base $|L|$, same as in the regular game but adjusted to the limitation of the alphabet - unfortunately this fails to capture any structure of the states.\n2. Huffman coding using base 2. Many advantages but requires access to the entire message and the frequency distribution of the states. This generally not available in the Lewis signaling games where the states are chosen by nature and the distribution emerges over time from the interaction of the agents.\n3. N-ary Huffman coding - this time we use base $|L|$ for greater efficiency.\n4. Adaptive Huffman coding - this is the Vitter algorithm.\n5. Learn an encoder decoder using a neural network with LSTM or a transformer.\n6. Learn a denoising autoencoder to correct for the noise in the message.\n\nMy idea is that this can stand in as a default protocol for encoding and decoding messages in lewis signaling games with complex signals.\n\nThe protocol gets updated as the agents play the game and distribution of states drifts over time.\n\nThis algorithm support both encoding compositional codes by encoding just atomic symbols or if we **encode multiple symbols at a time it can be produce entangled codes**.\n\n\nA way to make this idea more concrete is if we designate certain sequences as an idiom i.e. we wish to encode the idiom as a single symbol since together they have a different meaning than thier literal meaning as atomic symbols. This may sound like \nan awkward idea but consider that there are many cases where such a sequence is dramatically more likely then any other sequence featuring it's constituents. \n\nGiven  the higher frequency we might encode them as a single symbol. \nThis way we can encode compositional codes and idioms in the same message. \nBut you also avoid collisions between idioms and their atomic counter parts\n\n- \"keep the wolf from the door\" idiomatic version - in a 1 block of  6 symbols.\n- \"keep the wolf from the door\" atomic symbols - as a 6 symbols\n\n## Future work:\n\n1. add an algorithm for adaptive arithmetic coding - which is more efficient than huffman coding.\n2. add support for blocking - this is where we encode 4 or more characters at a time. This is useful when the message is very long and we want to reduce the overhead of encoding and decoding. \n    - Blocking seems to be counter productive for language evolution making semantics depend on the length and order of the block.  \n    - However both agents and Natural language can use entangled codes so we may want to support this. \n    - With the caveat that we may pad the block to avoid blocking beyond the end of the message or a semantic unit.\n3. Integrate into an agent in the lewis petting zoo environment.\n\n::: {#8a38a37c .cell execution_count=1}\n``` {.python .cell-code}\nimport heapq\n\nclass Node:\n    def __init__(self, char, freq):\n        self.char = char\n        self.freq = freq\n        self.left = None\n        self.right = None\n\n    def __lt__(self, other):\n        return self.freq < other.freq\n\ndef build_huffman_tree(chars_freq):\n    \"\"\"\n    Builds the Huffman tree for given character frequencies.\n\n    Args:\n        chars_freq: A dictionary of characters and their frequencies.\n\n    Returns:\n        The root of the Huffman tree.\n    \"\"\"\n    nodes = []\n    for char, freq in chars_freq.items():\n        heapq.heappush(nodes, Node(char, freq))\n\n    while len(nodes) > 1:\n        left = heapq.heappop(nodes)\n        right = heapq.heappop(nodes)\n        parent = Node(None, left.freq + right.freq)\n        parent.left = left\n        parent.right = right\n        heapq.heappush(nodes, parent)\n\n    return nodes[0]\n\ndef encode_char(root, char, code=''):\n    \"\"\"\n    Encodes a character using Huffman codes.\n\n    Args:\n        root: The root of the Huffman tree.\n        char: The character to encode.\n        code: The current code (initially empty).\n\n    Returns:\n        The Huffman code for the character.\n    \"\"\"\n    if root is None:\n        return ''\n\n    if root.char == char:\n        return code\n\n    left_code = encode_char(root.left, char, code + '0')\n    if left_code != '':\n        return left_code\n\n    right_code = encode_char(root.right, char, code + '1')\n    return right_code\n\ndef decode_char(root, code):\n    \"\"\"\n    Decodes a Huffman code to get the character.\n\n    Args:\n        root: The root of the Huffman tree.\n        code: The Huffman code to decode.\n\n    Returns:\n        The decoded character.\n    \"\"\"\n    current = root\n    for bit in code:\n        if bit == '0':\n            current = current.left\n        else:\n            current = current.right\n\n    if current.char is not None:\n        return current.char\n\ndef encode_message(root, message):\n    \"\"\"\n    Encodes a message using Huffman codes.\n\n    Args:\n        root: The root of the Huffman tree.\n        message: The message to encode.\n\n    Returns:\n        The encoded message.\n    \"\"\"\n    encoded_message = ''\n    for char in message:\n        encoded_message += encode_char(root, char)\n    return encoded_message\n\ndef decode_message(root, encoded_message):\n    \"\"\"\n    Decodes a Huffman-encoded message.\n\n    Args:\n        root: The root of the Huffman tree.\n        encoded_message: The encoded message.\n\n    Returns:\n        The decoded message.\n    \"\"\"\n    decoded_message = ''\n    current = root\n    for bit in encoded_message:\n        if bit == '0':\n            current = current.left\n        else:\n            current = current.right\n\n        if current.char is not None:\n            decoded_message += current.char\n            current = root\n\n    return decoded_message\n\n# Example usage\nchars_freq = {'a': 45, 'b': 13, 'c': 12, 'd': 16, 'e': 9, 'f': 5}\nroot = build_huffman_tree(chars_freq)\n\nmessage = \"abcdef\"\nencoded_message = encode_message(root, message)\nprint(\"Encoded message:\", encoded_message)\n\ndecoded_message = decode_message(root, encoded_message)\nprint(\"Decoded message:\", decoded_message)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEncoded message: 010110011111011100\nDecoded message: abcdef\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}