{
  "hash": "37b0a0fe3411152fb33e3a830174e9dc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate: \"2025-01-11\"\ntitle: \"A garden of forking paths\"\ncategory: visualizations\nimage: /images/cover.png\n---\n\n\n\n\n\n::: {.callout-tip}\n## rethinking ðŸ’­ sequences {.unnumbered}\n\nI've been thinking how to visualize learning the complex lewis games.\n\nFor states based on 0-1 sequences we can visualize the state space as a binary tree. Another way is the garden of forking paths.\n\n:::\n\nThe following code comes from Richard McElreath whose developed it for his book Statistical Rethinking. \nHw used this code to to visualize the garden of forking paths. This is a very beautiful metaphor for explaining \nhow Bayesian statistical models are built. The we build the garden by making independent picks from a random variable.\nThe livlihood of some event. (e.g. at least three heads out of five.) are the paths that lead to such outcomes. \nAnd the probability is estimated by normalizing by the total number of possible paths.\n\n\nThe garden of forking paths is a way to visualize the state space of a sequence of binary choices. \nThe code below is a modified version of the original code to allow for coloring of the paths. The code is written in R.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rethinking)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: cmdstanr\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThis is cmdstanr version 0.8.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n- CmdStanR documentation and vignettes: mc-stan.org/cmdstanr\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n- CmdStan path: /home/oren/.cmdstan/cmdstan-2.34.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n- CmdStan version: 2.34.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nA newer version of CmdStan is available. See ?install_cmdstan() to install it.\nTo disable this check set option or environment variable cmdstanr_no_ver_check=TRUE.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: posterior\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThis is posterior version 1.6.0\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'posterior'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    mad, sd, var\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    %in%, match\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: parallel\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrethinking (Version 2.42)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'rethinking'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:stats':\n\n    rstudent\n```\n\n\n:::\n\n```{.r .cell-code}\npolar2screen <- function( dist, origin, theta ) {\n  ## takes dist, angle and origin and returns x and y of destination point\n  vx <- cos(theta) * dist;\n  vy <- sin(theta) * dist;\n  c( origin[1]+vx , origin[2]+vy );\n}\n\nscreen2polar <- function( origin, dest ) {\n  ## takes two points and returns distance and angle, from origin to dest\n  vx <- dest[1] - origin[1];\n  vy <- dest[2] - origin[2];\n  dist <- sqrt( vx*vx + vy*vy );\n  theta <- asin( abs(vy) / dist );\n  ## correct for quadrant\n  if( vx < 0 && vy < 0 ) theta <- pi + theta; # lower-left\n  if( vx < 0 && vy > 0 ) theta <- pi - theta; # upper-left\n  if( vx > 0 && vy < 0 ) theta <- 2*pi - theta; # lower-right\n  if( vx < 0 && vy==0 ) theta <- pi;\n  if( vx==0 && vy < 0 ) theta <- 3*pi/2; \n  ## return angle and dist\n  c( theta, dist );\n}\n\npoint.polar <- function(dist,theta,origin=c(0,0),...) {\n    # angle theta is in radians\n    pt <- polar2screen(dist,origin,theta)\n    points( pt[1] , pt[2] , ... )\n    invisible( pt )\n}\n\nline.polar <- function(dist,theta,origin=c(0,0),...) {\n    # dist should be vector of length 2 with start and end points\n    # theta is angle\n    pt1 <- polar2screen(dist[1],origin,theta)\n    pt2 <- polar2screen(dist[2],origin,theta)\n    lines( c(pt1[1],pt2[1]), c(pt1[2],pt2[2]) , ... )\n}\n\nline.short <- function(x,y,short=0.1,...) {\n    # shortens the line segment, but retains angle and placement\n    pt1 <- c(x[1],y[1])\n    pt2 <- c(x[2],y[2])\n    theta <- screen2polar( pt1 , pt2 )[1]\n    dist <- screen2polar( pt1 , pt2 )[2]\n    q1 <- polar2screen( short , pt1 , theta )\n    q2 <- polar2screen( dist-short , pt1 , theta )\n    lines( c(q1[1],q2[1]) , c(q1[2],q2[2]) , ... )\n}\n\nwedge <- function(dist,start,end,pt,hedge=0.1,alpha,lwd=2,...) {\n    # start: start angle of wedge\n    # end: end angle of wedge\n    # pt: vector of point bg colors\n    n <- length(pt)\n    points.save <- matrix(NA,nrow=n,ncol=2) # x,y columns\n    span <- abs(end-start)\n    span2 <- span*(1 - 2*hedge)\n    origin <- start + span*hedge\n    gap <- span2/n\n    theta <- origin + gap/2\n    border <- rep(\"black\",length(pt))\n    if ( !missing(alpha) ) {\n        pt <- sapply( 1:length(pt) , function(i) col.alpha(pt[i],alpha[i]) )\n        border <- sapply( 1:length(pt) , function(i) col.alpha(border[i],alpha[i]) )\n    }\n    for ( i in 1:n ) {\n        points.save[i,] <- point.polar( dist , theta , pch=21 , lwd=lwd , bg=pt[i] , col=border[i] , ... )\n        theta <- theta + gap\n    }\n    points.save\n}\n\n#######\n# garden draws paths using recursion\n\ngarden <- function( arc , possibilities , data , alpha.fade = 0.25 , hedge=0.1 , hedge1=0 , newplot=TRUE , plot.origin=FALSE , cex=1.5 , lwd=2 , adj.cex , adj.lwd , ring_dist , ... ) {\n    \n    poss.cols <- ifelse( possibilities==1 , rangi2 , \"white\" )\n    \n    if ( missing(adj.cex) ) adj.cex=rep(1,length(data))\n    if ( missing(adj.lwd) ) adj.lwd=rep(1,length(data))\n    \n    if ( newplot==TRUE ) {\n    # empty plot\n        par(mgp = c(1.5, 0.5, 0), mar = c(1, 1, 1, 1) + 0.1, tck = -0.02)\n        plot( NULL , xlim=c(-1,1) , ylim=c(-1,1) , bty=\"n\" , xaxt=\"n\" , yaxt=\"n\" , xlab=\"\" , ylab=\"\" )\n    }\n    \n    if ( plot.origin==TRUE ) point.polar( 0 , 0 , pch=16 )\n    \n    N <- length(data)\n    n_poss <- length(possibilities)\n    \n    # draw rings\n    \n    # compute distance out for each ring\n    # use golden ratio 1.618 for each successive ring\n    goldrat <- 1.618\n    if ( missing(ring_dist) ) {\n        ring_dist <- rep(1,N)\n        if ( N>1 )\n            for ( i in 2:N ) ring_dist[i] <- ring_dist[i-1]*goldrat\n        ring_dist <- ring_dist / sum(ring_dist)\n        ring_dist <- cumsum(ring_dist)\n    }\n    \n    if ( length(alpha.fade)==1 ) alpha.fade <- rep(alpha.fade,N)\n    \n    draw_wedge <- function(r,hit_prior,arc2,hedge=0.1,hedge1=0,lines_to) {\n    \n        # is each path clear?\n        hit <- hit_prior * ifelse( possibilities==data[r] , 1 , 0 )\n        \n        # transparency for blocked paths\n        alpha <- ifelse( hit , 1 , alpha.fade[r] )\n        \n        # draw wedge\n        hedge_use <- ifelse( r==1 , hedge1 , hedge )\n        pts <- wedge( ring_dist[r] , arc2[1] , arc2[2] , poss.cols , hedge=hedge_use , alpha=alpha , cex=cex*adj.cex[r] , lwd=lwd*adj.lwd[r] )\n        \n        if ( N > r ) {\n            # draw next layer\n            span <- abs( arc2[1] - arc2[2] ) / n_poss\n            for ( j in 1:n_poss ) {\n                # for each possibility, draw the next wedge\n                # recursion handles deeper wedges\n                new_arc <- c( arc2[1]+span*(j-1) , arc2[1]+span*j )\n                pts2 <- draw_wedge(r+1,hit[j],new_arc,hedge,lines_to=pts[j,])\n            }#j\n        }# N>r\n        \n        # draw lines back to parent point\n        if ( !missing(lines_to) ) {\n            for ( k in 1:n_poss ) {\n                alpha_l <- ifelse( hit==1 , 1 , alpha.fade[r] )\n                line.short( c(lines_to[1],pts[k,1]) , c(lines_to[2],pts[k,2]) , lwd=lwd*adj.lwd[r] , short=0.04 , col=col.alpha(\"black\",alpha_l[k]) )\n            }\n        } # lines_to\n        \n        return(pts)\n        \n    }\n    \n    pts1 <- draw_wedge(1,1,arc=arc,hedge=hedge,lines_to=c(0,0))\n    \n    invisible(pts1)\n    \n}\n\n\n##\n\ngoldrat <- 1.618\nring_dist <- rep(1,3)\nfor ( i in 2:3 ) ring_dist[i] <- ring_dist[i-1]*goldrat\nring_dist <- ring_dist / sum(ring_dist)\nring_dist <- cumsum(ring_dist)\n\ndat <- c(1,0,1)\n\narc <- c( 0 , pi )\ngarden(\n    arc = arc,\n    possibilities = c(0,0,0,1),\n    data = dat,\n    hedge = 0.05,\n    ring_dist=ring_dist,\n    alpha.fade=0.35\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n\n```{.r .cell-code}\n####\n# compare {1,0,0,0}, {1,1,0,0} and {1,1,1,0}\n\ndat <- c(1,0,1)\n\narc <- c( 0 , pi )\ngarden(\n    arc = arc,\n    possibilities = c(0,0,0,1),\n    data = dat,\n    hedge = 0.05,\n    ring_dist=ring_dist,\n    alpha.fade=0.35\n)\n\n\n####\n# second plot\n# compare {1,0,0,0} to {1,1,1,0}\n\ndat <- c(1,0,1)\n\narc <- c( pi/2 , pi/2+pi )\ngarden(\n    arc = arc,\n    possibilities = c(0,0,0,1),\n    data = dat,\n    hedge = 0.05,\n    adj.cex=c(1.2,1,0.8)\n)\n\narc <- c( arc[2] , arc[2] + pi )\ngarden(\n    arc = arc,\n    possibilities = c(0,0,1,1),\n    data = dat,\n    hedge = 0.05,\n    newplot=FALSE,\n    adj.cex=c(1.2,1,0.8)\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-2.png){width=672}\n:::\n\n```{.r .cell-code}\n####\n# third plot\n# three options: {1,0,0,0}, {1,1,0,0}, {1,1,1,0}\n\ndat <- c(1,0,1)\nac <- c(1.2,0.9,0.6)\n\narc <- c( pi/2 , pi/2 + (2/3)*pi )\ngarden(\n    arc = arc,\n    possibilities = c(1,0,0,0),\n    data = dat,\n    hedge = 0.05,\n    adj.cex=ac\n)\n\narc <- c( arc[2] , arc[2] + (2/3)*pi )\ngarden(\n    arc = arc,\n    possibilities = c(1,1,0,0),\n    data = dat,\n    hedge = 0.05,\n    newplot=FALSE,\n    adj.cex=ac\n)\n\narc <- c( arc[2] , arc[2] + (2/3)*pi )\ngarden(\n    arc = arc,\n    possibilities = c(1,1,1,0),\n    data = dat,\n    hedge = 0.05,\n    newplot=FALSE,\n    adj.cex=ac\n)\n\nline.polar( c(0,2) , pi/2 , lwd=1 )\nline.polar( c(0,2) , pi/2 + (2/3)*pi , lwd=1 )\nline.polar( c(0,2) , pi/2 + 2*(2/3)*pi , lwd=1 )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-3.png){width=672}\n:::\n\n```{.r .cell-code}\n#####\n# single possibility out of 10 plot\n\ndat <- c(1,0,1)\nac <- c(1.2,0.9,0.65)\nal <- c(1,1,0.6)\n\nn <- 6\nnblue <- 3\n\narc <- c( pi/2 , pi/2 + 2*pi )\ngarden(\n    arc = arc,\n    possibilities = c(rep(1,nblue),rep(0,n-nblue)),\n    data = dat,\n    hedge = 0.05,\n    adj.cex=ac,\n    adj.lwd=al\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-4.png){width=672}\n:::\n:::\n\n\n\n\n\n\n## Further work\n\n- todo: make figures with binary nodes\n- todo: extend to a series of 4\n- todo: highlight a subset of paths with a different color\n- show corresponding truth tables.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}