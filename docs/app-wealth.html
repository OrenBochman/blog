<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Oren Bochman’s Blog - Wealth App</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/cookie-consent/cookie-consent.js"></script>
<link href="site_libs/cookie-consent/cookie-consent.css" rel="stylesheet">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<meta name="shinylive:serviceworker_dir" content=".">
<script src="site_libs/quarto-contrib/shinylive-0.2.6/shinylive/load-shinylive-sw.js" type="module"></script>
<script src="site_libs/quarto-contrib/shinylive-0.2.6/shinylive/run-python-blocks.js" type="module"></script>
<link href="site_libs/quarto-contrib/shinylive-0.2.6/shinylive/shinylive.css" rel="stylesheet">
<link href="site_libs/quarto-contrib/shinylive-quarto-css/shinylive-quarto.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

<script type="text/javascript" charset="UTF-8">
document.addEventListener('DOMContentLoaded', function () {
cookieconsent.run({
  "notice_banner_type":"simple",
  "consent_type":"implied",
  "palette":"light",
  "language":"en",
  "page_load_consent_levels":["strictly-necessary","functionality","tracking","targeting"],
  "notice_banner_reject_button_hide":false,
  "preferences_center_close_button_hide":false,
  "website_name":""
  ,
"language":"en"
  });
});
</script> 
  


<meta name="twitter:title" content="Oren Bochman’s Blog - Wealth App">
<meta name="twitter:image" content="https://orenbochman.github.io/blog/thumbnail_blog.png">
<meta name="twitter:creator" content="@orenbochman">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    <img src="./images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Oren Bochman’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-bi-book" role="button" data-bs-toggle="dropdown" aria-expanded="false">
      <i class="bi bi-book" role="img">
</i> 
 <span class="menu-text"></span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-bi-book">    
        <li>
    <a class="dropdown-item" href="./dnn.html">
 <span class="dropdown-text">Neural Networks for Machine Learning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./model-thinking.html">
 <span class="dropdown-text">Model Thinking</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./xai.html">
 <span class="dropdown-text">XAI</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./rl.html">
 <span class="dropdown-text">rl</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./rhetoric.html">
 <span class="dropdown-text">rhetoric</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./tfp.html">
 <span class="dropdown-text">TFP</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./ab-testing.html">
 <span class="dropdown-text">AB testing</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./cognitiveai.html">
 <span class="dropdown-text">cognitive AI</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/orenbochman"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-bi-github" role="button" data-bs-toggle="dropdown" aria-expanded="false">
      <i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-bi-github">    
        <li>
    <a class="dropdown-item" href="https://github.com/OrenBochman/blog">
 <span class="dropdown-text">Source Code</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/OrenBochman/blog/issues">
 <span class="dropdown-text">Report a Bug</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item compact">
    <a class="nav-link" href="./index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./archive.html"> <i class="bi bi-archive" role="img">
</i> 
<span class="menu-text">Archive</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Wealth App</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<pre class="shinylive-python" data-engine="python"><code>#| standalone: true
#| components: [editor, viewer]
from shiny import App, render, ui
#import micropip
#await micropip.install("scipy")
#from os import sys
import numpy as np
import seaborn as sns
import pandas as pd
import random as rd
import itertools
from numpy import ndarray
import collections.abc as abc
from collections.abc import Sequence
import numpy.lib.recfunctions as rfs
from datetime import datetime
#from .sample import Range, Values
#from .tools import AttrDict, AgentpyError, make_list, InfoStr
#from importlib import metadata
#__version__ = metadata.version('agentpy')
#from .tools import make_list, make_matrix, AgentpyError, ListDict

class ListDict(Sequence):
    """ List with fast deletion &amp; lookup. """
    # H/T Amber https://stackoverflow.com/a/15993515/14396787

    def __init__(self, iterable):
        self.item_to_position = {}
        self.items = []
        for item in iterable:
            self.append(item)

    def __iter__(self):
        return iter(self.items)

    def __len__(self):
        return len(self.items)

    def __getitem__(self, item):
        return self.items[item]

    def __contains__(self, item):
        return item in self.item_to_position

    def extend(self, seq):
        for s in seq:
            self.append(s)

    def append(self, item):
        if item in self.item_to_position:
            return
        self.items.append(item)
        self.item_to_position[item] = len(self.items)-1

    def replace(self, old_item, new_item):
        position = self.item_to_position.pop(old_item)
        self.item_to_position[new_item] = position
        self.items[position] = new_item

    def remove(self, item):
        position = self.item_to_position.pop(item)
        last_item = self.items.pop()
        if position != len(self.items):
            self.items[position] = last_item
            self.item_to_position[last_item] = position

    def pop(self, index):
        """ Remove an object from the group by index. """
        self.remove(self[index])


class AgentSequence:
    """ Base class for agenpty sequences. """

    def __repr__(self):
        len_ = len(list(self))
        s = 's' if len_ != 1 else ''
        return f"{type(self).__name__} ({len_} object{s})"

    def __getattr__(self, name):
        """ Return callable list of attributes """
        if name[0] == '_':  # Private variables are looked up normally
            # Gives numpy conversion correct error for __array_struct__ lookup
            super().__getattr__(name)
        else:
            return AttrIter(self, attr=name)

    def _set(self, key, value):
        object.__setattr__(self, key, value)

    @staticmethod
    def _obj_gen(model, n, cls, *args, **kwargs):
        """ Generate objects for sequence. """

        if cls is None:
            cls = ap.Agent

        if args != tuple():
            raise AgentpyError(
                "Sequences no longer accept extra arguments without a keyword."
                f" Please assign a keyword to the following arguments: {args}")

        for i in range(n):
            # AttrIter values get broadcasted among agents
            i_kwargs = {k: arg[i] if isinstance(arg, AttrIter) else arg
                        for k, arg in kwargs.items()}
            yield cls(model, **i_kwargs)


# Attribute List ------------------------------------------------------------ #

class AttrIter(AgentSequence, Sequence):
    def __init__(self, source, attr=None):
        self.source = source
        self.attr = attr

    def __repr__(self):
        return repr(list(self))

    @staticmethod
    def _iter_attr(a, s):
        for o in s:
            yield getattr(o, a)

    def __iter__(self):
        """ Iterate through source list based on attribute. """
        if self.attr:
            return self._iter_attr(self.attr, self.source)
        else:
            return iter(self.source)

    def __len__(self):
        return len(self.source)

    def __getitem__(self, key):
        """ Get item from source list. """
        if self.attr:
            return getattr(self.source[key], self.attr)
        else:
            return self.source[key]

    def __setitem__(self, key, value):
        """ Set item to source list. """
        if self.attr:
            setattr(self.source[key], self.attr, value)
        else:
            self.source[key] = value

    def __call__(self, *args, **kwargs):
        return AttrIter([func_obj(*args, **kwargs) for func_obj in self])

    def __eq__(self, other):
        return [obj == other for obj in self]

    def __ne__(self, other):
        return [obj != other for obj in self]

    def __lt__(self, other):
        return [obj &lt; other for obj in self]

    def __le__(self, other):
        return [obj &lt;= other for obj in self]

    def __gt__(self, other):
        return [obj &gt; other for obj in self]

    def __ge__(self, other):
        return [obj &gt;= other for obj in self]

    def __add__(self, v):
        if isinstance(v, AttrIter):
            return AttrIter([x + y for x, y in zip(self, v)])
        else:
            return AttrIter([x + v for x in self])

    def __sub__(self, v):
        if isinstance(v, AttrIter):
            return AttrIter([x - y for x, y in zip(self, v)])
        else:
            return AttrIter([x - v for x in self])

    def __mul__(self, v):
        if isinstance(v, AttrIter):
            return AttrIter([x * y for x, y in zip(self, v)])
        else:
            return AttrIter([x * v for x in self])

    def __truediv__(self, v):
        if isinstance(v, AttrIter):
            return AttrIter([x / y for x, y in zip(self, v)])
        else:
            return AttrIter([x / v for x in self])

    def __iadd__(self, v):
        return self + v

    def __isub__(self, v):
        return self - v

    def __imul__(self, v):
        return self * v

    def __itruediv__(self, v):
        return self / v


# Object Containers --------------------------------------------------------- #

def _random(model, gen, obj_list, n=1, replace=False):
    """ Creates a random sample of agents.

    Arguments:
        n (int, optional): Number of agents (default 1).
        replace (bool, optional):
            Select with replacement (default False).
            If True, the same agent can be selected more than once.

    Returns:
        AgentIter: The selected agents.
    """
    if n == 1:
        selection = [gen.choice(obj_list)]
    elif replace is False:
        selection = gen.sample(obj_list, k=n)
    else:
        selection = gen.choices(obj_list, k=n)
    return AgentIter(model, selection)


class AgentList(AgentSequence, list):

    def __init__(self, model, objs=(), cls=None, *args, **kwargs):
        if isinstance(objs, int):
            objs = self._obj_gen(model, objs, cls, *args, **kwargs)
        super().__init__(objs)
        super().__setattr__('model', model)
        super().__setattr__('ndim', 1)

    def __setattr__(self, name, value):
        if isinstance(value, AttrIter):
            # Apply each value to each agent
            for obj, v in zip(self, value):
                setattr(obj, name, v)
        else:
            # Apply single value to all agents
            for obj in self:
                setattr(obj, name, value)

    def __add__(self, other):
        agents = AgentList(self.model, self)
        agents.extend(other)
        return agents

    def select(self, selection):
        """ Returns a new :class:`AgentList` based on `selection`.

        Arguments:
            selection (list of bool): List with same length as the agent list.
                Positions that return True will be selected.
        """
        return AgentList(self.model, [a for a, s in zip(self, selection) if s])

    def random(self, n=1, replace=False):
        """ Creates a random sample of agents.

        Arguments:
            n (int, optional): Number of agents (default 1).
            replace (bool, optional):
                Select with replacement (default False).
                If True, the same agent can be selected more than once.

        Returns:
            AgentIter: The selected agents.
        """
        return _random(self.model, self.model.random, self, n, replace)

    def sort(self, var_key, reverse=False):
        """ Sorts the list in-place, and returns self.

        Arguments:
            var_key (str): Attribute of the lists' objects, based on which
                the list will be sorted from lowest value to highest.
            reverse (bool, optional): Reverse sorting (default False).
        """
        super().sort(key=lambda x: x[var_key], reverse=reverse)
        return self

    def shuffle(self):
        """ Shuffles the list in-place, and returns self. """
        self.model.random.shuffle(self)
        return self


class AgentDList(AgentSequence, ListDict):

    def __init__(self, model, objs=(), cls=None, *args, **kwargs):
        if isinstance(objs, int):
            objs = self._obj_gen(model, objs, cls, *args, **kwargs)

        self._set('model', model)
        self._set('ndim', 1)
        self._set('items', [])
        self._set('item_to_position', {})

        self.model = model
        self.item_to_position = {}
        self.items = []
        for obj in objs:
            self.append(obj)

    def __setattr__(self, name, value):
        if isinstance(value, AttrIter):
            # Apply each value to each agent
            for obj, v in zip(self, value):
                setattr(obj, name, v)
        else:
            # Apply single value to all agents
            for obj in self:
                setattr(obj, name, value)

    def __add__(self, other):
        agents = AgentDList(self.model, self)
        agents.extend(other)
        return agents

    def random(self, n=1, replace=False):
        return _random(self.model, self.model.random, self.items, n, replace)

    def select(self, selection):

        return AgentList(
            self.model, [a for a, s in zip(self.items, selection) if s])

    def sort(self, var_key, reverse=False):

        agentlist = AgentList(self.model, self)
        agentlist.sort(var_key=var_key, reverse=reverse)
        return agentlist

    def shuffle(self):
        return AgentDListIter(self.model, self, shuffle=True)

    def buffer(self):
        return AgentDListIter(self.model, self, buffer=True)


class AgentSet(AgentSequence, set):

    def __init__(self, model, objs=(), cls=None, *args, **kwargs):
        if isinstance(objs, int):
            objs = self._obj_gen(model, objs, cls, *args, **kwargs)
        super().__init__(objs)
        super().__setattr__('model', model)
        super().__setattr__('ndim', 1)


class AgentIter(AgentSequence):

    def __init__(self, model, source=()):
        object.__setattr__(self, '_model', model)
        object.__setattr__(self, '_source', source)

    def __getitem__(self, item):
        raise AgentpyError(
            'AgentIter has to be converted to list for item lookup.')

    def __iter__(self):
        return iter(self._source)

    def __len__(self):
        return len(self._source)

    def __setattr__(self, name, value):
        if isinstance(value, AttrIter):
            # Apply each value to each agent
            for obj, v in zip(self, value):
                setattr(obj, name, v)
        else:
            # Apply single value to all agents
            for obj in self:
                setattr(obj, name, value)

    def to_list(self):
        return AgentList(self._model, self)

    def to_dlist(self):
        return AgentDList(self._model, self)


class AgentDListIter(AgentIter):

    def __init__(self, model, source=(), shuffle=False, buffer=False):
        object.__setattr__(self, '_model', model)
        object.__setattr__(self, '_source', source)
        object.__setattr__(self, '_shuffle', shuffle)
        object.__setattr__(self, '_buffer', buffer)

    def __iter__(self):
        if self._buffer:
            return self._buffered_iter()
        elif self._shuffle:
            items = self._source.items.copy()
            self._model.random.shuffle(items)
            return iter(items)
        else:
            return iter(self._source)

    def buffer(self):
        object.__setattr__(self, '_buffer', True)
        return self

    def shuffle(self):
        object.__setattr__(self, '_shuffle', True)
        return self

    def _buffered_iter(self):
        """ Iterate over source. """
        items = self._source.items.copy()
        if self._shuffle:
            self._model.random.shuffle(items)
        for a in items:
            if a in self._source:
                yield a

class _IterArea:

    def __init__(self, area, exclude=None):
        self.area = area
        self.exclude = exclude

    def __len__(self):
        if isinstance(self.area, np.ndarray):
            len_ = sum([len(s) for s in self.area.flat])
        else:
            len_ = len(self.area)
        if self.exclude:
            len_ -= 1  # Assumes that exclude is in Area
        return len_

    def __iter__(self):
        if self.exclude:
            if isinstance(self.area, np.ndarray):
                return itertools.filterfalse(
                    lambda x: x is self.exclude,
                    itertools.chain.from_iterable(self.area.flat)
                )
            else:
                return itertools.filterfalse(
                    lambda x: x is self.exclude, self.area)
        else:
            if isinstance(self.area, np.ndarray):
                return itertools.chain.from_iterable(self.area.flat)
            else:
                return iter(self.area)


class GridIter(AgentIter):

    def __init__(self, model, iter_, items):
        super().__init__(model, iter_)
        object.__setattr__(self, '_items', items)

    def __getitem__(self, item):
        sub_area = self._items[item]
        return GridIter(self._model, _IterArea(sub_area), sub_area)



class Object:

    def __init__(self, model):
        self._var_ignore = []

        self.id = model._new_id()  # Assign id to new object
        self.type = type(self).__name__
        self.log = {}

        self.model = model
        self.p = model.p

    def __repr__(self):
        return f"{self.type} (Obj {self.id})"

    def __getattr__(self, key):
        raise AttributeError(f"No attribute '{key}'.")

    def __getitem__(self, key):
        return getattr(self, key)

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def _set_var_ignore(self):
        self._var_ignore = [k for k in self.__dict__.keys() if k[0] != '_']

    @property
    def vars(self):
        return [k for k in self.__dict__.keys()
                if k[0] != '_'
                and k not in self._var_ignore]

    def record(self, var_keys, value=None):

        # Connect log to the model's dict of logs
        if self.type not in self.model._logs:
            self.model._logs[self.type] = {}
        self.model._logs[self.type][self.id] = self.log
        self.log['t'] = [self.model.t]  # Initiate time dimension

        # Perform initial recording
        for var_key in make_list(var_keys):
            v = getattr(self, var_key) if value is None else value
            self.log[var_key] = [v]

        # Set default recording function from now on
        self.record = self._record  # noqa

    def _record(self, var_keys, value=None):

        for var_key in make_list(var_keys):

            # Create empty lists
            if var_key not in self.log:
                self.log[var_key] = [None] * len(self.log['t'])

            if self.model.t != self.log['t'][-1]:

                # Create empty slot for new documented time step
                for v in self.log.values():
                    v.append(None)

                # Store time step
                self.log['t'][-1] = self.model.t

            if value is None:
                v = getattr(self, var_key)
            else:
                v = value

            self.log[var_key][-1] = v

    def setup(self, **kwargs):
        """This empty method is called automatically at the objects' creation.
        Can be overwritten in custom sub-classes
        to define initial attributes and actions.

        Arguments:
            **kwargs: Keyword arguments that have been passed to
                :class:`Agent` or :func:`Model.add_agents`.
                If the original setup method is used,
                they will be set as attributes of the object.

        Examples:
            The following setup initializes an object with three variables::

                def setup(self, y):
                    self.x = 0  # Value defined locally
                    self.y = y  # Value defined in kwargs
                    self.z = self.p.z  # Value defined in parameters
        """

        for k, v in kwargs.items():
            setattr(self, k, v)


class SpatialEnvironment(Object):

    def record_positions(self, label='p'):
        """ Records the positions of each agent.

        Arguments:
            label (string, optional):
                Name under which to record each position (default p).
                A number will be added for each coordinate (e.g. p1, p2, ...).
        """
        for agent, pos in self.positions.items():
            for i, p in enumerate(pos):
                agent.record(label+str(i), p)

class Grid(SpatialEnvironment):
    """ Environment that contains agents with a discrete spatial topology,
    supporting multiple agents and attribute fields per cell.
    For a continuous spatial topology, see :class:`Space`.

    This class can be used as a parent class for custom grid types.
    All agentpy model objects call the method :func:`setup` after creation,
    and can access class attributes like dictionary items.

    Arguments:
        model (Model):
            The model instance.
        shape (tuple of int):
            Size of the grid.
            The length of the tuple defines the number of dimensions,
            and the values in the tuple define the length of each dimension.
        torus (bool, optional):
            Whether to connect borders (default False).
            If True, the grid will be toroidal, meaning that agents who
            move over a border will re-appear on the opposite side.
            If False, they will remain at the edge of the border.
        track_empty (bool, optional):
            Whether to keep track of empty cells (default False).
            If true, empty cells can be accessed via :obj:`Grid.empty`.
        check_border (bool, optional):
            Ensure that agents stay within border (default True).
            Can be set to False for faster performance.
        **kwargs: Will be forwarded to :func:`Grid.setup`.

    Attributes:
        agents (GridIter):
            Iterator over all agents in the grid.
        positions (dict of Agent):
            Dictionary linking each agent instance to its position.
        grid (numpy.rec.array):
            Structured numpy record array with a field 'agents'
            that holds an :class:`AgentSet` in each position.
        shape (tuple of int):
            Length of each dimension.
        ndim (int):
            Number of dimensions.
        all (list):
            List of all positions in the grid.
        empty (ListDict):
            List of unoccupied positions, only available
            if the Grid was initiated with `track_empty=True`.
    """

    @staticmethod
    def _agent_field(field_name, shape, model):
        # Prepare structured array filled with empty agent sets
        array = np.empty(shape, dtype=[(field_name, object)])
        it = np.nditer(array, flags=['refs_ok', 'multi_index'])
        for _ in it:
            array[it.multi_index] = AgentSet(model)
        return array

    def __init__(self, model, shape, torus=False,
                 track_empty=False, check_border=True, **kwargs):

        super().__init__(model)

        self._track_empty = track_empty
        self._check_border = check_border
        self._torus = torus

        self.positions = {}
        self.grid = np.rec.array(self._agent_field('agents', shape, model))
        self.shape = tuple(shape)
        self.ndim = len(self.shape)
        self.all = list(itertools.product(*[range(x) for x in shape]))
        self.empty = ListDict(self.all) if track_empty else None

        self._set_var_ignore()
        self.setup(**kwargs)

    @property
    def agents(self):
        return GridIter(self.model, self.positions.keys(), self.grid.agents)

    # Add and remove agents ------------------------------------------------- #

    def _add_agent(self, agent, position, field):
        position = tuple(position)
        self.grid[field][position].add(agent)  # Add agent to grid
        self.positions[agent] = position  # Add agent position to dict

    def add_agents(self, agents, positions=None, random=False, empty=False):
        """ Adds agents to the grid environment.

        Arguments:
            agents (Sequence of Agent):
                Iterable of agents to be added.
            positions (Sequence of positions, optional):
                The positions of the agents.
                Must have the same length as 'agents',
                with each entry being a tuple of integers.
                If none is passed, positions will be chosen automatically
                based on the arguments 'random' and 'empty':

                - random and empty:
                  Random selection without repetition from `Grid.empty`.
                - random and not empty:
                  Random selection with repetition from `Grid.all`.
                - not random and empty:
                  Iterative selection from `Grid.empty`.
                - not random and not empty:
                  Iterative selection from `Grid.all`.

            random (bool, optional):
                Whether to choose random positions (default False).
            empty (bool, optional):
                Whether to choose only empty cells (default False).
                Can only be True if Grid was initiated with `track_empty=True`.
        """

        field = 'agents'

        if empty and not self._track_empty:
            raise AgentpyError(
                "To use 'Grid.add_agents()' with 'empty=True', "
                "Grid must be iniated with 'track_empty=True'.")

        # Choose positions
        if positions:
            pass
        elif random:
            n = len(agents)
            if empty:
                positions = self.model.random.sample(self.empty, k=n)
            else:
                positions = self.model.random.choices(self.all, k=n)
        else:
            if empty:
                positions = list(self.empty)  # Soft copy
            else:
                positions = itertools.cycle(self.all)

        if empty and len(positions) &lt; len(agents):
            raise AgentpyError("Cannot add more agents than empty positions.")

        if self._track_empty:
            for agent, position in zip(agents, positions):
                self._add_agent(agent, position, field)
                if position in self.empty:
                    self.empty.remove(position)
        else:
            for agent, position in zip(agents, positions):
                self._add_agent(agent, position, field)

    def remove_agents(self, agents):
        """ Removes agents from the environment. """
        for agent in make_list(agents):
            pos = self.positions[agent]  # Get position
            self.grid.agents[pos].remove(agent)  # Remove agent from grid
            del self.positions[agent]  # Remove agent from position dict
            if self._track_empty:
                self.empty.append(pos)  # Add position to free spots

    # Move and select agents ------------------------------------------------ #

    @staticmethod
    def _border_behavior(position, shape, torus):
                
        # Connected - Jump to other side
        if torus:
            new_position = tuple(x % x_max for x, x_max
                                 in zip(position, shape))

        # Not connected - Stop at border
        else:
            new_position = tuple(np.clip(position, 0, 
                                         np.array(shape)-1))
                    
        return new_position

    def move_to(self, agent, pos):
        """ Moves agent to new position.

        Arguments:
            agent (Agent): Instance of the agent.
            pos (tuple of int): New position of the agent.
        """

        pos_old = self.positions[agent]
        if pos != pos_old:

            # Grid options
            if self._check_border:
                pos = self._border_behavior(pos, self.shape, self._torus)
            if self._track_empty:
                if len(self.grid.agents[pos_old]) == 1:
                    if pos in self.empty:
                        self.empty.replace(pos, pos_old)
                    else:
                        self.empty.append(pos_old)
                elif pos in self.empty:
                    self.empty.remove(pos)

            self.grid.agents[pos_old].remove(agent)
            self.grid.agents[pos].add(agent)
            self.positions[agent] = pos

    def move_by(self, agent, path):
        """ Moves agent to new position, relative to current position.

        Arguments:
            agent (Agent): Instance of the agent.
            path (tuple of int): Relative change of position.
        """
        pos = [p + c for p, c in zip(self.positions[agent], path)]
        self.move_to(agent, tuple(pos))

    def neighbors(self, agent, distance=1):
        """ Select neighbors of an agent within a given distance.

        Arguments:
            agent (Agent): Instance of the agent.
            distance (int, optional):
                Number of cells to cover in each direction,
                including diagonally connected cells (default 1).

        Returns:
            AgentIter: Iterator over the selected neighbors.
        """

        pos = self.positions[agent]

        # TODO Change method upon initiation
        # Case 1: Toroidal
        if self._torus:
            slices = [(p-distance, p+distance+1) for p in pos]
            new_slices = []
            for (x_from, x_to), x_max in zip(slices, self.shape):
                if distance &gt;= x_max//2 :
                    sl_tupl = [(0, x_max)]
                elif x_to &gt; x_max:
                    sl_tupl = [(x_from, x_max), (0, x_to - x_max)]
                elif x_from &lt; 0:
                    sl_tupl = [(x_max + x_from, x_max), (0, x_to)]
                else:
                    sl_tupl = [(x_from, x_to)]
                new_slices.append(sl_tupl)
            areas = []
            for slices in itertools.product(*new_slices):
                slices = tuple(slice(*sl) for sl in slices)
                areas.append(self.grid.agents[slices])
            # TODO Exclude in every area inefficient
            area_iters = [_IterArea(area, exclude=agent) for area in areas]
            # TODO Can only be iterated on once
            return AgentIter(self.model,
                             itertools.chain.from_iterable(area_iters))

        # Case 2: Non-toroidal
        else:
            slices = tuple(slice(p-distance if p-distance &gt;= 0 else 0,
                                  p+distance+1) for p in pos)
            area = self.grid.agents[slices]
            # Iterator over all agents in area, exclude original agent
            return AgentIter(self.model, _IterArea(area, exclude=agent))

    # Fields and attributes ------------------------------------------------- #

    def apply(self, func, field='agents'):
        """ Applies a function to each grid position,
        end returns an `numpy.ndarray` of return values.

        Arguments:
            func (function): Function that takes cell content as input.
            field (str, optional): Field to use (default 'agents').
        """
        return np.vectorize(func)(self.grid[field])

    def attr_grid(self, attr_key, otypes='f', field='agents'):
        """ Returns a grid with the value of the attribute of the agent
        in each position, using :class:`numpy.vectorize`.
        Positions with no agent will contain `numpy.nan`.
        Should only be used for grids with zero or one agents per cell.
        Other kinds of attribute grids can be created with :func:`Grid.apply`.

        Arguments:
            attr_key (str): Name of the attribute.
            otypes (str or list of dtypes, optional):
                Data type of returned grid (default float).
                For more information, see :class:`numpy.vectorize`.
            field (str, optional): Field to use (default 'agents').
        """

        f = np.vectorize(
            lambda x: getattr(next(iter(x)), attr_key) if x else np.nan,
            otypes=otypes)
        return f(self.grid[field])

    def add_field(self, key, values=None):
        """
        Add an attribute field to the grid.

        Arguments:
            key (str):
                Name of the field.
            values (optional):
                Single value or :class:`numpy.ndarray`
                of values (default None).
        """

        if not isinstance(values, (np.ndarray, list)):
            values = np.full(np.product(self.shape), fill_value=values)
        if len(values.shape) &gt; 1:
            values = values.reshape(-1)

        # Create attribute as a numpy field
        self.grid = rfs.append_fields(
            self.grid, key, values, usemask=False, asrecarray=True
            ).reshape(self.grid.shape)

        # Create attribute as reference to field
        setattr(self, key, self.grid[key])

    def del_field(self, key):
        """
        Delete a attribute field from the grid.

        Arguments:
            key (str): Name of the field.
        """

        self.grid = rfs.drop_fields(
            self.grid, key, usemask=False, asrecarray=True)
        delattr(self, key)

class AgentpyError(Exception):
    pass

class AttrDict(dict):
    """ Dictionary where attribute calls are handled like item calls.

    Examples:

        &gt;&gt;&gt; ad = ap.AttrDict()
        &gt;&gt;&gt; ad['a'] = 1
        &gt;&gt;&gt; ad.a
        1

        &gt;&gt;&gt; ad.b = 2
        &gt;&gt;&gt; ad['b']
        2
    """

    def __init__(self, *args, **kwargs):
        if args == (None, ):
            args = ()  # Empty tuple
        super().__init__(*args, **kwargs)

    def __getattr__(self, name):
        try:
            return self.__getitem__(name)
        except KeyError:
            # Important for pickle to work
            raise AttributeError(name)

    def __setattr__(self, name, value):
        self.__setitem__(name, value)

    def __delattr__(self, item):
        del self[item]

    def _short_repr(self):
        len_ = len(self.keys())
        return f"AttrDict ({len_} entr{'y' if len_ == 1 else 'ies'})"

class Model(Object):
    def __init__(self, parameters=None, _run_id=None, **kwargs):

        # Prepare parameters
        self.p = AttrDict()
        if parameters:
            for k, v in parameters.items():
                if isinstance(v, (Range, Values)):
                    v = v.vdef
                self.p[k] = v

        # Iniate model as model object with id 0
        self._id_counter = -1
        super().__init__(self)

        # Simulation attributes
        self.t = 0
        self.running = False
        self._run_id = _run_id

        # Random number generators
        # Can be re-initiated with seed by Model.run()
        self.random = random.Random()
        self.nprandom = np.random.default_rng()

        # Recording
        self._logs = {}
        self.reporters = {}
        self.output = DataDict()
        self.output.info = {
            'model_type': self.type,
            'time_stamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'agentpy_version': __version__,
            'python_version': sys.version[:5],
            'experiment': False,
            'completed': False
        }

        # Private variables
        self._steps = None
        self._partly_run = False
        self._setup_kwargs = kwargs
        self._set_var_ignore()

    def __repr__(self):
        return self.type

    # Class Methods --------------------------------------------------------- #

    @classmethod
    def as_function(cls, **kwargs):
        """ Converts the model into a function that can be used with the
        `ema_workbench &lt;https://emaworkbench.readthedocs.io/&gt;`_ library.

        Arguments:
            **kwargs: Additional keyword arguments that will passed
                to the model in addition to the parameters.

        Returns:
            function:
                The model as a function that takes
                parameter values as keyword arguments and
                returns a dictionary of reporters.
        """

        superkwargs = kwargs

        def agentpy_model_as_function(**kwargs):
            model = cls(kwargs, **superkwargs)
            model.run(display=False)
            return model.reporters

        agentpy_model_as_function.__doc__ = f"""
        Performs a simulation of the model '{cls.__name__}'.
        
        Arguments:
            **kwargs: Keyword arguments with parameter values.

        Returns:
            dict: Reporters of the model.
        """

        return agentpy_model_as_function

    # Properties ------------------------------------------------------------ #

    @property
    def info(self):
        rep = f"Agent-based model {{"
        items = list(self.__dict__.items())
        for k, v in items:
            if k[0] != '_':
                v = v._short_repr() if '_short_repr' in dir(v) else v
                rep += f"\n'{k}': {v}"
        rep += '\n}'
        return InfoStr(rep)

    # Handling object ids --------------------------------------------------- #

    def _new_id(self):
        """ Returns a new unique object id (int). """
        self._id_counter += 1
        return self._id_counter

    # Recording ------------------------------------------------------------- #

    def report(self, rep_keys, value=None):
        for rep_key in make_list(rep_keys):
            if value is not None:
                self.reporters[rep_key] = value
            else:
                self.reporters[rep_key] = getattr(self, rep_key)

    # Placeholder methods for custom simulation methods --------------------- #

    def setup(self):
        """ Defines the model's actions before the first simulation step.
        Can be overwritten to initiate agents and environments."""
        pass

    def step(self):
        """ Defines the model's actions
        during each simulation step (excluding `t==0`).
        Can be overwritten to define the models' main dynamics."""
        pass

    def update(self):
        """ Defines the model's actions
        after each simulation step (including `t==0`).
        Can be overwritten for the recording of dynamic variables. """
        pass

    def end(self):
        """ Defines the model's actions after the last simulation step.
        Can be overwritten for final calculations and reporting."""
        pass

    # Simulation routines (in line with ipysimulate) ------------------------ #

    def set_parameters(self, parameters):
        """ Adds and/or updates the parameters of the model. """
        self.p.update(parameters)

    def sim_setup(self, steps=None, seed=None):
        """ Prepares time-step 0 of the simulation.
        Initiates (additional) steps and the two random number generators,
        and then calls :func:`Model.setup` and :func:`Model.update`. """

        # Prepare random number generators if initial run
        if self._partly_run is False:
            if seed is None:
                if 'seed' in self.p:
                    seed = self.p['seed']  # Take seed from parameters
                else:
                    seed = random.getrandbits(128)
            if not ('report_seed' in self.p and not self.p['report_seed']):
                self.report('seed', seed)
            self.random = random.Random(seed)
            npseed = self.random.getrandbits(128)
            self.nprandom = np.random.default_rng(seed=npseed)

        # Prepare simulation steps
        if steps is None:
            self._steps = self.p['steps'] if 'steps' in self.p else np.nan
        else:
            self._steps = self.t + steps

        # Initiate simulation
        self.running = True
        self._partly_run = True

        # Execute setup and first update
        self.setup(**self._setup_kwargs)
        self.update()

        # Stop simulation if t too high
        if self.t &gt;= self._steps:
            self.running = False

    def sim_step(self):
        """ Proceeds the simulation by one step, incrementing `Model.t` by 1
        and then calling :func:`Model.step` and :func:`Model.update`."""
        self.t += 1
        self.step()
        self.update()
        if self.t &gt;= self._steps:
            self.running = False

    def sim_reset(self):
        """ Reset model to initial conditions. """
        # TODO Remove attributes
        self.record = super().record
        self.__init__(parameters=self.p,
                      _run_id=self._run_id,
                      **self._setup_kwargs)

    # Main simulation method for direct use --------------------------------- #

    def stop(self):
        """ Stops :meth:`Model.run` during an active simulation. """
        self.running = False

    def run(self, steps=None, seed=None, display=True):
        """ Executes the simulation of the model.
        Can also be used to continue a partly-run simulation
        for a given number of additional steps.

        It starts by calling :func:`Model.run_setup` and then calls
        :func:`Model.run_step` until the method :func:`Model.stop` is called
        or `steps` is reached. After that, :func:`Model.end` and
        :func:`Model.create_output` are called. The simulation results can
        be found in :attr:`Model.output`.

        Arguments:
            steps (int, optional):
                Number of (additional) steps for the simulation to run.
                If passed, the parameter 'Model.p.steps' will be ignored.
                The simulation can still be stopped with :func:'Model.stop'.
            seed (int, optional):
                Seed to initialize the model's random number generators.
                If none is given, the parameter 'Model.p.seed' is used.
                If there is no such parameter, a random seed will be used.
                For a partly-run simulation, this argument will be ignored.
            display (bool, optional):
                Whether to display simulation progress (default True).

        Returns:
            DataDict: Recorded variables and reporters.

        """

        dt0 = datetime.now()
        self.sim_setup(steps, seed)
        while self.running:
            self.sim_step()
            if display:
                print(f"\rCompleted: {self.t} steps", end='')
        self.end()
        self.create_output()

        self.output.info['completed'] = True
        self.output.info['created_objects'] = self._id_counter
        self.output.info['completed_steps'] = self.t
        self.output.info['run_time'] = ct = str(datetime.now() - dt0)

        if display:
            print(f"\nRun time: {ct}\nSimulation finished")

        return self.output

    # Data management ------------------------------------------------------- #

    def create_output(self):
        """ Generates a :class:`DataDict` with dataframes of all recorded
        variables and reporters, which will be stored in :obj:`Model.output`.
        """

        def output_from_obj_list(self, log_dict, columns):
            # Aggregate logs per object type
            # Log dict structure: {obj_type: obj_id: log}
            obj_types = {}
            for obj_type, log_subdict in log_dict.items():

                if obj_type not in obj_types.keys():
                    obj_types[obj_type] = {}

                for obj_id, log in log_subdict.items():

                    # Add object id/key to object log
                    log['obj_id'] = [obj_id] * len(log['t'])

                    # Add object log to aggregate log
                    for k, v in log.items():
                        if k not in obj_types[obj_type]:
                            obj_types[obj_type][k] = []
                        obj_types[obj_type][k].extend(v)

            # Transform logs into dataframes
            for obj_type, log in obj_types.items():
                if obj_type == self.type:
                    del log['obj_id']
                    index_keys = ['t']
                else:
                    index_keys = ['obj_id', 't']
                df = pd.DataFrame(log)
                for k, v in columns.items():
                    df[k] = v  # Set additional index columns
                df = df.set_index(list(columns.keys()) + index_keys)
                self.output['variables'][obj_type] = df

        # 1 - Document parameters
        if self.p:
            self.output['parameters'] = DataDict()
            self.output['parameters']['constants'] = self.p.copy()

        # 2 - Define additional index columns
        columns = {}
        if self._run_id is not None:
            if self._run_id[0] is not None:
                columns['sample_id'] = self._run_id[0]
            if len(self._run_id) &gt; 1 and self._run_id[1] is not None:
                columns['iteration'] = self._run_id[1]

        # 3 - Create variable output
        if self._logs:
            self.output['variables'] = DataDict()
            output_from_obj_list(self, self._logs, columns)

        # 4 - Create reporters output
        if self.reporters:
            d = {k: [v] for k, v in self.reporters.items()}
            for key, value in columns.items():
                d[key] = value
            df = pd.DataFrame(d)
            if columns:
                df = df.set_index(list(columns.keys()))
            self.output['reporters'] = df

class Agent(Object):
    """ Template for an individual agent.

    Arguments:
        model (Model): The model instance.
        **kwargs: Will be forwarded to :func:`Agent.setup`.

    Attributes:
        id (int): Unique identifier of the agent.
        log (dict): Recorded variables of the agent.
        type (str): Class name of the agent.
        model (Model): The model instance.
        p (AttrDict): The model parameters.
        vars (list of str): Names of the agent's custom variables.
    """

    def __init__(self, model, *args, **kwargs):
        super().__init__(model)
        self.setup(*args, **kwargs)

# Model design
class WealthAgent(Agent):
    """ An agent with wealth """
    def setup(self):
        self.wealth = 1

    def wealth_transfer(self):
        if self.wealth &gt; 0:
            partner = self.model.agents.random()
            partner.wealth += 1
            self.wealth -= 1

def gini(x):
    """ Calculate Gini Coefficient """
    x = np.array(x)
    mad = np.abs(np.subtract.outer(x, x)).mean()  # Mean absolute difference
    rmad = mad / np.mean(x)  # Relative mean absolute difference
    return 0.5 * rmad

class WealthModel(Model):
    """ A simple model of random wealth transfers """
    def setup(self):
        self.agents = ap.AgentList(self, self.p.agents, WealthAgent)
    def step(self):
        self.agents.wealth_transfer()
    def update(self):
        self.record('Gini Coefficient', gini(self.agents.wealth))
    def end(self):
        self.agents.record('wealth')

app_ui = ui.page_fluid(
    ui.input_slider("agents", "Agents", 0, 100, 100),
    ui.input_slider("steps", "Steps", 0, 100, 100),
    ui.input_slider("x", "y", 0, 10, 10),
    ui.input_slider("y", "y", 0, 10, 10),
    ui.output_text_verbatim("txt"),
)

def server(input, output, session):
    @output
    @render.text    
    def txt():
        parameters = {
           'agents': input.agents(),
            'steps': input.steps(),
            'seed': 42,
        }
        model = WealthModel(parameters)
        results = model.run()
        return results.info['completed_steps'] </code></pre>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/orenbochman\.github\.io\/blog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 Copyright 2024, Oren Bochman
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="./about.html">
<p>About</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="./license.html">
<p>License</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="./trademark.html">
<p>Trademark</p>
</a>
  </li>  
</ul>
    <div class="cookie-consent-footer"><a href="#" id="open_preferences_center">Cookie Preferences</a></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>