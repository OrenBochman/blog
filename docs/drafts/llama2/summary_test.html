<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>transcript</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="summary_test_files/libs/clipboard/clipboard.min.js"></script>
<script src="summary_test_files/libs/quarto-html/quarto.js"></script>
<script src="summary_test_files/libs/quarto-html/popper.min.js"></script>
<script src="summary_test_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="summary_test_files/libs/quarto-html/anchor.min.js"></script>
<link href="summary_test_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="summary_test_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="summary_test_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="summary_test_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="summary_test_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">transcript</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<style>
.edit_remove { text-decoration: line-through; color: #7f8c8d; } /* Grey and strike-through for removal */
.ent_person { color: #e74c3c; } /* Red for people */
.ent_organization { color: #3498db; } /* Blue for organizations */
.ent_model { color: #9b59b6; } /* Purple for models */
.ent_event { color: #2ecc71; } /* Green for events */
.ent_subject { color: #f1c40f; } /* Yellow for subjects */
.ent_other { color: #95a5a6; } /* Grey for other entities */
</style>
<p>Hi, in this lecture we’re gonna step back a little bit, and we’re gonna think about how we model people. Because a lot of models that are gonna be concerning us are models of, you know, people and groups of people like firms, governments, and organizations. So, if you wanna make good models of those things, then you’ve gotta have good models of the parts, good models of the people. <span class="edit_remove">Okay</span>. Modeling people is tricky. Physicist <span class="ent_person">Marie Gelmont</span> once famously said, imagine how difficult physics would be if electrons could think <span class="edit_remove">[laugh]</span> so what did he mean by human? What he meant was that, you know, if you take an electron or a carbon atom or even a water molecule, it doesn’t think, it doesn’t try to make sense of the world, it doesn’t have any goals or objectives or anything like that, no beliefs, so it’s pretty straightforward to model how those things function. When you look at people, people are much more complicated, <span class="edit_remove">right</span>? We’re purposeful, we’ve got goals, we’ve got objectives, we’ve got things we want to do, we’ve got belief structures, we’re messy. And because of that, you just don’t quite know how we’re going to behave. Now, on top of that, we’re diverse, <span class="edit_remove">right</span>? We want different things. We have different goals and objectives. So this combination of sort of purposeful, thinking actors who are different means that it can be really hard to understand what they do and how they act. So how do we do it? <span class="edit_remove">Well</span>, we’re gonna talk about three basic frameworks.</p>
<p>The first framework is called the <span class="ent_model">rational actor model</span>. Now in this framework, what you do is you assume that people optimize. Now, this is unrealistic, and I’ll talk about this in the next lecture in some detail, but it’s a good benchmark. So one way to think about it is just to assume, let’s just assume people have some sort of goal, and they optimize their goal, <span class="edit_remove">okay</span>? The second thing. We can assume what we call a <span class="ent_model">behavioral model</span>. Now here we sort of gather up all sorts of data about how real people actually do make decisions and choices and act, and then what we try to do is model people as close as possible to how real people behave. Now of course, you can make it too complicated. We sort of try and include the one or two different things from perfect rationality, like the biases that people might have. <span class="edit_remove">Right</span>. And the third thing that we’ll look at is even simpler. Which are sort of, <span class="ent_model">rule-based models</span>. So here what we’re going to do is instead of digging really deep into psychology we’re just going to assume that people follow rules, and then see how those things add up. Now, what we’re gonna see is in some cases which of these three things we assume matters a lot and in other cases which of these three things we assume doesn’t matter very much at all. And so, how we model people and whether it is so important that we get it exactly right is going to be a function of the particular model we are playing with. Look at that a little bit later on. First let me go a bit more back. So, how does that <span class="ent_model">rational actor model</span> work? In the <span class="ent_model">rational actor model</span>, you assume there is an objective function. It’ll be a mathematical function you know someone is trying to maximize, <span class="edit_remove">right</span>. So that could be if you’re a person, maximizing happiness or utility. If you’re a firm it could be maximizing profits or market share. Or if you’re a government, if you’re running for office it could be maximizing the number of votes. Then what you assume is that people optimize. Given your objective what you do is you do the optimal thing. So you take the choice that makes you as happy as possible. You make the, put a couple of decisions, get used to those votes, and you produce the product that makes you the most money. Let me, let me be more specific. So suppose you’re in a situation, you see something. How many hours should someone choose to work? <span class="edit_remove">Well</span>, what’d you do is you’d write down a function, a utility function. Say the utility depends on consumption and on leisure. And you might assume it’s like this one. It’s the square root of consumption times the square root of leisure. Now why would you assume that? <span class="edit_remove">Well</span>, the square root function, <span class="edit_remove">right</span>, starts out up and then sort of slowly falls off. So then so that means the first bit of consumption’s really good but then it becomes worth less. In the first bit of leisure’s really good, by the first hour of vacation’s great, but by a week you’re sorta ready to get back to work. So that also falls off. They’ve got what they call diminishing returns. So this function sorta says consumption’s good but becomes less good the more you have. Leisure’s good but it becomes less good the more you have. <span class="edit_remove">Well</span>, this is your function, and then what you do is you just choose consumption and leisure depending on how much they cost, to maximize that. Now that may not be exactly what you, you may not be sitting at home writing down functions and you know, solving these equations for what to do, but economists sort of assume that you do that, it’s as if you do that. <span class="edit_remove">Right</span>? You come close enough to doing that, that this is a useful model.</p>
<p>Now the <span class="ent_model">rational actor model</span> comes under a lot of criticism and particularly like according to. You know? Just basic data. <span class="edit_remove">Right</span>? So, there’s a movement in economics called the <span class="ent_event">behavioral revolution</span> that, this is also being going on in psychology for, for about a 100 years. Aiming that if you observe people being rational, A rational ’cause you can look and see what people do. And if you observe what people do, you’ll find out that they’re not rational. And they are not rational in systematic ways. Recently, this whole research pattern has been really propped up through evidence in neuroscience. You can actually look at the structure of the brain, look at how people think in particular situations, and you can see in fact, why they are thinking in ways that the <span class="ent_model">rational actor model</span> would consider to be irrational. So, those are sort of two benchmarks. On the one hand, you can assume people are rational. On the other hand, you can assume that, <span class="edit_remove">well</span>, people sorta do what people do. Now this other thing, this people doing what people do is gonna be a lot messier. There’s a third way, and the third approach comes from, you know, again, social scientists, but also from some computer scientists, and even some psychologists, and that is to assume that people follow rules. It’s more of a <span class="ent_model">Schelling model</span>, like we didn’t have a very elaborate model of how people behaved there, all we did was we just assumed that people moved out of a neighborhood if, you know, the neighborhood became too much unlike them. So this is just a simple rule, and if that simple rule is close to what people do, that might be sufficient to work in the model. <span class="edit_remove">Okay</span>, so what do we got? We got these three basic frameworks, people optimize, people are sort of behavioral, they do what people do and people follow rules. Each of those in a given situation will give a sort of slightly different predictions about how people behave. <span class="edit_remove">Right</span>? And when we start aggregating them and having them interact we can get very different conclusions. In some of the other cases where we really don’t see that much of a difference depending on what we assume. But what we want to do now, these next couple of lectures, is we just wanna sort of think through the logic of what a <span class="ent_model">rational actor model</span> means. Visit some of the biases that we’ve seen, that, you know, psychologists have seen when they look at how people actually behave. And then think through sort of what a <span class="ent_model">rule-based model</span> might look like. And we’ll conclude by sort of comparing all these in a couple of settings and see when it doesn’t matter and when it really does matter. <span class="edit_remove">Okay</span>.</p>
<p>Thank you.</p>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>