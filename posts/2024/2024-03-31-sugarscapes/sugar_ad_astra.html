<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Oren Bochman">

<title>Oren Bochman’s Blog - Sugarscape Ad Astra</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../favicon.ico" rel="icon">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script src="../../../site_libs/quarto-contrib/pseudocode-2.4.1/pseudocode.min.js"></script>
<link href="../../../site_libs/quarto-contrib/pseudocode-2.4.1/pseudocode.min.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta name="twitter:title" content="Oren Bochman’s Blog - Sugarscape Ad Astra">
<meta name="twitter:description" content="Personal website, portfolio and blog">
<meta name="twitter:image" content="https://orenbochman.github.io/posts/2024/2024-03-31-sugarscapes/thumbnail_blog.png">
<meta name="twitter:creator" content="@orenbochman">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar docked nav-fixed slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Oren Bochman’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-about" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">about</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-about">    
        <li>
    <a class="dropdown-item" href="../../../about.html">
 <span class="dropdown-text">About</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-notes" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">notes</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-notes">    
        <li>
    <a class="dropdown-item" href="../../../nlp.html">
 <span class="dropdown-text">NLP Specilization</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../dnn.html">
 <span class="dropdown-text">Neural Networks for Machine Learning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../model-thinking.html">
 <span class="dropdown-text">Model Thinking</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../xai.html">
 <span class="dropdown-text">XAI</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../rl.html">
 <span class="dropdown-text">Reinforcement Learning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../rhetoric.html">
 <span class="dropdown-text">Rhetoric</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../tfp.html">
 <span class="dropdown-text">TFP</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../ab-testing.html">
 <span class="dropdown-text">AB testing</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../cognitiveai.html">
 <span class="dropdown-text">Cognitive AI</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/orenbochman"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-bi-github" role="button" data-bs-toggle="dropdown" aria-expanded="false">
      <i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-bi-github">    
        <li>
    <a class="dropdown-item" href="https://github.com/OrenBochman/blog">
 <span class="dropdown-text">Source Code</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/OrenBochman/blog/issues">
 <span class="dropdown-text">Report a Bug</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item compact">
    <a class="nav-link" href="../../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../archive.html"> <i class="bi bi-archive" role="img">
</i> 
<span class="menu-text">Archive</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">Sugarscape Ad Astra</li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Sugarscape Ad Astra</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Oren Bochman </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">Sunday, March 24, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#research-questions" id="toc-research-questions" class="nav-link active" data-scroll-target="#research-questions">Research questions</a>
  <ul class="collapse">
  <li><a href="#understanding-rules" id="toc-understanding-rules" class="nav-link" data-scroll-target="#understanding-rules">Understanding rules:</a></li>
  <li><a href="#how-can-we-make-the-sugarscape-rules-more-fluid" id="toc-how-can-we-make-the-sugarscape-rules-more-fluid" class="nav-link" data-scroll-target="#how-can-we-make-the-sugarscape-rules-more-fluid">How can we make the Sugarscape rules more fluid?</a></li>
  <li><a href="#formalizing-sugarscape-as-an-mdp" id="toc-formalizing-sugarscape-as-an-mdp" class="nav-link" data-scroll-target="#formalizing-sugarscape-as-an-mdp">Formalizing Sugarscape as an MDP</a></li>
  </ul></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">





<p>I am really enjoying reading Growing artificial societies <span class="citation" data-cites="epstein1996growing">(<a href="#ref-epstein1996growing" role="doc-biblioref">Epstein, Axtell, and Project 1996</a>)</span> . Perhaps, the most brilliant aspect of the book is the authors reductionist approach to social science. This type of research was pioneered by Schelling in <span class="citation" data-cites="schelling1978micromotives">(<a href="#ref-schelling1978micromotives" role="doc-biblioref">Schelling 1978</a>)</span> his work on segregation. However the way the simulation is constructively developed is something I have rarely seen outside pure mathematics.</p>
<div class="no-row-height column-margin column-container"><div id="ref-epstein1996growing" class="csl-entry" role="listitem">
Epstein, J. M., R. Axtell, and 2050 Project. 1996. <em>Growing Artificial Societies: Social Science from the Bottom up</em>. A Bradford Book. MIT Press. <a href="https://books.google.co.il/books?id=xXvelSs2caQC">https://books.google.co.il/books?id=xXvelSs2caQC</a>.
</div><div id="ref-schelling1978micromotives" class="csl-entry" role="listitem">
Schelling, Thomas C. 1978. <em>Micromotives and Macrobehavior</em>. Fels Lectures on Public Policy Analysis. Norton. <a href="https://www.google.com/books?id=4C5mQgAACAAJ">https://www.google.com/books?id=4C5mQgAACAAJ</a>.
</div></div><p>The book is centered around an environment in which a small colony of ant like agent . The evolution of the environment is driven by simple rules. It is purported to a tool to investigate the emergence of complex macro behavior from local micro rules. The rules are generally kept as simple as possible. Some rules are part of the environment but most affect the behavior of the agents.</p>
<p>However they interactions are not baked into the rules AFAIK - they are emergent?</p>
<p>As I process this amazing book, I want to:</p>
<ol type="1">
<li>list some research questions and some directions to answer them.</li>
<li>list some areas in which to extend the sim</li>
<li>list some ideas on implementation</li>
</ol>
<section id="research-questions" class="level1 page-columns page-full">
<h1>Research questions</h1>
<section id="understanding-rules" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="understanding-rules">Understanding rules:</h2>
<p>Recent work outlined in RL <span class="citation" data-cites="Team2021OpenEndedLL">(<a href="#ref-Team2021OpenEndedLL" role="doc-biblioref">Team et al. 2021</a>)</span> RL suggests that agent operating in highly variable environments will generalize better. However the work cannot be reproduced since the project was not made public.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Team2021OpenEndedLL" class="csl-entry" role="listitem">
Team, Open-Ended Learning, Adam Stooke, Anuj Mahajan, C. Barros, Charlie Deck, Jakob Bauer, Jakub Sygnowski, et al. 2021. <span>“Open-Ended Learning Leads to Generally Capable Agents.”</span> <em>ArXiv</em> abs/2107.12808.
</div></div><p>In an interview [@<a href="https://www.youtube.com/watch?v=1yVoNAMLIy0&amp;t=1460s" class="uri">https://www.youtube.com/watch?v=1yVoNAMLIy0&amp;t=1460s</a>] seems to mention artificial life as a source of inspiration. Which go me thinking again about this article. I later found a related work [@<a href="https://arxiv.org/abs/2312.12044" class="uri">https://arxiv.org/abs/2312.12044</a>] on XLand-MiniGrid which has been made public.</p>
</section>
<section id="how-can-we-make-the-sugarscape-rules-more-fluid" class="level2">
<h2 class="anchored" data-anchor-id="how-can-we-make-the-sugarscape-rules-more-fluid">How can we make the Sugarscape rules more fluid?</h2>
<ol type="1">
<li><p>The autors introduced parametrised rules</p></li>
<li><p>The authors also gave some variants of rules</p></li>
<li><p>The authors also listed some ideas they never implemented.</p></li>
<li><p>Other researchers have come up with additional rules</p>
<ol type="1">
<li>Adding rivers to expand trade to many agents</li>
<li>Adding agents that live from trade only.</li>
</ol></li>
<li><p>In Sugarscape Rules prescribe actions. More challenging is a simulation where agents must learn to make decision and the rules would then determine the impact on the future state.</p>
<p>This would be greatly facilitated by restructuring the rules into:</p>
<ol type="1">
<li>initial state <span class="math inline">s</span></li>
<li>an action <span class="math inline">a</span></li>
<li>the new state <span class="math inline">s'</span> [change to env, agent, other agents]</li>
<li>(optional) the immediate reward <span class="math inline">r</span> gained by to the agent</li>
</ol>
<p>This should make the simulation more ameanable to introducing agents that can learn optimal behavior using RL.<br>
Rewards can be based on some king of Utility function estimating a Pareto frontier of preferences factoring in expected wealth, progeny etc.<br>
On the agent side there would be a</p>
<ol start="5" type="1">
<li>a policy <span class="math inline">\pi</span> that the agent follows</li>
</ol>
<p>For each rule we would want to also learn a policy <span class="math inline">\pi_0</span> which mimic the original agent’s behavior.</p></li>
<li><p>Another way to make rules more fluid is to introduce direct or indirect interactions. For example culture might activate combat and trade (perhaps within family, friends, tribes, everyone, or with none). This could be implemented for different forms of culture formation.</p></li>
<li><p>Changing landscapes - Agents learn more general strategies if they are subject to many different shocks this can be done</p>
<p>by introducing a “changing the landscape” i.e.&nbsp;rules for evolution of states are not fixed. This is occasionally implemented in the book.</p>
<ol type="1">
<li>Parameters of active rules vary over the course of the simulation.</li>
<li>Each epoch a rule variant might switch</li>
<li>Rules might be randomized - (state evolves using a random pick of rule variant and parameters)</li>
<li>Rules might be localized (similar to the above but rules change locally within cells or nighbourhoods)</li>
</ol></li>
<li><p>Game theory suggest all sort of challenges for making decisions harder</p>
<ol type="1">
<li><p>imperfect information is (in poker might not know some <em>sets of information</em> like the hands of other players or their startegy)</p></li>
<li><p>incomplete information agents also have limited knowledge of the game’s structure (e.g.&nbsp;in auctions/negotionation don’t know others’ valuations or constraints and can use Bayesian updating to update their beliefs regarding these as the game progresses.)</p></li>
<li><p>decisions that affect group like social dilemmas, voting, public goods, assiginging payments to coalitions, marriage problems etc.</p></li>
</ol></li>
<li><p>Finally, I can specify the original idea I had on this subject, Can we create a very general notion of a trade rule drawn from some family of unspecified trade rules</p>
<ol type="1">
<li>For any trade and price agents should get to decide if they like the trade, perhaps subject to some public information like the mean wealth of nearby agents or private information, like their expected future harvests or their original endownment. This might be represented as a random variable drawn from all possible decision trees of some depth based on the given input. The tree could also be learned using random forest or some neural net.</li>
<li>A part of this decision tree might be a based on a learned function approximation of the Cobbs-Douglass utility function using a deep Q network (DQN) or Actor-Critic methods. This function could evolve with changing environmental factors.</li>
</ol></li>
</ol>
</section>
<section id="formalizing-sugarscape-as-an-mdp" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="formalizing-sugarscape-as-an-mdp">Formalizing Sugarscape as an MDP</h2>
<p>If we define Sugarscape as an MDP how can we collect data for training agent’s policies given that agent are heterogeneous, rules may change and have different preferences and utilities.</p>
<ol type="1">
<li>the main question seems to be defining the state, which depends on the rules active.</li>
<li>However since rules are localized we might store for each agent at each time step:
<ol type="1">
<li>agent[sugar,spice,sugar_endowment,spice_endowment,sugar_metabolism,spice_metabolism,vision,gender,age]</li>
<li>fov_sugar[(offset,[sugar,spice,pollution])],</li>
<li>fov_agents[(offset,agent)] where agent could be as in 1 or some some of their data might be considered private.</li>
<li>context rules:[G_1,M,P,T,S]<br>
after each rule we can store the actions taken and the new state and rewards.</li>
<li>note that for some decisions like harvesting an agent might not consider some part of the state.<br>
perhaps for such decisions a smaller representation might suffice.</li>
</ol></li>
<li>Since there are many similar agents envitonments fov_sugar and fov_agent might repeat many times they could be hashed.</li>
<li>Since different rules might cause some of the data to be missing this makes the state space very large.</li>
</ol>
<p>We could assign a reward for each rule’s action - a form if intrinsic reward or we could assign a rewards at time of death.<br>
An agent fitness is their expected progeney.</p>
<ol start="3" type="1">
<li><p>Agent Identification problem: In different settings we might have similar agents. In fact we may switch rules on and off during the sim. If there is no spice many different agent with different spice endowment might be identified as a single agent. Why do we care ? We might want to do learning at the agent level and so we would need many episodes for each to use MC RL methods.</p>
<ol type="1">
<li>The mathematical notion is to create equivalence classes of agents and perhaps more practical a heirarchy of agents where we might consider members of a subset more as similar.</li>
<li>We might want though something more sophisticated - we might want to have an equivalence that can account for
<ol type="1">
<li>ignoring some intrinsics (forgetful equivalence)</li>
<li>can compare two potentially different agents. (potential equivalence)</li>
</ol></li>
<li>Seed equivalence: If Each agent is created using a function from some random seed we can generate all possible agents with full intrinsic. Any agent without some intrinsic is equivalent wrt the seed.</li>
<li>With fewer intrinsic parameters many agents that are not identical wrt seed are going to be the same for all intents and purposes.</li>
<li>consider a more complex agent coming from the same seed (assuming the same intrinsics get the same seeds) we get a subset operation - more complexs agents belong to the set of more complex ones.</li>
<li>Each agent might get a has</li>
<li>One idea is to hash the agents</li>
<li>Another idea is to generate an agent from a seed with a function. This would</li>
</ol></li>
<li><p>Different reward schemes</p>
<ol type="1">
<li>For a episodic RL setting we could consider an agen’t lifetime an episode.
<ol type="1">
<li><p>Survior reward:</p>
<p>If they die of old age they get a reward of 1 otherwise they get 0.</p></li>
<li><p>Lifespan reward</p>
<p>We could amplify this signal by giving a reward of one for each time step for surviving.</p></li>
<li><p>Fitness</p>
<p>This is an evolutionary reward signal defined as the expected number of progeny or number of children.</p>
<p>To get the expected number we can simply average the number from many episodes. In reality this statistic is an Random Variable that changes due to the stochastic nature of the environment, distribution of other agent types.</p>
<p>Also the progeny are different from their parents since they are produced my mitosis like sexual reproduction step</p>
<p>Population dynamics does typically updates subsequent generation based on agents’ fitness.</p>
<p>We can simplify things by giving a reward of one for each descendant that is born</p>
<p>we can amplify this signal by giving a reward of one per turn a decendent is alive</p></li>
</ol></li>
<li>Intrinsic rewards
<ol type="1">
<li>for each rule we add an intrinsic reward</li>
</ol></li>
<li>Utility based approach instead of calulating a reward an agent has a utility function of the state. Their rewards for an action a in <span class="math inline">s\rightarrow a\rightarrow s'</span> is <span class="math inline">U(s')-U(s)</span></li>
</ol></li>
<li><p>Alternitively<br>
they might be given a reward at thier<br>
</p></li>
<li><p>Suppose we generate all generate each agent from a seed</p></li>
<li><p>Recall that MDPs are an extension of MRPs which extend a markov process by adding rewards</p></li>
<li><p>If we consider Sugarscape as a markov process ignoring rewards and</p>
<p>Given access to some subset of states,action,state could can agents lean the dynamics of the simulation. Sugarscape rules are simple.</p></li>
<li><p>This<br>
IF the agent learn the rules they could use that with a utility to estimate the</p></li>
<li></li>
<li><p>the existing rule would become be specific strategy/policy profile in its respective game.</p></li>
<li><p>since policies are probabilistic mapping from states to actions, they be represented as square table whose rows are states and column are actions and the cells hold the probabilities, which should sum to 1 for each column. 1. define a random strategy (assign same/different probability to all states) 1. define simple mutations (reassign probability between transitions 2. define a simple mitosis rule to 3. define a non robust variants</p></li>
<li><p>RL agents might be initially assigned a random uniform strategy then optimize from it using a continuing task RL algorithm.</p></li>
<li><p>Sugarscape is reductionist but typically three or more “rules” are described working in tandem. The serial nature of the rule’s execution seems to mean that in each rule few choices are available.</p>
<ul>
<li>Movement lets you move one step.</li>
<li>Harvesting is determined by location.</li>
<li>Metabolism is automatic.</li>
<li>Aging is automatic</li>
<li>Reproduction is automatic if conditions are right</li>
<li>Trade is also automatic - a once an agent picks a trader the alg will trade regardless of the other traders alternatives. If an agent is building rss for reproduction it will lose any resources it builds. What might help here is being able to switch utility.</li>
</ul></li>
<li><p>What if agents could also learn thier own rules for trade, combat, sex, communcation, bargaing, trade, government etc. This might be easier if rules become multi episode or contious games agent played and they could be assigned or aquire a strategy [uniform-random,nash-equilibrium, ess, pareto-optimal, learned, a strategy] this could also make them baysian players with the ability to respond to the <strong>State of the World</strong> (SOTW) and <strong>Model of Other Agents</strong> (MOA),</p>
<ol type="1">
<li>what about games that are related.
<ul>
<li>we can compose games like move, harvest to get</li>
</ul></li>
</ol></li>
<li><p>Can we teach agents to evolve and communicate efficently.</p>
<ol type="1">
<li>supoprt grammer</li>
<li>support injecting contexts?</li>
<li>support for evolving error corection</li>
</ol></li>
<li><p>Can agents that learn from mistakes? Say by getting another life if it was very unlucky!? <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> And how would that help. <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p></li>
<li><p>How can we make agent explore/exploit thier action space. <strong>Bandits</strong></p></li>
<li><p>How can we make a differntiable utility/fitness/loss which we can differntitate to get intresting gradients</p></li>
<li><p>can we make SugarScape more realistic by adding additional rules. Like the original rules each should make a minimal change</p></li>
<li><p>can we make make the SugerScape grow increasingly more challanging over time?</p></li>
<li><p>can we impose quantifiable selection pressure 1. can we make more commodeties and matching matabolism so that agents need to coordinate gathering and trades. 1. can we make commodeties more scarce 1. can we make agent need to specilize in roles to survive and thrive as a group.</p></li>
<li><p>can we add predetors</p></li>
<li><p>can we add calamaties like earthquakes, hurricanes, avalanches, sugar slides</p></li>
<li><p>can we add differnt ecological regimes:</p>
<ol type="1">
<li>make growback be based on a game of life ruleset.</li>
<li>Agents can overgraze and destroy thier habitat.</li>
<li>Agriculture - Agents can learn to expand thier endowmant by seeding the nearby neighbourhood with glider like patterns that generate resource growth around them. This would allow them to follow the glider and harvest. This is perhaps a hybrid between agriculture and herding.</li>
<li>agents can terraform thier habitat to increase the carying capaciry for thier species/culture metabolism and possibly hostile to thier enemies. with a risk that the world could also lose its carrying capacity. damaged ivable and couse extinction.</li>
<li>polution requires cleanup work before one can harvest again.</li>
<li>deforestation degrades food resuuply.</li>
<li>polution leads to golbabl warming.</li>
<li>polution leads to global cooling.that would disasters like global warming and green house effect that impact metabilism, deasease and resource growth</li>
</ol></li>
<li><p>can we make resource groth less predictable under</p></li>
<li><p>can we force switching from regimes of cooperation, and competition.</p></li>
<li><p>can we make it a RL Gym and run different RL aglorithms.</p></li>
<li><p>Culture seems to minimal. I see a culture rule that is a contrlller for other behavioral rules.</p></li>
<li></li>
<li><p>More trading rules.</p></li>
<li><p>Expanding the economy by adding more commodeties.</p></li>
</ol>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;but isn’t bad luck the ugly face of natural selection!?</p></div><div id="fn2"><p><sup>2</sup>&nbsp;e.g.&nbsp;start life with a better prior</p></div></div><ol type="a">
<li>some commodities</li>
</ol>
<p>can we add speciation: 1. penealty on inbreeding - we add a recesive gene will reduce max age of the child 2. success in sexual reproduction is proprtional to similarity of agents. (compatability) 3. bigger map with different localities i.e.&nbsp;conditions for local genetic advantages to emrege. 4. resistance to parasites and sickness through diversity. (they are transmittion and leathality are linked to genetic/cultural traits)</p>
<ul>
<li><p>Consider representing traits with sugar_metabolism_1 … 5 if all are on you have a metabolism of 5</p></li>
<li><p>vision_1 … 5</p></li>
<li><p>foresight_1 … 5</p></li>
<li><p>There are also immunity genes that give a permanent immunity, temporary immunity, partial_immunitry, carriar status, reduced risk.</p></li>
<li><p>each parasite and sickness can target genetic and or cultural traits.</p></li>
<li><p>each trait is binary</p></li>
<li><p>same for culture</p></li>
<li><p>a second column makes the trait genetic/cultural</p></li>
<li><p>a third column makes the trait dominant or recessive,</p></li>
<li><p>parasites and sickness have a limited number or genes they can flip</p>
<ul>
<li>parasites might turn on metabolism genes</li>
<li>sickness could be trnasmited on contact, proximity or during sex</li>
<li>blindness would eventually kill agents.</li>
</ul></li>
</ul>
<p>changing prefernces: - change can be driven by sickness (e.g.&nbsp;loss of taste, smell, vison) - by scarcity - by culture.</p>
<p>difffernet inheritance rules that are cultural/social in nature</p>
<p>give to the poorest give to the poorest child give to children but equaliznig thier waelth give to a favourite (this can be arbitrary or can be via counter of proximity and or benefits in trade)</p>
<p>what if we change movement to 1. bandit like explore explot 2. ad a prefernce towards better prices with respect to MRS - this can let agent with shor vision a hint of where goods are better distributed.</p>



</section>
</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{bochman2024,
  author = {Bochman, Oren},
  title = {Sugarscape {Ad} {Astra}},
  date = {2024-03-24},
  url = {https://orenbochman.github.io//posts/2024/2024-03-31-sugarscapes/sugar_ad_astra.html},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-bochman2024" class="csl-entry quarto-appendix-citeas" role="listitem">
Bochman, Oren. 2024. <span>“Sugarscape Ad Astra.”</span> March 24, 2024.
<a href="https://orenbochman.github.io//posts/2024/2024-03-31-sugarscapes/sugar_ad_astra.html">https://orenbochman.github.io//posts/2024/2024-03-31-sugarscapes/sugar_ad_astra.html</a>.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("^(?:http:|https:)\/\/www\.quarto\.org\/custom");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
          // default icon
          link.classList.add("external");
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
      for (let i=0; i<annoteTargets.length; i++) {
        const annoteTarget = annoteTargets[i];
        const targetCell = annoteTarget.getAttribute("data-target-cell");
        const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
        const contentFn = () => {
          const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          if (content) {
            const tipContent = content.cloneNode(true);
            tipContent.classList.add("code-annotation-tip-content");
            return tipContent.outerHTML;
          }
        }
        const config = {
          allowHTML: true,
          content: contentFn,
          onShow: (instance) => {
            selectCodeLines(instance.reference);
            instance.reference.classList.add('code-annotation-active');
            window.tippy.hideAll();
          },
          onHide: (instance) => {
            unselectCodeLines();
            instance.reference.classList.remove('code-annotation-active');
          },
          maxWidth: 300,
          delay: [50, 0],
          duration: [200, 0],
          offset: [5, 10],
          arrow: true,
          appendTo: function(el) {
            return el.parentElement.parentElement.parentElement;
          },
          interactive: true,
          interactiveBorder: 10,
          theme: 'quarto',
          placement: 'right',
          popperOptions: {
            modifiers: [
            {
              name: 'flip',
              options: {
                flipVariations: false, // true by default
                allowedAutoPlacements: ['right'],
                fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
              },
            },
            {
              name: 'preventOverflow',
              options: {
                mainAxis: false,
                altAxis: false
              }
            }
            ]        
          }      
        };
        window.tippy(annoteTarget, config); 
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="OrenBochman/blogComments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 Copyright 2024, Oren Bochman
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="../../../about.html">
<p>About</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="../../../license.html">
<p>License</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="../../../trademark.html">
<p>Trademark</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>
    <script type="text/javascript">
    (function(d) {
      d.querySelectorAll(".pseudocode-container").forEach(function(el) {
        let pseudocodeOptions = {
          indentSize: el.dataset.indentSize || "1.2em",
          commentDelimiter: el.dataset.commentDelimiter || "//",
          lineNumber: el.dataset.lineNumber === "true" ? true : false,
          lineNumberPunc: el.dataset.lineNumberPunc || ":",
          noEnd: el.dataset.noEnd === "true" ? true : false,
          titlePrefix: el.dataset.algTitle || "Algorithm"
        };
        pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
      });
    })(document);
    (function(d) {
      d.querySelectorAll(".pseudocode-container").forEach(function(el) {
        titleSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
        titlePrefix = el.dataset.algTitle;
        titleIndex = el.dataset.chapterLevel ? el.dataset.chapterLevel + "." + el.dataset.pseudocodeIndex : el.dataset.pseudocodeIndex;
        titleSpan.innerHTML = titlePrefix + " " + titleIndex + " ";
      });
    })(document);
    </script>
  




<script src="../../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>