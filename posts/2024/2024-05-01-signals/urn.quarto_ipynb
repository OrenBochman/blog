{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "date: 2024-05-02\n",
        "title: \"Urn models using Numpy\"\n",
        "keywords: [\"numpy\", \"probability\", \"urn\", \"polya\", \"hoppe\", \"moran\", \"ehrenfest\"]\n",
        "---\n",
        "\n",
        "\n",
        "Let's create one of the most fundumental models in probability theory - the urn model.\n",
        "\n",
        "Urn models go back to the 17th century and were first introduced in [@bernoulli1713ars] by [Jacob Bernoulli](https://en.wikipedia.org/wiki/Jacob_Bernoulli) \n",
        "The urn model is a simple model that describes the process of drawing balls from an urn. The urn contains balls of different colors, and the goal is to study the probabilities of drawing balls of different colors.\n",
        "\n",
        "Two text on urns models are [@johnson1977urn] and [@mahmoud2008polya]\n",
        "\n",
        "The urn model is a simple model that describes the process of drawing balls from an urn. \n",
        "\n",
        "The urn contains balls of different colors, and the goal is to study the probabilities of drawing balls of different colors.\n",
        "\n",
        "Although basic urn models can be represented with draws from well known distributions\n",
        "an the urn model is useful concrete form for thinking about probability particularly\n",
        "when implementing simple reinforcement learning algorithms or model with Bayesian updating.\n",
        "\n",
        "Some more complex processess in probability theory can be set up as urn model\n",
        "making this a useful model to understand.\n",
        "\n",
        "When it comes to implementing agents, we can quickly set them up for \n",
        "reinforcement or Bayesian learning by equipping the agnet with such an urn model.\n",
        "\n",
        "In python we can implement the urn model using a numpy array to represent the balls in the urn and their counts.\n",
        "\n",
        "\n",
        "\n",
        "The basic operations of the urn model is to draw a ball from the urn and update the urn with the new ball counts.\n",
        "\n",
        "basic operations:\n",
        "\n",
        "- draw() draw a ball from the urn \n",
        "\n",
        "\n",
        "operations:\n",
        "\n",
        "- we might want to draw n balls then observe how many were of a certain color\n",
        "- we might want to draw n balls then update the urn with the new ball counts\n",
        "- we might want to draw n balls without updateing the urn with new balls to capture the current distribution of balls.\n",
        "- convert balls/weights to probabilities\n",
        "- estimate probability of drawing a certain sequence of balls with or without updating the urn.\n",
        "- given n observations of balls estimate the ball proportions and thier confidence intervals.\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "## Urn Models and distributions\n",
        "\n",
        "\n",
        "- [x] The Bernoulli urn model - sampling with replacement from an urn with two balls of different colors yields a binomial distribution.\n",
        "- [x] The Multinomial urn model - sampling with replacement from an urn with more than two balls of different colors yields a multinomial distribution.\n",
        "- hypergeometric urn - sampling without replacement...\n",
        "- urn with sampling with replacement and adding a new ball of the same color\n",
        "- polya urn - when a ball is observed the urn is updated with the same color ball and a new ball of the same color\n",
        "- beta-binomial when ever a ball is observed the urn is updated with the number of balls of the same color\n",
        "- dirichlet\n",
        "- hoppe urn - the urn has a mutator ball that generates new ball color (a new column) and a mutator state that generates new states (a new row)\n",
        "    - derichlet process\n",
        "    - chinee restaurant process \n",
        "- moran urn - like a polya urn but we a;sp remove a ball so that the total number of balls remains constant.\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "## The Basic Urn model \n"
      ],
      "id": "6f016051"
    },
    {
      "cell_type": "code",
      "metadata": {
        "results": "hold",
        "require": "altair, numpy, matplotlib, seaborn, pandas"
      },
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "import altair as alt\n",
        "import pandas as pd\n",
        "\n",
        "class Urn():\n",
        "  ''' classic urn model using np array of ball counts\n",
        "      for two balls this is a model for the  Binomial distribution\n",
        "      for more balls this is a model of the multinomial distribution\n",
        "  '''\n",
        "  def __init__(self, ball_names=['white','black'], init='ones', weights=None):\n",
        "    '''initialize the urn with ball names and weights'''\n",
        "    self.ball_names = ball_names\n",
        "    \n",
        "    if weights is not None:\n",
        "      assert type(weights) == np.ndarray, \"Weights must be a numpy array.\"\n",
        "      assert weights.shape[0] == (len(self.ball_names)), f\"Weight shape {weights.shape} not the same as the number of balls. {len(self.ball_names)}\"\n",
        "      self.weights = weights\n",
        "    else:\n",
        "      if init == 'ones':\n",
        "        self._weights = np.ones((self.ball_colors))\n",
        "      elif init == 'zeros':\n",
        "        self._weights = np.zeros((self.ball_colors))\n",
        "      elif init == 'random':\n",
        "        self._weights = np.random.rand(self.ball_colors)\n",
        "      else:\n",
        "        raise ValueError(\"Initialization parameter must be 'ones', 'zeros', or 'random'.\")\n",
        "\n",
        "  @property\n",
        "  def ball_names(self):\n",
        "    return self._ball_names\n",
        "  \n",
        "  @ball_names.setter\n",
        "  def ball_names(self, ball_names):\n",
        "    assert type(ball_names) == list, \"Ball names must be a list.\"\n",
        "    self._ball_names = ball_names\n",
        "    self._num_balls = len(ball_names)\n",
        "\n",
        "  @property\n",
        "  def ball_colors(self):\n",
        "    return len(self.ball_names)\n",
        "\n",
        "  @property\n",
        "  def weights(self):\n",
        "    return self._weights\n",
        "  \n",
        "  @weights.setter\n",
        "  def weights(self, weights):\n",
        "    assert type(weights) == np.ndarray, \"Weights must be a numpy array.\"\n",
        "    assert weights.shape == (self.ball_colors), \"Weights must have the same shape as the number of balls and columns.\"\n",
        "    #not nan\n",
        "    assert np.isnan(weights).sum() == 0, \"Weights must not be nan.\"\n",
        "    assert weights.sum() > 0, \"Weights must sum to a positive number.\"\n",
        "    \n",
        "    #assert weights.shape == (self.ball_colors), \"Weights must have the same shape as the number of balls and columns.\"\n",
        "    self._weights = weights\n",
        "\n",
        "  def draw(self,n=1):\n",
        "    ''' draw a ball from the urn with replacement'''\n",
        "    row_idx = np.random.choice(self.ball_colors, p=self.weights/self.weights.sum(), size=n)\n",
        "    result = []\n",
        "    for i in range(n):\n",
        "      result.append(self.ball_names[row_idx[i]])\n",
        "    return result"
      ],
      "id": "b0c53a59",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Bernulli Urn Model\n"
      ],
      "id": "ca2a71ae"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: bernoulli-urn-sampling\n",
        "#some examples\n",
        "benulli_urn = Urn()\n",
        "print(benulli_urn.draw(10))\n",
        "print(benulli_urn.draw(10))\n",
        "print(benulli_urn.draw(10))"
      ],
      "id": "bernoulli-urn-sampling",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: bernoulli-urn-weighted\n",
        "\n",
        "benulli_urn.weights = np.array([1., 9.])\n",
        "print(benulli_urn.draw(10))"
      ],
      "id": "bernoulli-urn-weighted",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: bernoulli-urn-weighted-sampling\n",
        "bern_df = pd.DataFrame({'balls': benulli_urn.draw(100)})\n",
        "bern_df.head()"
      ],
      "id": "bernoulli-urn-weighted-sampling",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-urn-bernoulli\n",
        "#| fig-cap: Bernoulli urn model\n",
        "\n",
        "fig=alt.Chart(bern_df).mark_bar().encode(\n",
        "    x='balls',\n",
        "    y='count()'\n",
        ").properties(width=200, height=200)\n",
        "fig.show()"
      ],
      "id": "fig-urn-bernoulli",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Multinomial Urn Model\n"
      ],
      "id": "17a5128e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "multinomial_urn = Urn(ball_names=['red','blue','green'], weights=np.array([3., 9., 1.]))\n",
        "multi_df = pd.DataFrame({'balls': multinomial_urn.draw(100)})\n",
        "multi_df.head()"
      ],
      "id": "1f1ceff9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-urn-multinomial\n",
        "#| fig-cap: Multinomial urn model\n",
        "#alt.renderers.enable(\"html\")\n",
        "alt.Chart(multi_df).mark_bar().encode(\n",
        "    x='balls',\n",
        "    y='count()'\n",
        ").properties(width=200, height=200)"
      ],
      "id": "fig-urn-multinomial",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(multinomial_urn.draw(10))"
      ],
      "id": "6c8c79dd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## The Polya Urn model\n"
      ],
      "id": "06108cc5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: polya-urn-model\n",
        "\n",
        "class Polya(Urn):\n",
        "  ''' \n",
        "    The polya urn model is a generalization of the urn model where c is the number of balls of the same color added to the urn\n",
        "    for c=0 the polya urn model we get drawing with replacement reulting in binomial and multinomial distributions.\n",
        "    for c=1 the polya urn model we get drawing with replacement and adding a new ball of the same color resulting in a  BetaBinomial and Dirichlet distributions.\n",
        "    for c=-1 the polya urn model we get drawing withot replacement resulting in a  the hypergeometric distribution.\n",
        "  '''\n",
        "  \n",
        "  def __init__(self,ball_names=['white','black'], init='ones', weights=None, c=1):\n",
        "    '''initialize the urn with ball names and weights'''\n",
        "    super().__init__(ball_names, init, weights)\n",
        "    self.c = c\n",
        "\n",
        "  def draw(self,n=1,update=True):\n",
        "    ''' \n",
        "    draw a ball from the urn with replacement and add a new ball of the same color\n",
        "\n",
        "    Parameters:\n",
        "    n: int, number of balls to draw\n",
        "    update: bool, update the urn with the new ball counts or keep it frozen    \n",
        "    '''\n",
        "    result = []\n",
        "    for i in range(n):\n",
        "      row_idx = np.random.choice(self.ball_colors, p=self.weights/self.weights.sum(), size=n)\n",
        "      result.append(self.ball_names[row_idx[i]])\n",
        "      if update:\n",
        "        self.weights[row_idx[i]] += self.c\n",
        "    return result"
      ],
      "id": "polya-urn-model",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### BetaBinomial Urn Model - Polya Urn Model with c=1\n",
        "\n",
        "\n",
        "this is not correct - we need to add an operation to return the number white balls from n draws.\n"
      ],
      "id": "b31c5931"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: betabinomial-urn-model\n",
        "\n",
        "betabinomial_urn = Polya(ball_names=['white','black'], c=1)\n",
        "print(betabinomial_urn.draw(10))"
      ],
      "id": "betabinomial-urn-model",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: betabinomial-urn-chart\n",
        "#| fig-cap: BetaBinomial urn model\n",
        "\n",
        "betabinomial_df = pd.DataFrame({'balls': betabinomial_urn.draw(100)})\n",
        "alt.Chart(betabinomial_df).mark_bar().encode(\n",
        "    x='balls',\n",
        "    y='count()'\n",
        ").properties(width=200, height=200)"
      ],
      "id": "betabinomial-urn-chart",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Beta Negative Binomial Distribution - Polya Urn Model with c=1\n",
        "\n",
        "this time \n",
        "\n",
        "\n",
        "### Dirichlet Urn Model - Polya Urn Model with c=1\n",
        "\n",
        "### Hypergeometric Urn Model - Polya Urn Model with c=-1\n"
      ],
      "id": "b806a5b2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: hypergeometric-urn-model\n",
        "\n",
        "hypergeometric_urn = Polya(ball_names=['white','black'], c=-1)\n",
        "print(hypergeometric_urn.draw(10))"
      ],
      "id": "hypergeometric-urn-model",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: hypergeometric-urn-chart\n",
        "#| fig-cap: Hypergeometric urn model\n",
        "\n",
        "hypergeometric_df = pd.DataFrame({'balls': hypergeometric_urn.draw(100)})\n",
        "alt.Chart(hypergeometric_df).mark_bar().encode(\n",
        "    x='balls',\n",
        "    y='count()'\n",
        ").properties(width=200, height=200)"
      ],
      "id": "hypergeometric-urn-chart",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## The Hoppe  Urn models\n"
      ],
      "id": "540cdc10"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "class Hoppe(Polya):\n",
        "  ''' Hoppe urn model'''\n",
        "  \n",
        "  def __init__(self,ball_names=['0'], init='ones', weights=None, c=1, mutator_mass=1.0):\n",
        "    '''initialize the urn with ball names and weights'''\n",
        "    super().__init__(ball_names, init, weights, c)\n",
        "    self.mutator_mass = mutator_mass\n",
        "    if weights is not None:\n",
        "      assert type(weights) == np.ndarray, \"Weights must be a numpy array.\"\n",
        "      assert weights.shape[0] == (len(self.ball_names)), f\"Weight shape {weights.shape} not the same as the number of balls. {len(self.ball_names)}\"\n",
        "      self.weights = weights\n",
        "    else:\n",
        "      if init == 'ones':\n",
        "        self._weights = np.ones((self.ball_colors))\n",
        "      elif init == 'zeros':\n",
        "        self._weights = np.zeros((self.ball_colors))\n",
        "      elif init == 'random':\n",
        "        self._weights = np.random.rand(self.ball_colors)\n",
        "      else:\n",
        "        raise ValueError(\"Initialization parameter must be 'ones', 'zeros', or 'random'.\")\n",
        "      #set the weight of the mutator ball to the mutator mass\n",
        "      self.weights[0] = self.mutator_mass\n",
        "    \n",
        "  def draw(self,n=1):\n",
        "    ''' draw a ball from the urn with replacement and add a new ball of the same color'''\n",
        "    result = []\n",
        "    for i in range(n):\n",
        "      row_idx = np.random.choice(self.ball_colors, p=self.weights/self.weights.sum(), size=1)\n",
        "      if row_idx[i] == 0:\n",
        "        #add a new ball color\n",
        "        self.ball_names.append(str(len(self.ball_names)))\n",
        "        self.weights = np.append(self.weights, c)\n",
        "        result.append(self.ball_names[-1])\n",
        "      else:\n",
        "        result.append(self.ball_names[row_idx[0]])\n",
        "        self.weights[row_idx[i]] += c\n",
        "        \n",
        "    return result"
      ],
      "id": "05d66f4c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## The Moran Urn model\n"
      ],
      "id": "54b9e559"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "class Moran(Polya):\n",
        "  ''' Moran urn model'''\n",
        "  \n",
        "  def draw(self,n=1):\n",
        "    ''' draw a ball from the urn with replacement and add a new ball of the same color'''\n",
        "    result = []\n",
        "    for i in range(n):\n",
        "      row_idx = np.random.choice(self.ball_colors, p=self.weights/self.weights.sum(), size=2)\n",
        "      self.weights[row_idx[0]] += c\n",
        "      self.weights[row_idx[1]] -= c\n",
        "      \n",
        "      result.append(self.ball_names[row_idx[0]])\n",
        "        \n",
        "    return result"
      ],
      "id": "f84a9668",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Ehrenfest Urn Model\n",
        "\n",
        "The Ehrenfest urn model is a simple model that describes the process of moving balls between two urns. I view this as a precursor to compartmental models in epidemiology and other fields and it demostrates how one can extend the urn model can be used to model more complex systems. The more general model is the multiurn model where we have multiple urns and we can move balls between them which is a Markov chain model.\n",
        "\n",
        "\n",
        "The model consists of two urns, each containing a fixed number of balls. At each time step, a ball is randomly selected from one of the urns and moved to the other urn.\n",
        "\n",
        "## The MultiUrn model\n",
        "\n",
        "> \"any problem of probability appears comparable to a suitable problem about bags containing balls, and any random mass phenomenon appears\n",
        "as similar in certain essential respects to successive drawings of balls from a system of suitibly combined bags.\" - @polya1954patterns\n",
        "\n",
        "So I actualy implemented this model first to do some basic RL algorithms for the Lewis Signalling model.\n",
        "\n",
        "The MultiUrn model is an extension of the basic Urn model that allows for multiple urns to be used together.\n",
        "\n",
        "We may for example need to learn an urn model per state in our system extending\n",
        "a bandit algorithm to a contextual bandit algorithm.\n",
        "\n",
        "We can represent these using rows of a matrix where each row represents an urn\n",
        "and each column represents a ball color.\n",
        "\n",
        "In cases where we have hierarchical models we may be able to use additional constraints - for example on both rows and columns to speed up learning.\n"
      ],
      "id": "13ff3ca4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: multi-urn-model\n",
        "\n",
        "class MultiUrn:\n",
        "    def __init__(self, row_names, col_names, init='ones'):\n",
        "        self.row_names = row_names\n",
        "        self.col_names = col_names\n",
        "        self.num_rows = len(row_names)\n",
        "        self.num_cols = len(col_names)\n",
        "        \n",
        "        if init == 'ones':\n",
        "            self.weights = np.ones((self.num_rows, self.num_cols))\n",
        "        elif init == 'zeros':\n",
        "            self.weights = np.zeros((self.num_rows, self.num_cols))\n",
        "        elif init == 'random':\n",
        "            self.weights = np.random.rand(self.num_rows, self.num_cols)\n",
        "        else:\n",
        "            raise ValueError(\"Initialization parameter must be 'ones', 'zeros', or 'random'.\")\n",
        "    \n",
        "    def _convert_to_numeric(self, row_name, col_name):\n",
        "        try:\n",
        "            row_idx = self.row_names.index(row_name)\n",
        "            col_idx = self.col_names.index(col_name)\n",
        "            return row_idx, col_idx\n",
        "        except ValueError:\n",
        "            raise ValueError(\"Invalid row or column name.\")\n",
        "    \n",
        "    def get_weight(self, row_name, col_name):\n",
        "        row_idx, col_idx = self._convert_to_numeric(row_name, col_name)\n",
        "        return self.weights[row_idx, col_idx]\n",
        "    \n",
        "    def set_weight(self, row_name, col_name, value):\n",
        "        row_idx, col_idx = self._convert_to_numeric(row_name, col_name)\n",
        "        self.weights[row_idx, col_idx] = value\n",
        "    \n",
        "    def add_weights(self, other_urn):\n",
        "        if self.weights.shape != other_urn.weights.shape:\n",
        "            raise ValueError(\"Urns must have the same dimensions to add weights.\")\n",
        "        return Urn(self.row_names, self.col_names, init=None, weights=self.weights + other_urn.weights)\n",
        "    \n",
        "    def get_conditional_probabilities(self):\n",
        "        row_sums = self.weights.sum(axis=1, keepdims=True)\n",
        "        conditional_probs = self.weights / row_sums\n",
        "        return conditional_probs\n",
        "    \n",
        "    def get_conditional_probability(self, row_name, col_name):\n",
        "        row_idx, col_idx = self._convert_to_numeric(row_name, col_name)\n",
        "        row_sum = self.weights[row_idx, :].sum()\n",
        "        conditional_prob = self.weights[row_idx, col_idx] / row_sum\n",
        "        return conditional_prob\n",
        "\n",
        "    def choose_option(self, row_name):\n",
        "        row_idx = self.row_names.index(row_name)\n",
        "        row_weights = self.weights[row_idx, :]\n",
        "        col_idx = np.random.choice(self.num_cols, p=row_weights/row_weights.sum())\n",
        "        return self.col_names[col_idx]\n",
        "    \n",
        "    def update_weights(self, row_name, col_name, reward):\n",
        "        row_idx, col_idx = self._convert_to_numeric(row_name, col_name)\n",
        "        self.weights[row_idx, col_idx] += reward\n",
        "\n",
        "    def plot_heatmap(self):\n",
        "        for idx, row_name in enumerate(self.row_names):\n",
        "            plt.figure(figsize=(10, 1))\n",
        "            sns.heatmap(self.weights[idx, :].reshape(1, -1), annot=True, cmap=\"viridis\", cbar=False, xticklabels=self.col_names, yticklabels=[row_name])\n",
        "            plt.title(f\"Urn for {row_name}\")\n",
        "            plt.show()\n",
        "            \n",
        "\n",
        "    def calculate_expected_reward(self, receiver_urn):\n",
        "        result = 0.0\n",
        "        sender_probs = self.get_conditional_probabilities()\n",
        "        receiver_probs = receiver_urn.get_conditional_probabilities()\n",
        "        \n",
        "        for sender_state in self.row_names:\n",
        "            for sender_signal in self.col_names:\n",
        "                p_sender = self.get_conditional_probability(sender_state, sender_signal)\n",
        "                for receiver_signal in receiver_urn.row_names:\n",
        "                    for receiver_state in receiver_urn.col_names:\n",
        "                        p_receiver = receiver_urn.get_conditional_probability(receiver_signal, receiver_state)\n",
        "                        if receiver_signal == sender_signal:\n",
        "                            result += p_sender * p_receiver\n",
        "        return result\n",
        "    \n",
        "    def add_expected_reward(self, receiver_urn):\n",
        "        expected_reward = self.calculate_expected_reward(receiver_urn)\n",
        "        for row_name in self.row_names:\n",
        "            for col_name in self.col_names:\n",
        "                self.update_weights(row_name, col_name, expected_reward)    \n",
        "\n",
        "    def __str__(self):\n",
        "        return str(self.weights)"
      ],
      "id": "multi-urn-model",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: multi-urn-model-examples\n",
        "\n",
        "\n",
        "# Example usage\n",
        "row_names = ['state0', 'state1', 'state2', 'state3', 'state4']\n",
        "col_names = ['a', 'b', 'c', 'd']\n",
        "\n",
        "urn = MultiUrn(row_names, col_names, init='ones')\n",
        "\n",
        "print(\"Initial weights:\")\n",
        "print(urn)\n",
        "\n",
        "weight_0_a = urn.get_weight('state0', 'a')\n",
        "print(f\"Weight for state0 and signal 'a': {weight_0_a}\")\n",
        "\n",
        "urn.set_weight('state0', 'a', 2.0)\n",
        "print(\"Weights after setting weight for state0 and signal 'a' to 0.5:\")\n",
        "print(urn)\n",
        "\n",
        "conditional_probs = urn.get_conditional_probabilities()\n",
        "print(\"Conditional probabilities:\")\n",
        "print(conditional_probs)\n",
        "\n",
        "state = 'state0'\n",
        "signal = 'a'\n",
        "conditional_prob = urn.get_conditional_probability(state, signal)\n",
        "print(f\"Conditional probability of signal {signal} given {state}: {conditional_prob}\")\n",
        "\n",
        "state = 'state1'\n",
        "signal = 'a'\n",
        "conditional_prob = urn.get_conditional_probability(state, signal)\n",
        "print(f\"Conditional probability of signal {signal} given {state}: {conditional_prob}\")\n",
        "\n",
        "chosen_signal = urn.choose_option('state0')\n",
        "print(f\"Chosen signal for state0: {chosen_signal}\")\n",
        "\n",
        "urn.update_weights('state0', 'a', 1.0)\n",
        "print(\"Weights after updating weight for state0 and signal 'a' with a reward of 0.1:\")\n",
        "print(urn)\n",
        "\n",
        "\n",
        "\n",
        "# Plot heatmaps\n",
        "urn.plot_heatmap()"
      ],
      "id": "multi-urn-model-examples",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "s_row_names = ['state0', 'state1', 'state2', 'state3', 'state4']\n",
        "s_col_names = ['a', 'b', 'c', 'd']\n",
        "s_urn = MultiUrn(s_row_names, s_col_names, init='ones')\n",
        "s_urn.plot_heatmap()"
      ],
      "id": "e3aa3872",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "r_row_names = ['a', 'b', 'c', 'd']\n",
        "r_col_names = ['state0', 'state1', 'state2', 'state3', 'state4']\n",
        "r_urn = MultiUrn(r_row_names, r_col_names, init='ones')\n",
        "r_urn.plot_heatmap()"
      ],
      "id": "a61ca628",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "lets add a method to calculate the expected reward of two urns\n",
        "\n",
        "result = 0.0\n",
        "for each sender state sender_state\n",
        "  for each sender signal sender_signal\n",
        "    p_sender = the conditional probability of the sender_signal given the sender_state\n",
        "    for each reciever signal reciever_signal\n",
        "      for each reciever state reciever_state\n",
        "          p_reciever = the conditional probability of the reciever_state given the reciever_signal \n",
        "          if the reciever_signal is the same as the sender_signal\n",
        "            result += p_sender * p_reciever\n",
        "return result\n",
        "\n",
        "# note I think the expected reward could be less then one - since the expected reward is the probability of the reciever signal given the sender signal\n",
        "\n",
        "and sum of probabilities of the reciever signal given the sender signal is less then one.\n",
        "      \n",
        "      \n",
        "        calculate the expected reward\n",
        "        add the expected reward to the urn\n",
        "where we start with a reciever, chose \n"
      ],
      "id": "9e117827"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "expected_reward = s_urn.calculate_expected_reward(r_urn)/(s_urn.num_rows*r_urn.num_cols*s_urn.num_rows*r_urn.num_cols)\n",
        "print(f\"Expected reward: {expected_reward}\")\n",
        "\n",
        "s_urn.add_expected_reward(r_urn)\n",
        "print(\"Sender Urn weights after adding expected reward:\")\n",
        "print(s_urn)\n",
        "s_urn.plot_heatmap()"
      ],
      "id": "34b9b984",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/oren/.local/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}