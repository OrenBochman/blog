{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Vitter Algorithm\"\n",
        "date: \"2025-01-01\"\n",
        "categories: \n",
        "    review\n",
        "    compositionality\n",
        "    neural networks\n",
        "    signaling systems\n",
        "    language evolution\n",
        "keywords: \n",
        "    compositionality\n",
        "    naive compositionality\n",
        "    language emergence\n",
        "    deep learning\n",
        "    neural networks\n",
        "    signaling systems \n",
        "    emergent languages\n",
        "    topographic similarity\n",
        "    positional disentanglement\n",
        "    bag-of-symbols disentanglement\n",
        "    information gap disentanglement    \n",
        "bibliography: ./bibliography.bib\n",
        "image: thumbnail.jpg\n",
        "---\n",
        "\n",
        "\n",
        "This is the vitter algorithm - an algorithm for encoding and decoding messages using Huffman codes.\n",
        "\n",
        "But it is a an adaptive version of the Huffman coding algorithm, which means that it can update the codebook as it processes the message. This is useful when the frequency distribution of characters in the message changes over time.\n",
        "\n",
        "Why do we care ? My idea is that this can stand in as a default protocol for encoding and decoding messages in lewis signaling games with complex signals.\n",
        "\n",
        "The protocol gets updated as the agents play the game and distribution of states shifts.\n",
        "\n",
        "This algorithm support both encoding compositional codes by encoding just atomic symbols or if we encode multiple symbols at a time it can be produce entangled codes.\n",
        "\n",
        "An interesting idea is to designate certain sequences as idioms. Give them higher frequency and encode them as a single symbol. This way we can encode compositional codes and idioms in the same message. But you also avoid collisions between idioms and their atomic counter parts\n",
        "\n",
        "- \"keep the wolf from the door\" idiomatic version - in a 1 block of  6 symbols.\n",
        "- \"keep the wolf from the door\" atomic symbols - as a 6 symbols\n",
        "\n",
        "\n",
        "## Future work:\n",
        "\n",
        "1. add an algorithm for adaptive arithmetic codein - which is more efficient than huffman coding.\n",
        "2. add support for blocking - this is where we encode 4 or more characters at a time. This is useful when the message is very long and we want to reduce the overhead of encoding and decoding.\n",
        "3. Integrate into an agent in the lewis petting zoo environment.\n"
      ],
      "id": "730ebd1f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import heapq\n",
        "\n",
        "class Node:\n",
        "    def __init__(self, char, freq):\n",
        "        self.char = char\n",
        "        self.freq = freq\n",
        "        self.left = None\n",
        "        self.right = None\n",
        "\n",
        "    def __lt__(self, other):\n",
        "        return self.freq < other.freq\n",
        "\n",
        "def build_huffman_tree(chars_freq):\n",
        "    \"\"\"\n",
        "    Builds the Huffman tree for given character frequencies.\n",
        "\n",
        "    Args:\n",
        "        chars_freq: A dictionary of characters and their frequencies.\n",
        "\n",
        "    Returns:\n",
        "        The root of the Huffman tree.\n",
        "    \"\"\"\n",
        "    nodes = []\n",
        "    for char, freq in chars_freq.items():\n",
        "        heapq.heappush(nodes, Node(char, freq))\n",
        "\n",
        "    while len(nodes) > 1:\n",
        "        left = heapq.heappop(nodes)\n",
        "        right = heapq.heappop(nodes)\n",
        "        parent = Node(None, left.freq + right.freq)\n",
        "        parent.left = left\n",
        "        parent.right = right\n",
        "        heapq.heappush(nodes, parent)\n",
        "\n",
        "    return nodes[0]\n",
        "\n",
        "def encode_char(root, char, code=''):\n",
        "    \"\"\"\n",
        "    Encodes a character using Huffman codes.\n",
        "\n",
        "    Args:\n",
        "        root: The root of the Huffman tree.\n",
        "        char: The character to encode.\n",
        "        code: The current code (initially empty).\n",
        "\n",
        "    Returns:\n",
        "        The Huffman code for the character.\n",
        "    \"\"\"\n",
        "    if root is None:\n",
        "        return ''\n",
        "\n",
        "    if root.char == char:\n",
        "        return code\n",
        "\n",
        "    left_code = encode_char(root.left, char, code + '0')\n",
        "    if left_code != '':\n",
        "        return left_code\n",
        "\n",
        "    right_code = encode_char(root.right, char, code + '1')\n",
        "    return right_code\n",
        "\n",
        "def decode_char(root, code):\n",
        "    \"\"\"\n",
        "    Decodes a Huffman code to get the character.\n",
        "\n",
        "    Args:\n",
        "        root: The root of the Huffman tree.\n",
        "        code: The Huffman code to decode.\n",
        "\n",
        "    Returns:\n",
        "        The decoded character.\n",
        "    \"\"\"\n",
        "    current = root\n",
        "    for bit in code:\n",
        "        if bit == '0':\n",
        "            current = current.left\n",
        "        else:\n",
        "            current = current.right\n",
        "\n",
        "    if current.char is not None:\n",
        "        return current.char\n",
        "\n",
        "def encode_message(root, message):\n",
        "    \"\"\"\n",
        "    Encodes a message using Huffman codes.\n",
        "\n",
        "    Args:\n",
        "        root: The root of the Huffman tree.\n",
        "        message: The message to encode.\n",
        "\n",
        "    Returns:\n",
        "        The encoded message.\n",
        "    \"\"\"\n",
        "    encoded_message = ''\n",
        "    for char in message:\n",
        "        encoded_message += encode_char(root, char)\n",
        "    return encoded_message\n",
        "\n",
        "def decode_message(root, encoded_message):\n",
        "    \"\"\"\n",
        "    Decodes a Huffman-encoded message.\n",
        "\n",
        "    Args:\n",
        "        root: The root of the Huffman tree.\n",
        "        encoded_message: The encoded message.\n",
        "\n",
        "    Returns:\n",
        "        The decoded message.\n",
        "    \"\"\"\n",
        "    decoded_message = ''\n",
        "    current = root\n",
        "    for bit in encoded_message:\n",
        "        if bit == '0':\n",
        "            current = current.left\n",
        "        else:\n",
        "            current = current.right\n",
        "\n",
        "        if current.char is not None:\n",
        "            decoded_message += current.char\n",
        "            current = root\n",
        "\n",
        "    return decoded_message\n",
        "\n",
        "# Example usage\n",
        "chars_freq = {'a': 45, 'b': 13, 'c': 12, 'd': 16, 'e': 9, 'f': 5}\n",
        "root = build_huffman_tree(chars_freq)\n",
        "\n",
        "message = \"abcdef\"\n",
        "encoded_message = encode_message(root, message)\n",
        "print(\"Encoded message:\", encoded_message)\n",
        "\n",
        "decoded_message = decode_message(root, encoded_message)\n",
        "print(\"Decoded message:\", decoded_message)"
      ],
      "id": "ab9d5c48",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "another intersting idea is "
      ],
      "id": "69dc343a"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/oren/.local/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}