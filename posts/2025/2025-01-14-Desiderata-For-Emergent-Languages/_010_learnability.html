<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>learnability</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="_010_learnability_files/libs/clipboard/clipboard.min.js"></script>
<script src="_010_learnability_files/libs/quarto-html/quarto.js"></script>
<script src="_010_learnability_files/libs/quarto-html/popper.min.js"></script>
<script src="_010_learnability_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="_010_learnability_files/libs/quarto-html/anchor.min.js"></script>
<link href="_010_learnability_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="_010_learnability_files/libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="_010_learnability_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="_010_learnability_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="_010_learnability_files/libs/bootstrap/bootstrap-3a37d893dbde15df0453402ace248b12.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="learnability---easy-to-learn" class="level3">
<h3 class="anchored" data-anchor-id="learnability---easy-to-learn">1. Learnability - Easy to learn</h3>
<p>Despite its importance, learnability may be overlooked in research on emergent languages. While some settings may not prioritize ease of learning, in lifelong learning environments or multi-generational agent interactions, learnability becomes a crucial factor. Many other desiderata either enhance or hinder learnability</p>
<blockquote class="blockquote">
<p>My experience with the Lewis signaling game is that it is easy to learn and that Natural Languages are not. The difficulty seems to be in finding the right structure for the state space so that the signaling systems generalize well, allowing learners to pick up the language from a few examples and start to communicate effectively with a limited proficiency. At a deeper level if the language arises though a mechanism of spontaneous symmetry breaking, i.e.&nbsp;random choices then will have long term impact on the emergent languages that will increasingly be harder to undo.</p>
</blockquote>
</section>
<section id="insights-from-natural-languages" class="level3">
<h3 class="anchored" data-anchor-id="insights-from-natural-languages">Insights from Natural Languages</h3>
<p>Children typically begin learning to talk in stages:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 34%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>Age</th>
<th>Approximate Vocabulary Size</th>
<th>Language Milestones</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0-6 months</td>
<td>rudimentary signaling</td>
<td>Crying, cooing, babbling</td>
</tr>
<tr class="even">
<td>12 months</td>
<td>~1-5 words</td>
<td>Babbling becomes more complex, First words emerge (e.g., “mama,” “dada”)</td>
</tr>
<tr class="odd">
<td>18 months</td>
<td>~50 words</td>
<td>Vocabulary expands, simple word combinations begin</td>
</tr>
<tr class="even">
<td>24 months</td>
<td>~200-300 words</td>
<td>Two-word phrases, expanding vocabulary</td>
</tr>
<tr class="odd">
<td>30 months</td>
<td>~400-600 words</td>
<td>Three-word sentences, basic grammar structures appear, more verbs/adjectives</td>
</tr>
<tr class="even">
<td>36 months</td>
<td>~1,000 words</td>
<td>Complex sentences, basic grammar</td>
</tr>
<tr class="odd">
<td>4 years</td>
<td>~1,500-2,000 words</td>
<td>Storytelling, past/future tense</td>
</tr>
<tr class="even">
<td>5 years</td>
<td>~2,500-3,000 words</td>
<td>Longer conversations, complex grammar</td>
</tr>
<tr class="odd">
<td>6 years</td>
<td>~5,000+ words</td>
<td>Adult-like speech patterns emerging</td>
</tr>
</tbody>
</table>
<p>Language development varies by individual, but most children can hold simple conversations by age 3 and have a well-developed vocabulary by age 5.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Natural Languages</strong></th>
<th><strong>Emergent Languages</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>proceeds in stages</td>
<td>has one stage</td>
</tr>
<tr class="even">
<td>takes about 5 years</td>
<td>takes o(n^2/2) steps</td>
</tr>
<tr class="odd">
<td>in 5 years 5000 words</td>
<td>2,500,000 time steps<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></td>
</tr>
<tr class="even">
<td>Notoriously difficult to learn</td>
<td>Easy to learn<span class="math inline">\(O(N^2/2)\)</span> <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></td>
</tr>
<tr class="odd">
<td>learning in stages</td>
<td>learning in one stage</td>
</tr>
<tr class="even">
<td>learning is a lifelong process</td>
<td>learning is a one time process</td>
</tr>
<tr class="odd">
<td>learning is a social process</td>
<td>learning is one on one</td>
</tr>
</tbody>
</table>
<div class="line-block">Natural languages are notoriously difficult to learn.| On the other hand emergent languages can be learned in the worst case as quickly as in <span class="math inline">\(O(N^2/2)\)</span>, that is if one neutralizes the stochasticity of the process by requiring that nature prioritize unlearned states before all the learned ones at any given time.|</div>
<p>It doesn’t seem to be much easier to learn a second language once you have already learned the first. However research treats first language acquisition as a different process to second, etc. language acquisition.</p>
<p>In terms of the Lewis signaling game the first language acquisition maps the signals to states, a second language maps the signals to the first language. However in the game the players also engage in the inventing of the language for the first time simultaneously with learning about the state of the world.</p>
<p>The exception seems to be that children master one by the time they are 5 years old. Over time they will improve their proficiency and may learn additional languages. Students of a language may require many examples to learn. Having a dictionary is of limited help. <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> There isn’t an objective metric for tracking how difficult it is to learn a particular language. There is plenty of anecdotal evidence that some languages are easier to learn, as well as some languages are harder for native speakers of a second language. There are many challenges along the way.</p>
<p>Part of <a href="https://en.wikipedia.org/wiki/Nature_versus_nurture">Nature v.s. Nurture debate</a> is to what degree is the language instinct hard coded into us. c.f. Pinker’s books the blank slate and the language instinct. It</p>
<p>I often get hung up on why are natural languages (AKA man’s greatest invention) are such a challenge to learn and what this might mean for my investigation into emergence of language.</p>
<p>Hypothesis: Complex signaling that fulfill enough desiderata may suffer from reduced learnability. I think that the core desiderata might actually allow for languages with graded burden of learnability.</p>
<p>Questions: Howe can we evaluate the learnability of a signaling system? What are the metrics that we can use to evaluate the learnability of a signaling system?</p>
<section id="metrics-for-learnability" class="level4">
<h4 class="anchored" data-anchor-id="metrics-for-learnability">Metrics for Learnability</h4>
<section id="todo" class="level5 callout-info" data-collapse="true">
<h5 class="anchored" data-anchor-id="todo">TODO:</h5>
<p>I’m uncertain if other have studied learnability in the context of emergent languages. So there is an open challenge in defining good metrics that can guide progress in this area.</p>
<ol type="1">
<li><label><input type="checkbox">research this in the litrature.</label></li>
</ol>
</section>
<p>In RL we do however have metrics that are associated with learning. These are: 1. The number of examples needed to learn a task. 2. The generalization of the learned task. 3. The stability of the learned task.</p>
<ol type="1">
<li><p>Evidence that agents have learned the signaling systems is that they can communicate effectively. This is measures in terms of expected success rate. During learning this may take a long time to converge to 1.0.</p></li>
<li><p>In the tabular setting <span class="math inline">\(n^2/s\)</span> seems to be the worst case for agents engaged purely with learning a signaling system.</p></li>
<li><p>The best case is O(n) - i.e.&nbsp;if the receiver could see the state it would still need to see The faster the agent reach 1.0 the better they</p></li>
<li><p>The most obvious metric is the success rate for the agents in carrying out communications. However this by itself is not enough. In the original game the best case path to learning generally requires at least n^2/2 tries and the algorithms used do not usually need to generalize. In the complex signaling systems we might have infinite or prohibitively large state spaces and even for finite one potentially unbounded number of signals.</p></li>
<li><p>A second idea is how many examples are needed to be seen before agent get a good grasp of the language.</p></li>
</ol>
<ul>
<li><p>In <span class="citation" data-cites="goldsmith-2001-unsupervised">[@goldsmith-2001-unsupervised]</span> the author considered the induction of morphology using Minimal description length MDL - the number of bits needed to describe the signaling system is what agents need to coordinate between them to learn a shared communication system. In Goldsmith’s work he considered a corpus and then compared it to to the a corpus compressed + the binary of an encoder built from templates and a frequency lexicon. Goldsmith showed that by learning a morphology it was possible to compressed corpus + the binary of the encoder into less then the original corpur. his is a good metric for the learnability of a signaling system. In the case of emergent languages</p></li>
<li><p>I should make a review of this great paper but the gist is that there is a lexicon and a morphology based on a set of templates that are used to generate the words. <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p></li>
<li><p>We like to consider two cases: <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p></li>
</ul>
<ol type="1">
<li>there is a sender/teacher with a good signaling system and a receiver/student learning it.</li>
<li>there is no sender/teacher and the agents have to construct such a signaling system from scratch.</li>
</ol>
<p>the above notion if MDL is a good metric for the first case but not the second. In the second case we need to consider the complexity of the state space as well as the algorithmic complexity arriving at a common communication system. The cost of coordination of an MDL is subsumed by the cost due to complexity of constructing optimal signaling system that faithfully represent the structure of the state space.</p>
<p>Another two points:</p>
<ul>
<li>Learning a partial system should give agents better benefits than not.</li>
<li>Learning as a group should be easier and quicker than learning individually.</li>
<li>e.g.&nbsp;Learning of rules (grammar/morphology) should amplify the learning and generalization of the speaker wrt the structure of the state space.</li>
</ul>
<p>RL based metrics for learnability are:</p>
<ol type="1">
<li>cumulative reward <span class="math inline">\(G_T\)</span> if normalized becomes the average reward per time step or expected success rate.</li>
<li>Sample efficiency</li>
<li>convergence rate - how long till policy stabilizes or stops improving</li>
<li>regret - Measures how much reward is lost due to suboptimal actions compared to an optimal policy. Defined as <span class="math inline">\(R_t = G^*-G_t\)</span> where <span class="math inline">\(G^*\)</span> is the optimal cumulative reward</li>
<li>entropy of the policy- Measures randomness in action selection</li>
<li>policy stability</li>
<li>success rate/ task completion rate</li>
<li>generalization</li>
<li>exploration vs exploitation ballance</li>
</ol>
<p>For hierarchical RL additional metrics may include subtask efficiency, hierarchical consistency, and intrinsic reward utilization to assess the learning of macro-actions and task decomposition.</p>
</section>
</section>
<section id="references" class="level3">
<h3 class="anchored" data-anchor-id="references">References</h3>
<p>In the review paper <span class="citation" data-cites="Nowak2002ComputationalAE">[@Nowak2002ComputationalAE]</span>, the authors discuss Learnability.</p>
<p>One of the main points in the paper is Gold’s Theorem, concerning the impossibility of learning an unrestricted set of languages. The authors also discuss the necessity of innate expectations in language acquisition, arguing that the human brain’s learning algorithm can learn existing human languages but not all computable languages.</p>
<blockquote class="blockquote">
<p>Gold’s theorem formally states there exists no algorithm that can learn a set of ‘super-finite’ languages. Such a set includes all finite languages and at least one infinite language. Intuitively, if the learner infers that the target language is an infinite language, whereas the actual target language is a finite language that is contained in the infinite language, then the learner will not encounter any contradicting evidence, and will never converge onto the correct language. This result holds in greatest possible generality: ‘algorithm’ here includes any function from text to language.</p>
</blockquote>
<p>I drew the following sources for this section: <span class="citation" data-cites="bloom2013one">[@bloom2013one]</span>, <span class="citation" data-cites="fenson2000variability">[@fenson2000variability]</span>, <span class="citation" data-cites="hoff2009language">[@hoff2009language]</span>, <span class="citation" data-cites="hart1995meaningful">[@hart1995meaningful]</span></p>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>4.7 years at 1 step per minute<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>perhaps not so easy as N increases to millions and there are a a small chance of errors per symbol<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>for lewis signaling games where agents learn a lexicon this is is all an agent needs to learn the signaling system.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>As it overgenerates, it might be necessary to store a bit-list of which lexicon items can be used with which templates. though I don’t actually recall this being the case as the might be an infinite number.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>I have already written an article on some different ways that signaling systems can be arise.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>