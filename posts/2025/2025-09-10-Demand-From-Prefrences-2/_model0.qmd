---
date: 2025-10-02
title: Model 0
subtitle: "Microeconomics Model of Consumer Demand from Preferences"
description: ""
categories: [Shinylive for python, Model thinking, Simulation]
keywords: [Shiny, Shinylive for python, Mesa,Agent-Based Modeling, POC, Wealth distribution, Altair, Pyodide,]
filters:
  - shinylive
---

This is the original app I developed. The nonparametric approach is all about minimal assumptions. I want demand to emerge from preferences and wealth constraints.

I used an  chatgpt-5 LLM as an co-pilot. 
It actively resisted Using mesa with shinylive and created a minimal mesa-like core instead. This is why I dropped this model as one of the objectives is to develop a Mesa-Shinylive integration.

The model incorporates reinforcement of preferences via a Pólya-Urn model. The model follows a retail supermarket setting i.e. products quantity is unlimited and prices are random but fixed for the simulation.

In the next model I added mesa support and allow products to evolve using a Hoppe urn model. 

Some ideas from this model:

1. [ ] agents are Heterogeneous in wealth and preferences
2. [ ] agents have a budget constraint
3. [ ] agents preferences evolve and reinforce via a Pólya-Urn model
4. [ ] agents have bounded rationality (they do not optimize, they use a simple heuristic)
5. [ ] agents live on a grid
6. [ ] Agents can swap locations to be closer to similar agents (Homophily) based on a scheme similar to Schelling's segregation model.
7. Agents have a "happiness" metric based on whether they can afford their top-4 preferred products.

### Successes:

A Pólya-urn is a good way model to create heterogeneous preferences.


### Issues:

2. I am using a simple reinforcement mechanism to drive heterogeneity of preferences. However this is just a first step. 
3. A feedback mechanism should constructed based on some metric like cost of satisfying preferences subject to an agent budget constraint.
4. **Saving** Agents may go for broke or they may also place a value on savings. I.e. they may increase thier welfare to some extent by having a `product` called money. 
5. Agents that save money may be able to afford more expensive products over time so it also makes sense to smooth happiness over time and to track its fluctuations.

There are two conflicting tensions in my mind:

2. It isn't clear how to use **feedback**. But I would like to allow the agents to not only reinforce their preferences but to make choices based on what they can afford.
3. We should track the agents welfare and happiness based on thier ability to satisfy thier preference. they should be less happy than if they can. A
4. In real markets there are many products and individual consumers only buy a few.
5. There should be an evolution of budget i.e. a minimum wage so that as new products are introduced, agents have the purchasing power to buy them. I.e. wealth should be

### Further work:

1. Segregation and spatial interaction:
    - I started working on adding a grid and another process that does some sort of spatial interaction between agents so that agents at different locations can swap places to be closer to similar agents.
    - The main goal here is to create demand curves that vary by location.
    - This might be further refined later by adding a regional supermarket that serves a local population and use these to aggregate local demand.
    - Again supply side could be added later with these supermarkets prioritizing products and prices based on local demand patterns. I.e. we simulate the middle man ability to make profit by catering to local changes in demand.

6. Prices in this model are randomly assigned and fixed. In reality prices and production quantities are determined by supply and demand. In this sim I am assuming a unlimited supply of products at fixed prices. Adding the supply side should also add the  allow prices to evolve based on demand

7. Fitting to data: These are ABM models however once they are refined it may be useful to consider if one can fit the parameters to match real data. However at this point I see little point in doing this, beyond perhaps a thought experiment.


:::{.column-screen-inset-right}
```shinylive-python
#| standalone: true
#| viewerHeight: 600
#| components: [viewer] #[editor, viewer]

_='''{.markdown} 
from __future__ import annotations
## Tasks:

'''

# app.py — ShinyLive-ready ABM Polya-Urn demo (Mesa-lite core) + Altair via shinywidgets.
# Paste into shinylive.io/py/examples as app.py and Run.


from dataclasses import dataclass
from typing import Dict, List, Tuple
import random
from collections import Counter

import pandas as pd
import altair as alt

from shiny import App, Inputs, Outputs, Session, reactive, render, ui
from shinywidgets import render_altair, output_widget

# ---------- helpers ----------
def top_n(d: Dict[int, int], n: int) -> List[Tuple[int, int]]:
    return sorted(d.items(), key=lambda kv: (-kv[1], kv[0]))[:n]

def weighted_choice(keys: List[int], weights: List[int]) -> int:
    return random.choices(keys, weights=weights, k=1)[0]

# ---------- domain ----------
@dataclass(frozen=True)
class Product:
    idx: int
    sku: str
    letter: str
    price: float

@dataclass
class Agent:
    aid: int
    wealth: float
    urn: Dict[int, int]        # sku_idx -> bead count
    counts: Dict[int, int]     # cumulative draws per sku
    top4: List[int]
    happy: bool

    def step(self, products: List[Product], l: int = 1) -> int:
        last = -1
        for _ in range(l):
            ks = list(self.urn.keys())
            ws = [self.urn[k] for k in ks]
            k = weighted_choice(ks, ws)
            self.urn[k] += 1               # Polya reinforcement
            self.counts[k] = self.counts.get(k, 0) + 1
            last = k
        self.top4 = [k for k, _ in top_n(self.counts, 4)]
        total_price = sum(products[k].price for k in self.top4) if self.top4 else 0.0
        self.happy = (total_price <= self.wealth)
        return last

class Market:
    def __init__(self, K:int=8, n_agents:int=100, seed:int=42, base_wealth:float=10.0, wealth_jitter:float=2.0):
        random.seed(seed)
        self.products = make_products(K)
        self.agents = [
            Agent(
                aid=i+1,
                wealth=max(0.0, random.gauss(base_wealth, wealth_jitter)),
                urn={j:1 for j in range(K)},  # one bead per SKU
                counts={},
                top4=[],
                happy=False,
            )
            for i in range(n_agents)
        ]
        self.t = 0
        self._demand_rows: List[Dict] = []

    def step(self, l:int=1):
        self.t += 1
        drawn = [a.step(self.products, l=l) for a in self.agents]
        tick_counts = Counter(drawn)
        for idx, cnt in sorted(tick_counts.items()):
            p = self.products[idx]
            self._demand_rows.append({"t": self.t, "sku_idx": idx, "sku": p.sku, "letter": p.letter, "count": cnt})

    def grid_df(self) -> pd.DataFrame:
        ids = list(range(1, len(self.agents)+1))
        return pd.DataFrame({
            "id": ids,
            "happy": [a.happy for a in self.agents],
        })

    def top4_df(self) -> pd.DataFrame:
        recs = []
        for a in self.agents:
            letters = [self.products[k].letter for k in a.top4]
            price_sum = round(sum(self.products[k].price for k in a.top4), 2)
            recs.append({"agent": a.aid, "top4": "".join(letters), "sum_price": price_sum, "happy": a.happy})
        return pd.DataFrame(recs)

    @property
    def demand_ts(self) -> pd.DataFrame:
        return pd.DataFrame(self._demand_rows) if self._demand_rows else pd.DataFrame(columns=["t","sku_idx","sku","letter","count"])

# ---------- factories ----------
def make_products(K:int=8) -> List[Product]:
    letters = [chr(ord("A")+i) for i in range(K)]
    prices  = [round(1.0 + 0.5*i, 2) for i in range(K)]
    return [Product(i, f"SKU{i+1:02d}", letters[i], prices[i]) for i in range(K)]

def reset_market(K:int, seed:int, wealth_mu:float, wealth_sd:float) -> Market:
    return Market(K=K, n_agents=100, seed=seed, base_wealth=wealth_mu, wealth_jitter=wealth_sd)

# ---------- UI ----------
PERSON_PATH = (
    "M1.7 -1.7h-0.8c0.3 -0.2 0.6 -0.5 0.6 -0.9c0 -0.6 "
    "-0.4 -1 -1 -1c-0.6 0 -1 0.4 -1 1c0 0.4 0.2 0.7 0.6 "
    "0.9h-0.8c-0.4 0 -0.7 0.3 -0.7 0.6v1.9c0 0.3 0.3 0.6 "
    "0.6 0.6h0.2c0 0 0 0.1 0 0.1v1.9c0 0.3 0.2 0.6 0.3 "
    "0.6h1.3c0.2 0 0.3 -0.3 0.3 -0.6v-1.8c0 0 0 -0.1 0 "
    "-0.1h0.2c0.3 0 0.6 -0.3 0.6 -0.6v-2c0.2 -0.3 -0.1 "
    "-0.6 -0.4 -0.6z"
)

app_ui = ui.page_fluid(
    ui.h2("ABM Polya-Urn Demand (Mesa-lite)"),
    ui.row(
        ui.column(3,
            ui.input_numeric("seed", "Seed", 7),
            ui.input_slider("K", "Number of products K", min=4, max=12, value=8),
            ui.input_slider("wealth_mu", "Wealth mean", min=2, max=30, value=10),
            ui.input_slider("wealth_sd", "Wealth sd", min=0, max=10, value=2),
            ui.input_numeric("l_draws", "Draws per tick (l)", 1, min=1, max=4),
            ui.input_action_button("btn_reset", "Reset"),
            ui.input_action_button("btn_step",  "Step"),
            ui.input_action_button("btn_10",    "Run 10"),
            ui.hr(),
            ui.output_table("price_table"),
            ui.hr(),
            ui.output_table("last_tick_demand"),
        ),
        ui.column(5,
            ui.card(
                ui.card_header("Agents on 10×10 grid (blue=happy, red=unhappy)"),
                output_widget("grid_plot"),
            ),
            ui.card(
                ui.card_header("Demand time series by SKU (lines)"),
                output_widget("demand_plot"),
            ),
        ),
        ui.column(4,
            ui.card(
                ui.card_header("Top-4 per agent (after last tick)"),
                ui.output_table("top4_table"),
            ),
        )
    ),
)

# ---------- server ----------
def server(input: Inputs, output: Outputs, session: Session):

    market = reactive.value(reset_market(K=8, seed=7, wealth_mu=10, wealth_sd=2))

    @reactive.effect
    @reactive.event(input.btn_reset)
    def _reset():
        market.set(reset_market(K=int(input.K()), seed=int(input.seed()),
                                wealth_mu=float(input.wealth_mu()), wealth_sd=float(input.wealth_sd())))

    @reactive.effect
    @reactive.event(input.btn_step)
    def _step_once():
        market().step(l=int(input.l_draws()))

    @reactive.effect
    @reactive.event(input.btn_10)
    def _step_10():
        for _ in range(10):
            market().step(l=int(input.l_draws()))

    @output
    @render.table
    def price_table():
        prods = market().products
        return pd.DataFrame({
            "idx":[p.idx for p in prods],
            "sku":[p.sku for p in prods],
            "letter":[p.letter for p in prods],
            "price":[p.price for p in prods],
        })

    @output
    @render.table
    def last_tick_demand():
        ts = market().demand_ts
        if ts.empty:
            return pd.DataFrame(columns=["t","sku","letter","count"])
        last_t = ts["t"].max()
        return ts.loc[ts["t"]==last_t, ["t","sku","letter","count"]].sort_values(["letter"])

    @output
    @render.table
    def top4_table():
        return market().top4_df().sort_values(["happy","sum_price","agent"], ascending=[False, True, True])

    @output
    @render_altair
    def grid_plot():
        df = market().grid_df().assign(
            status=lambda d: d["happy"].map({True: "Happy", False: "Unhappy"})
        )
        return (
            alt.Chart(df)
            .transform_calculate(row="ceil(datum.id/10)")
            .transform_calculate(col="(datum.id - 1) % 10 + 1")
            .mark_point(filled=True, size=60)
            .encode(
                alt.X("col:O").axis(None),
                alt.Y("row:O").axis(None),
                alt.ShapeValue(PERSON_PATH),
                color=alt.Color(
                    "status:N",
                    scale=alt.Scale(domain=["Happy", "Unhappy"], range=["#3A86FF", "#E63946"]),
                ),
                tooltip=["id", "status"],
            )
            .properties(width=420, height=420)
            .configure_view(strokeWidth=0)
        )

    @output
    @render_altair
    def demand_plot():
        ts = market().demand_ts
        df = ts if not ts.empty else pd.DataFrame({"t": [], "count": [], "letter": []})
        return (
            alt.Chart(df)
            .mark_line(interpolate="monotone")
            .encode(
                x="t:Q",
                y="count:Q",
                color="letter:N",
                tooltip=["t", "letter", "count"],
            )
            .properties(width=460, height=300)
        )

app = App(app_ui, server)


## file: requirements.txt
altair
anywidget
palmerpenguins
jsonschema
```
:::
