---
date: 2025-10-02
title: Model 0
subtitle: "Microeconomics Model of Consumer Demand from Preferences"
description: ""
categories: [Shinylive for python, Model thinking, Simulation]
keywords: [Shiny, Shinylive for python, Mesa,Agent-Based Modeling, POC, Wealth distribution, Altair, Pyodide,]
filters:
  - shinylive
---





:::{.column-screen-inset-right}
```shinylive-python
#| standalone: true
#| viewerHeight: 600
#| components: [viewer] #[editor, viewer]

_='''{.markdown} 
from __future__ import annotations
## Tasks:

'''

# app.py — ShinyLive-ready ABM Polya-Urn demo (Mesa-lite core) + Altair via shinywidgets.
# Paste into shinylive.io/py/examples as app.py and Run.


from dataclasses import dataclass
from typing import Dict, List, Tuple
import random
from collections import Counter

import pandas as pd
import altair as alt

from shiny import App, Inputs, Outputs, Session, reactive, render, ui
from shinywidgets import render_altair, output_widget

# ---------- helpers ----------
def top_n(d: Dict[int, int], n: int) -> List[Tuple[int, int]]:
    return sorted(d.items(), key=lambda kv: (-kv[1], kv[0]))[:n]

def weighted_choice(keys: List[int], weights: List[int]) -> int:
    return random.choices(keys, weights=weights, k=1)[0]

# ---------- domain ----------
@dataclass(frozen=True)
class Product:
    idx: int
    sku: str
    letter: str
    price: float

@dataclass
class Agent:
    aid: int
    wealth: float
    urn: Dict[int, int]        # sku_idx -> bead count
    counts: Dict[int, int]     # cumulative draws per sku
    top4: List[int]
    happy: bool

    def step(self, products: List[Product], l: int = 1) -> int:
        last = -1
        for _ in range(l):
            ks = list(self.urn.keys())
            ws = [self.urn[k] for k in ks]
            k = weighted_choice(ks, ws)
            self.urn[k] += 1               # Polya reinforcement
            self.counts[k] = self.counts.get(k, 0) + 1
            last = k
        self.top4 = [k for k, _ in top_n(self.counts, 4)]
        total_price = sum(products[k].price for k in self.top4) if self.top4 else 0.0
        self.happy = (total_price <= self.wealth)
        return last

class Market:
    def __init__(self, K:int=8, n_agents:int=100, seed:int=42, base_wealth:float=10.0, wealth_jitter:float=2.0):
        random.seed(seed)
        self.products = make_products(K)
        self.agents = [
            Agent(
                aid=i+1,
                wealth=max(0.0, random.gauss(base_wealth, wealth_jitter)),
                urn={j:1 for j in range(K)},  # one bead per SKU
                counts={},
                top4=[],
                happy=False,
            )
            for i in range(n_agents)
        ]
        self.t = 0
        self._demand_rows: List[Dict] = []

    def step(self, l:int=1):
        self.t += 1
        drawn = [a.step(self.products, l=l) for a in self.agents]
        tick_counts = Counter(drawn)
        for idx, cnt in sorted(tick_counts.items()):
            p = self.products[idx]
            self._demand_rows.append({"t": self.t, "sku_idx": idx, "sku": p.sku, "letter": p.letter, "count": cnt})

    def grid_df(self) -> pd.DataFrame:
        ids = list(range(1, len(self.agents)+1))
        return pd.DataFrame({
            "id": ids,
            "happy": [a.happy for a in self.agents],
        })

    def top4_df(self) -> pd.DataFrame:
        recs = []
        for a in self.agents:
            letters = [self.products[k].letter for k in a.top4]
            price_sum = round(sum(self.products[k].price for k in a.top4), 2)
            recs.append({"agent": a.aid, "top4": "".join(letters), "sum_price": price_sum, "happy": a.happy})
        return pd.DataFrame(recs)

    @property
    def demand_ts(self) -> pd.DataFrame:
        return pd.DataFrame(self._demand_rows) if self._demand_rows else pd.DataFrame(columns=["t","sku_idx","sku","letter","count"])

# ---------- factories ----------
def make_products(K:int=8) -> List[Product]:
    letters = [chr(ord("A")+i) for i in range(K)]
    prices  = [round(1.0 + 0.5*i, 2) for i in range(K)]
    return [Product(i, f"SKU{i+1:02d}", letters[i], prices[i]) for i in range(K)]

def reset_market(K:int, seed:int, wealth_mu:float, wealth_sd:float) -> Market:
    return Market(K=K, n_agents=100, seed=seed, base_wealth=wealth_mu, wealth_jitter=wealth_sd)

# ---------- UI ----------
PERSON_PATH = (
    "M1.7 -1.7h-0.8c0.3 -0.2 0.6 -0.5 0.6 -0.9c0 -0.6 "
    "-0.4 -1 -1 -1c-0.6 0 -1 0.4 -1 1c0 0.4 0.2 0.7 0.6 "
    "0.9h-0.8c-0.4 0 -0.7 0.3 -0.7 0.6v1.9c0 0.3 0.3 0.6 "
    "0.6 0.6h0.2c0 0 0 0.1 0 0.1v1.9c0 0.3 0.2 0.6 0.3 "
    "0.6h1.3c0.2 0 0.3 -0.3 0.3 -0.6v-1.8c0 0 0 -0.1 0 "
    "-0.1h0.2c0.3 0 0.6 -0.3 0.6 -0.6v-2c0.2 -0.3 -0.1 "
    "-0.6 -0.4 -0.6z"
)

app_ui = ui.page_fluid(
    ui.h2("ABM Polya-Urn Demand (Mesa-lite)"),
    ui.row(
        ui.column(3,
            ui.input_numeric("seed", "Seed", 7),
            ui.input_slider("K", "Number of products K", min=4, max=12, value=8),
            ui.input_slider("wealth_mu", "Wealth mean", min=2, max=30, value=10),
            ui.input_slider("wealth_sd", "Wealth sd", min=0, max=10, value=2),
            ui.input_numeric("l_draws", "Draws per tick (l)", 1, min=1, max=4),
            ui.input_action_button("btn_reset", "Reset"),
            ui.input_action_button("btn_step",  "Step"),
            ui.input_action_button("btn_10",    "Run 10"),
            ui.hr(),
            ui.output_table("price_table"),
            ui.hr(),
            ui.output_table("last_tick_demand"),
        ),
        ui.column(5,
            ui.card(
                ui.card_header("Agents on 10×10 grid (blue=happy, red=unhappy)"),
                output_widget("grid_plot"),
            ),
            ui.card(
                ui.card_header("Demand time series by SKU (lines)"),
                output_widget("demand_plot"),
            ),
        ),
        ui.column(4,
            ui.card(
                ui.card_header("Top-4 per agent (after last tick)"),
                ui.output_table("top4_table"),
            ),
        )
    ),
)

# ---------- server ----------
def server(input: Inputs, output: Outputs, session: Session):

    market = reactive.value(reset_market(K=8, seed=7, wealth_mu=10, wealth_sd=2))

    @reactive.effect
    @reactive.event(input.btn_reset)
    def _reset():
        market.set(reset_market(K=int(input.K()), seed=int(input.seed()),
                                wealth_mu=float(input.wealth_mu()), wealth_sd=float(input.wealth_sd())))

    @reactive.effect
    @reactive.event(input.btn_step)
    def _step_once():
        market().step(l=int(input.l_draws()))

    @reactive.effect
    @reactive.event(input.btn_10)
    def _step_10():
        for _ in range(10):
            market().step(l=int(input.l_draws()))

    @output
    @render.table
    def price_table():
        prods = market().products
        return pd.DataFrame({
            "idx":[p.idx for p in prods],
            "sku":[p.sku for p in prods],
            "letter":[p.letter for p in prods],
            "price":[p.price for p in prods],
        })

    @output
    @render.table
    def last_tick_demand():
        ts = market().demand_ts
        if ts.empty:
            return pd.DataFrame(columns=["t","sku","letter","count"])
        last_t = ts["t"].max()
        return ts.loc[ts["t"]==last_t, ["t","sku","letter","count"]].sort_values(["letter"])

    @output
    @render.table
    def top4_table():
        return market().top4_df().sort_values(["happy","sum_price","agent"], ascending=[False, True, True])

    @output
    @render_altair
    def grid_plot():
        df = market().grid_df().assign(
            status=lambda d: d["happy"].map({True: "Happy", False: "Unhappy"})
        )
        return (
            alt.Chart(df)
            .transform_calculate(row="ceil(datum.id/10)")
            .transform_calculate(col="(datum.id - 1) % 10 + 1")
            .mark_point(filled=True, size=60)
            .encode(
                alt.X("col:O").axis(None),
                alt.Y("row:O").axis(None),
                alt.ShapeValue(PERSON_PATH),
                color=alt.Color(
                    "status:N",
                    scale=alt.Scale(domain=["Happy", "Unhappy"], range=["#3A86FF", "#E63946"]),
                ),
                tooltip=["id", "status"],
            )
            .properties(width=420, height=420)
            .configure_view(strokeWidth=0)
        )

    @output
    @render_altair
    def demand_plot():
        ts = market().demand_ts
        df = ts if not ts.empty else pd.DataFrame({"t": [], "count": [], "letter": []})
        return (
            alt.Chart(df)
            .mark_line(interpolate="monotone")
            .encode(
                x="t:Q",
                y="count:Q",
                color="letter:N",
                tooltip=["t", "letter", "count"],
            )
            .properties(width=460, height=300)
        )

app = App(app_ui, server)


## file: requirements.txt
altair
anywidget
palmerpenguins
jsonschema
```
:::
