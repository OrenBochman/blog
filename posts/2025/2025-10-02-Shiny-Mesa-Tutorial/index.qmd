---
date: 2025-10-02
title: ShinyLive ❤️ Mesa Tutorial
subtitle: "POC of a Mesa tutorial running in the browser with ShinyLive for Python"
description: "This is my vibe coding guide on how I built a POC of concept for running Mesa app (their tutorial) in ShinyLive app so it can run in the browser without a front end."
categories: [Shinylive for python, Model thinking, Simulation]
keywords: [Shiny, Shinylive for python, Mesa,Agent-Based Modeling, POC, Wealth distribution, Altair, Pyodide]
filters:
  - shinylive
---

In this is the Mesa tutorial integrated into a shiny app and running via `Pyodide` in the browser from a static backend. I had some background with both shiny and mesa. However, it was a while since I coded with  either and I realized that both had some major changes. I actually fixed some mesa bugs and made a custom version for this blog. But Mesa is getting lots of changes and so I needed something simple for the POC. 
I wanted to use a co-pilot for getting up to speed on the changes and for filling in the gaps about things like reactive programming which I also have some experience but less so in python. So In this post we
will cover

1. The challenges of adapting Mesa to work with the reactive architecture required by Shiny. Shiny apps are usually split into UI and Server parts. We want to be able to have good control of the mesa sim running in the server without exposing it directly to the UI.
1. For a long time the Shiny-Quarto integration raised  issues which turned out to be show stoppers. I cover how I faced and solved them some of these into notes. 
3. Vibe coding Working with a ai-copilot was a major requirement for this project. I find that the ai can help with a quick start but also may become a liability if not handled well. I realize, many people are facing this type of challenge and I am trying to also indicate how I used the copilot to overcome some of my own weaknesses from previous projects. 

:::{.callout-note}

## TL;DR: A POC for Getting Mesa Agent-Based Modeling to run in the browser via ShinyLive and Altair.

This is a proof of concept (POC) for running the Mesa tutorial in a Shiny app using ShinyLive for Python.

I've created hundreds of dashboards using BI tools but always considered Shiny as my goto solution for truly custom dashboards projects. Only I moved to python a decade or so back and Shiny was R only. Now with the new Shiny for Python, I can finally use Shiny with Python. Also Shiny needed a backend which is not ideal for lightweight projects like MVP and their POC. But with ShinyLive for Python it is possible to run on a static site with everything running in the browser.

On the way I also started using Mesa for ABM and Altair for very lightweight declarative widgets. But these tools did not play. Until now Mesa also had a clunky backend which required a server. But as this POC demonstrates we can do it all in python and run it in the server.
:::

## The POC

- Chat GPT was able to write some small shiny and some mesa sims over the last three years. But getting shiny and mesa together was more that It could stomach when I asked for this. It would create a mesa lite clone from scratch instead when asked to create a hybrid solution.

- So to make the POC I got started on the playground with shinylive.io. I quickly found out that since my last visit it was ok running MESA. Mesa had had since dropped some dependencies and `Pyodide` added support for `scipy` which Mesa depends on. (I actually made a version of `mesa` without this as only one function was used from `scipy` and I had created a tree line replacement.) This however required running everything locally which ended up a problematic proposition.

- Moving on I was able to add the two main classes from the mesa tutorial, add the changes required and integrate with the shiny. I replaced the the plotting with altair using another demo. This required more changes like exposing the state as a dataframe. But I had something working in less than an hour. 

- I think that most of the time LLMs are glorified cut and paste solutions - they can rewrite bit and pieces early well but they need to be able to retrieve something that is close enough. Usually someone has coded something smarter and better than your next idea and the LLM has seen it in training. There is lots of mesa and shiny code out these. But probably nothing very helpful for chat GPT so it messed up. On the other hand making POCs for my idea has always been one of my core strength when it comes to coding. A second one is the ability to handle fairly complex systems. And one of my weakness is deviating from KISS.

- Next steps were to get the initial demo fully functional. I had reactivity issues, extra code, no interactivity in the ui. The tutorial called for checking different setting of steps, agents and repetitions. 

- I added some ui for these as well a dashboard title. but it didn't get picked up by the sim.

- I was missing some annotation to make the sim function reactive.
- I needed to access the UI sliders for the current values instead of using a global state
- Once I had these in place it was more or less done.
- I need to remove some extra bits of code and do the write up.
- I had used $GPT_5$ as my copilot to get some minor fixes. It generally said great job just fix this line and gave a drop in replacement. In the next bit - the grid it would again be less helpful at coding and more as a troubleshooter.


::: {.callout-tip}
## Trouble shooting with a co-pilot

- Java is well known for hundreds of line cascading error messages. This was exacerbated by an idiomatic/idiotic style of deeply nested anonymous constructs. I thought I liked Java for many years but felt that I was just waiting for the day I would design something soo much better to code in.
- In this setting (quarto + filters + python + shinylive + mesa + altair + `Pyodide`) I quickly found that there were long cascading errors and some might be in the command line other in the `shiny` console with other yet in the browser's console.
- Instead of trying to decipher these issues I asked my co-pilot for help. This saved my eyes and sanity.
- [We come to a project with very limited human resources. The LLM can be either multiply and mentor or it it can become a demon that completely eat our limited capacity using complexity or via griefing ( not being helpful). It is up to us to figure out how to go with multiply and learn while avoiding any griefing process as soon as it starts. ]{.mark}
- Ask the co-pilot was able to help me identify these issues. If it can't fix them this is a strong indicator indicator that you should step in. You are now in charge of the fix and you get to ask for advice on specific parts of your plan. This will save lots of time and get you more familiar with reading the code.
- Always remember you are the boss, stakeholder etc and the co-pilot should be your side-kick.
:::


:::{.column-screen-inset}
```{shinylive-python}
#| standalone: true
#| viewerHeight: 600
#| components: [viewer] #[editor, viewer]

from shiny import reactive, render
from shiny.express import input, ui
from shinywidgets import render_altair

import numpy as np
import pandas as pd

import seaborn as sns
import altair as alt

import mesa


### UI for Agent Sim ##############################################

DEFAULT_RUNS = 100
DEFAULT_STEPS = 30
DEFAULT_AGENTS = 12

# Add page title and sidebar
ui.page_opts(title="Mesa Wealth Agents Tutorial in Shineylive for Python", fillable=True)


with ui.sidebar(open="desktop"):
    ui.input_slider("runs", "Runs", min=1, max=500, value=DEFAULT_RUNS)
    ui.input_slider("steps", "Steps per run", min=1, max=500, value=DEFAULT_STEPS)
    ui.input_slider("agents", "Agents", min=1, max=50, value=DEFAULT_AGENTS)
    ui.input_action_button("reset", "Reset")


### MESA MODEL ###################################################


class MoneyAgent(mesa.Agent):
    """An agent with fixed initial wealth."""

    def __init__(self, model):
        # Pass the parameters to the parent class.
        super().__init__(model)

        # Create the agent's variable and set the initial values.
        self.wealth = 1

    def exchange(self):
        # Verify agent has some wealth
        if self.wealth > 0:
            other_agent = self.random.choice(self.model.agents)
            if other_agent is not None:
                other_agent.wealth += 1
                self.wealth -= 1


class MoneyModel(mesa.Model):
    """A model with some number of agents."""

    def __init__(self, n):
        super().__init__()
        self.num_agents = n

        # Create agents
        MoneyAgent.create_agents(model=self, n=n)

    def step(self):
        """ Advance the model by one step."""
        # This function pseudo-randomly reorders the list of agent objects and
        # then iterates through calling the function passed in as the parameter
        self.agents.shuffle_do("exchange")


#ui.input_selectize("var", "Select variable", choices=["bill_length_mm", "body_mass_g"])


# ---------- RESET BEHAVIOR ----------
@reactive.effect
@reactive.event(input.reset)
def _reset_sliders():
    # These update_* helpers pick up the current session implicitly in Shiny Express
    ui.update_slider("runs", value=DEFAULT_RUNS)
    ui.update_slider("steps", value=DEFAULT_STEPS)
    ui.update_slider("agents", value=DEFAULT_AGENTS)

# ---------- SIMULATION (reactive) ----------
@reactive.calc
def sim_df():
    runs = input.runs()
    steps = input.steps()
    n = input.agents()

    all_wealth = []
    for _ in range(runs):
        model = MoneyModel(n)
        for _ in range(steps):
            model.step()
        # collect wealth after final step of this run
        all_wealth.extend(a.wealth for a in model.agents)

    return pd.DataFrame({"wealth": all_wealth})


# ---------- PLOT ----------
@render_altair
def hist():
    df = sim_df()  # depends on inputs via sim_df()
    return (
        alt.Chart(df, title="Wealth distribution")
        .mark_bar()
        .encode(x=alt.X("wealth:Q", bin=True, title="Wealth"),
                y=alt.Y("count()", title="Agents"))
        .properties(width="container", height=300)
        .interactive()
    )


## file: requirements.txt
shinyswatch
altair
anywidget
palmerpenguins
jsonschema
mesa
scipy
tqdm
```
:::

---

## About Wealth agents:

We run 1-500 simulations (runs) of 1-500 (steps) each with 1-50 (agents).

Each agent starts with one unit of wealth. At each step, every agent randomly selects another agent and gives them one unit of wealth if they have at least one unit to give. 

After all runs are complete, we plot the distribution of wealth among all agents. Any change to the parameters re runs the simulation. Note that in
ABM and RL we often run the simulation a number of times to avoid local view of the behavior. We then need to aggregate the data and if we do this well we get a deeper (more distributional view of the data.)


---

## Linear Notes

- I wanted this for a long time but couldn't get it to work in quarto. 
- I recently asked $GPT_5$ for help buy it faked the mesa code. It worked ok but I felt cheated.
- I knew I could do better. So I decided to try running MVP mesa model on the Shiny for Python website using the playground.
- Shiny was ok installing mesa - a good sign
- The tutorial worked more or less.
- But it refused to render in my quarto project. 
- Getting it to work locally was 90% of the work 
- I had the Sine shiny app on my blog so I tried again there - it failed.
- In fact this was just another failure in a long line of failures with shinylive.
- I had many issues here is a summary from $GPT_5$ of the the main ones we troubleshooted together. 

Moving parts:

1. Quarto
2. [ShinyLive extension](https://github.com/quarto-ext/shinylive) for Quarto
    1. install `pip install shinylive --upgrade`
    2. `quarto add quarto-ext/shinylive`
    3. modify `_quarto.yml`

    ```yml  
    > filters:
    >  - shinylive    
    ```
   
    4. add to the quarto page frontmatter yml

    ```yml
    > filters:
    >  - shinylive
    ```

    5. add `shinylive-python` code blocks with the actual app
    6. to use more screen real estate wrap code with `::: {.column-screen-inset}`
    7. Add dependency to `requirements.txt` in `shinylive-python` block

```shinylive-python
#| standalone: true
#| components: [editor, viewer]
## file: app.py
from shiny import App, ui render
from utils import square

# [App code here...]

## file: utils.py

def square(x, n):
    row = ui.div([x] * n)
    return ui.div([row] * n)

## file: requirements.txt
shinyswatch

## file: www/logo.png
## type: binary
iVBORw0KGgoAAAANSUhEUgAAACgAAA ...
```

3. ShinyLive for Python (CLI, assets, `Pyodide`)
    1. install `pip install shinylive shiny`
    2. download assets tends to fail so I side-loaded it from [shinylive repo](https://github.com/posit-dev/shinylive/releases)
    3. It tends to time out so I used `wget` with retries and unpacked it.
    4. The shinylive expects it to be extracted.

```bash
cd ~/.cache/shinylive

wget -c -4 \
  --tries=0 \
  --waitretry=5 \
  --timeout=30 \
  --read-timeout=30 \
  --retry-connrefused \
  --show-progress \
  --server-response \
  'https://github.com/posit-dev/shinylive/releases/download/v0.10.5/shinylive-0.10.5.tar.gz'

tar -xzf shinylive-0.10.5.tar.gz
```
4. Shiny for Python (behind the scenes)
5. Altair for charts
    - add to requirements.txt per 1.
6. Mesa for agent-based modeling (Heterogeneity)


- The Mesa Tutorial gives us a layer for doing Agent Based Simulation of wealth distribution 
- I figured how to add it to the altair demo
- I dropped some widgets.
- I added new widgets per the tutorial request
- I then needed to make things reactive - i.e. refresh when the simulation parameters change
  - Removed global vars for UI elements (replaced by default values)
  - Added annotations for the UI elements
  - Split chart rendering from simulation
  - Made these parts reactive as well.
  - Altair is great for small prototypes and quick visualizations. But crashes with large datasets. This is a known limitation but I have not fixed it in this version yet (todo: cap the number of row in the data frame, or aggregate so we don't exceed the Altair limits)
- The shiny app can also show an editor with all of the code. This is part of the meta data at the top of the code block. I have hidden it for now.

## What Next Part 2 Adding the grid to Mesa

1. In this part I quickly got the grid in place. 
2. I did not know how to handle a `seaborn` chart in 
shiny, it is actually simpler than `altair` which requires `shinyextras`

::: {.callout-tip} 

### vibe coding - Roles switching

Vibe coding means being able to expediently switch roles between Project Manager, Lead dev, Trouble shooter etc. Expediency is primarily being on top of cost benefit of working with a co-pilot over even other devs.

The co-pilot is often an idiot-savant it knows a lot but can get stuck on tiny details. It is here that you can lose a lot of time. Rather than getting it to fix it you should ideally always be able to jump in and do the fix yourself. I used to work with the legendry "David Allouch" who said once "I never ask my workers to do anything I can't do myself".

 If it knows a lot more than you do about some part of the project that is fine so long as you remember that you are the lead and you will quickly catch up. 



- It is good document what you want to do on two levels
    1. you need a plan, 
    1. you need to remember everything
    2. you need to communicate what you are want doing to your co-pilot
- It smart to comment on the shortcoming of what has been done so far. You co-pilot can sometimes suggest quick or immediate fixes to things you don't even want to think about because there are bigger issues. 
:::

1. I want to be able to be able to switch between interactive mode on an off
    1. On - View the sim step by step
    2. Off run many sims. Turn of in
    3. See where we are




Here’s a summary + a fast triage for some hiccups.

### What we fixed (recap)

* **Env mismatch** → Pointed Quarto to your venv (`execute.python: .venv/bin/python` or `QUARTO_PYTHON`).
* **Wrong invocation** → Use the **`shinylive` CLI**, not `python -m shinylive`.
* **Assets flakiness** → Side-loaded GitHub release assets and **unpacked** them under `~/.cache/shinylive/shinylive-0.10.x` (and, if needed, `~/.local/share/shinylive/`), verified with `shinylive assets info`.
* **Clean builds** → Use `quarto render --clean` (no `quarto clean` command).


## Future plans

So I've had a number of successful shiny and mesa apps over the last three years but now it's time to integrate them into interactive versions that users can engage with in thier browsers.

Also I think that the ability to specify multiple files in one code block is ideal for vibe coding POC or MVPs.

1. Adding space part of the tutorial on this page
2. Sugarscape and other model thinking models I've developed.
3. Demand from preferences Microeconomics model
4. Demand curve simulator and forecasting 
5. Lewis Signaling Bayesian algs. and RL
6. Sugarscape as a POMDP with  RL or MARL.
7. PYMC NDLM POC using ABM for simulating consumer behavior (in progress)
8. Urn Models with ABM
9. Lotka-Volterra equations population dynamics demos
10. SIR models with ABM
11. Bayesian MCMC algorithms demos
12. BNP (Bayesian Nonparametric Models) demos
13. Integrating with LLM support in Shiny.
    - [chatlas](https://github.com/posit-dev/chatlas)
    - [querychat](https://github.com/posit-dev/querychat)
14. Price theory demos
