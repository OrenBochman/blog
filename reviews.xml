<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Oren Bochman&#39;s Blog</title>
<link>https://orenbochman.github.io/reviews.html</link>
<atom:link href="https://orenbochman.github.io/reviews.xml" rel="self" type="application/rss+xml"/>
<description>Personal website, portfolio and blog</description>
<generator>quarto-1.5.57</generator>
<lastBuildDate>Thu, 26 Sep 2024 14:07:51 GMT</lastBuildDate>
<item>
  <title>Multi-column Deep Neural Networks for Image Classification</title>
  <link>https://orenbochman.github.io/reviews/2012/Multi-column deep neural networks for image classi cation/</link>
  <description><![CDATA[ 




<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">TL;DR</h2>
<p>In <span class="citation" data-cites="cireşan2012multicolumndeepneuralnetworks">(Cireşan, Meier, and Schmidhuber 2012)</span> titled “Multi-column Deep Neural Networks for Image Classification”, the authors, Dan Cireşan, Ueli Meier, Juergen Schmidhuber introduce a biologically plausible deep artificial neural network architecture that achieves near-human performance on tasks such as the recognition of handwritten digits or traffic signs. The method uses small receptive fields of convolutional winner-take-all neurons to yield large network depth, resulting in roughly as many sparsely connected neural layers as found in mammals between retina and visual cortex. The authors demonstrate that their approach outperforms humans on a traffic sign recognition benchmark and improves the state-of-the-art on various image classification benchmarks.</p>
</section>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<blockquote class="blockquote">
<p>Traditional methods of computer vision and machine learning cannot match human performance on tasks such as the recognition of handwritten digits or traffic signs. Our biologically plausible deep artificial neural network architectures can. Small (often minimal) receptive fields of convolutional winner-take-all neurons yield large network depth, resulting in roughly as many sparsely connected neural layers as found in mammals between retina and visual cortex. Only winner neurons are trained. Several deep neural columns become experts on inputs preprocessed in different ways; their predictions are averaged. Graphics cards allow for fast training. On the very competitive MNIST handwriting benchmark, our method is the first to achieve near-human performance. On a traffic sign recognition benchmark it outperforms humans by a factor of two. We also improve the state-of-the-art on a plethora of common image classification benchmarks. — <span class="citation" data-cites="cireşan2012multicolumndeepneuralnetworks">(Cireşan, Meier, and Schmidhuber 2012)</span></p>
</blockquote>
</section>
<section id="review" class="level2">
<h2 class="anchored" data-anchor-id="review">Review</h2>
<p>In <span class="citation" data-cites="cireşan2012multicolumndeepneuralnetworks">(Cireşan, Meier, and Schmidhuber 2012)</span> the authors make significant strides in the field of image classification by demonstrating the effectiveness of multi-column deep neural networks (DNNs). <mark>This work is noteworthy for its pioneering approach in applying deep learning techniques to image classification tasks, which have since become the foundation of modern computer vision systems.</mark></p>
</section>
<section id="key-contributions" class="level2">
<h2 class="anchored" data-anchor-id="key-contributions">Key Contributions</h2>
<p>The authors present a system that uses several deep neural networks, each operating as a “column,” which are trained independently. The outputs of these networks are then averaged to form the final prediction. This multi-column approach exploits the diversity between different networks and boosts classification accuracy, reducing the impact of overfitting and improving generalization. Notably, the method achieved state-of-the-art results on several image classification benchmarks at the time, including the MNIST digit recognition task.</p>
<p>One of the central contributions of this paper is the demonstration of how <mark>combining multiple deep networks can outperform single networks in complex image classification tasks</mark>. The authors trained their models on NVIDIA GPUs, which allowed them to scale deep networks efficiently—a relatively new practice when this paper was published, underscoring its innovative edge.</p>
</section>
<section id="strengths" class="level2">
<h2 class="anchored" data-anchor-id="strengths">Strengths</h2>
<ul>
<li><p><strong>Improvement on Benchmarks</strong>: The multi-column DNN approach delivered unprecedented accuracy on datasets like MNIST, achieving an error rate of just 0.23%. This represents one of the early breakthroughs that paved the way for deep learning in computer vision.</p></li>
<li><p><strong>Effective Use of Parallelism</strong>: The paper highlights the use of modern GPUs to efficiently train deep networks, illustrating how hardware advancements can accelerate research progress.</p></li>
<li><p><strong>Generalizability</strong>: While the paper focuses on MNIST and other datasets, the multi-column DNN framework offers a flexible approach to other image classification tasks. The general architecture and training methodology could be adapted to more complex datasets, making this work highly relevant across a variety of image recognition problems.</p></li>
<li><p><strong>Robustness</strong>: By averaging outputs from multiple networks, the system reduces the sensitivity to the specific architecture or initialization of a single network. This ensemble-like approach increases robustness and reduces error rates.</p></li>
</ul>
</section>
<section id="weaknesses" class="level2">
<h2 class="anchored" data-anchor-id="weaknesses">Weaknesses</h2>
<ul>
<li><p><strong>Lack of Theoretical Insight</strong>: Although the empirical results are impressive, the paper does not delve deeply into the theoretical reasons behind the success of multi-column architectures. It remains unclear how much of the performance gain is due to ensembling versus the intrinsic strength of the individual networks.</p></li>
<li><p><strong>Computational Cost</strong>: The approach requires training multiple deep neural networks independently, which could be computationally expensive for larger datasets or higher-dimensional inputs. While GPUs mitigate this to an extent, scaling the multi-column approach to larger tasks would demand significant computational resources.</p></li>
<li><p><strong>Limited Applicability to Other Modalities</strong>: The paper focuses solely on image classification. While it hints at the potential for multi-column networks in other domains (e.g., audio or text), the paper doesn’t explore these extensions or provide empirical evidence beyond the image domain.</p></li>
</ul>
</section>
<section id="impact-and-relevance" class="level2">
<h2 class="anchored" data-anchor-id="impact-and-relevance">Impact and Relevance</h2>
<p>This paper marked a turning point for deep learning in computer vision, showing the power of combining deep networks for complex tasks like image classification. Its success on benchmarks like MNIST helped popularize deep learning as a dominant method for pattern recognition and set the stage for more advanced techniques. Although it primarily focuses on image classification, the insights regarding ensemble learning through independent deep networks have since inspired various approaches in different machine learning areas, including speech recognition and natural language processing.</p>
<p>The paper is particularly significant when viewed in the context of its time (2012), as it predated the massive adoption of deep learning across industries. Its methods were fundamental to later developments in deep convolutional neural networks, which have become a cornerstone of state-of-the-art models in computer vision tasks today.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Ciresan, Meier, and Schmidhuber’s work on multi-column deep neural networks represents a crucial step forward in the development of image classification techniques. Its impact on deep learning, especially in terms of model ensembling and parallelization using GPUs, cannot be overstated. While it comes with some computational challenges and lacks deep theoretical explanation, the paper’s practical results and novel approach have solidified its place as a landmark contribution in the history of deep learning.</p>
</section>
<section id="the-paper" class="level2">
<h2 class="anchored" data-anchor-id="the-paper">The paper</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="./paper.pdf" class="col-page" width="800" height="1000"></p>
<figcaption>paper</figcaption>
</figure>
</div>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-cireşan2012multicolumndeepneuralnetworks" class="csl-entry">
Cireşan, Dan, Ueli Meier, and Juergen Schmidhuber. 2012. <span>“Multi-Column Deep Neural Networks for Image Classification.”</span> <a href="https://arxiv.org/abs/1202.2745">https://arxiv.org/abs/1202.2745</a>.
</div>
</div></section></div> ]]></description>
  <guid>https://orenbochman.github.io/reviews/2012/Multi-column deep neural networks for image classi cation/</guid>
  <pubDate>Thu, 26 Sep 2024 14:07:51 GMT</pubDate>
  <media:content url="https://orenbochman.github.io/reviews/2012/Multi-column deep neural networks for image classi cation/cover.jpg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>Improving Neural Networks by Preventing Co-Adaptation of Feature Detectors</title>
  <link>https://orenbochman.github.io/reviews/2012/dropout/</link>
  <description><![CDATA[ 




<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">TL;DR</h2>
<p>In <span class="citation" data-cites="hinton2012improvingneuralnetworkspreventing">(Hinton et al. 2012)</span> titled “Improving Neural Networks by Preventing Co-Adaptation of Feature Detectors”, the authors, Hinton, Geoffrey E., Nitish Srivastava, Alex Krizhevsky, Ilya Sutskever, and Ruslan R. Salakhutdinov introduces a new regularization technique called “Dropout” that helps to prevent overfitting in neural networks. Dropout is a simple and effective way to improve the performance of neural networks by preventing co-adaptation of feature detectors. The authors show that dropout can be used to improve the performance of a wide range of neural networks, including deep networks, convolutional networks, and recurrent networks.</p>
</section>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<blockquote class="blockquote">
<p>Deep neural nets with a large number of parameters are very powerful machine learning systems. However, overfitting is a serious problem in such networks. Large networks are also slow to use, making it difficult to deal with overfitting by combining the predictions of many different large neural nets at test time. Dropout is a technique for addressing this problem. The key idea is to randomly drop units (along with their connections) from the neural network during training. This prevents units from co-adapting too much. During training, dropout samples from an exponential number of different “thinned” networks. At test time, it is easy to approximate the effect of averaging the predictions of all these thinned networks by simply using a single unthinned network that has smaller weights. This significantly reduces overfitting and gives major improvements over other regularization methods. We show that dropout improves the performance of neural networks on supervised learning tasks in vision, speech recognition, document classification, and computational biology, obtaining state-of-the-art results on many benchmark data sets.</p>
</blockquote>
</section>
<section id="review" class="level2">
<h2 class="anchored" data-anchor-id="review">Review</h2>
<p>, introduces the dropout technique as an innovative method to prevent overfitting in neural networks. Overfitting occurs when a model performs well on training data but poorly on unseen test data, particularly when dealing with a large number of parameters and limited training samples. The paper addresses this by proposing the use of dropout, a regularization technique that randomly omits units (neurons) during training.</p>
</section>
<section id="core-ideas" class="level2">
<h2 class="anchored" data-anchor-id="core-ideas">Core Ideas</h2>
<p>The central concept behind dropout is to prevent co-adaptation of feature detectors. In a traditional neural network, feature detectors can co-adapt to specific patterns in the training data, which leads to poor generalization. By randomly omitting neurons with a probability of 0.5 during training, each neuron is forced to contribute independently to the final output. This reduces the reliance on specific sets of neurons and ensures that each feature detector learns useful patterns.</p>
<p>Another significant advantage of dropout is that it acts as an efficient form of model averaging. Training with dropout can be seen as training an ensemble of neural networks that share parameters, making it computationally feasible to obtain better generalization without having to train multiple models.</p>
</section>
<section id="experimental-results" class="level2">
<h2 class="anchored" data-anchor-id="experimental-results">Experimental Results</h2>
<p>The authors demonstrate the effectiveness of dropout on several benchmark datasets, including MNIST, CIFAR-10, ImageNet, TIMIT, and the Reuters corpus.</p>
<ul>
<li>MNIST: Dropout reduced the error rate from 160 errors to around 110 by applying 50% dropout to hidden units and 20% dropout to input units.</li>
<li>TIMIT: Dropout improved frame classification accuracy in speech recognition tasks, reducing the error rate by 3% in comparison to standard training methods.</li>
<li>CIFAR-10: The authors achieved a 16.6% error rate without dropout and 15.6% with dropout, outperforming previous state-of-the-art results.</li>
<li>ImageNet: Dropout applied to deep convolutional neural networks (CNNs) reduced the error rate from 48.6% to 42.4%.</li>
<li>Reuters Corpus: Dropout reduced classification error from 31.05% to 29.62%.</li>
</ul>
</section>
<section id="theoretical-contributions" class="level2">
<h2 class="anchored" data-anchor-id="theoretical-contributions">Theoretical Contributions</h2>
<p>The theoretical underpinning of dropout is grounded in model averaging and regularization. In standard practice, model averaging is performed by training multiple models and averaging their predictions, but this approach is computationally expensive. Dropout provides a far more efficient alternative by implicitly training an ensemble of models that share parameters, thus achieving the benefits of model averaging without the overhead of training separate models.</p>
<p>Additionally, dropout mitigates the problem of overfitting by introducing noise during training, making the model more robust. At test time, all units are used, but their outgoing weights are scaled to reflect the fact that fewer units were active during training.</p>
</section>
<section id="discussion-and-impact" class="level2">
<h2 class="anchored" data-anchor-id="discussion-and-impact">Discussion and Impact</h2>
<p>The introduction of dropout represents a major step forward in the development of deep learning models, as it allows for better generalization across a variety of tasks. Its simplicity, coupled with its effectiveness, has made dropout a standard tool in neural network training. The experiments conducted in the paper demonstrate its utility across a wide range of tasks, from image recognition to speech processing, providing compelling evidence of its broad applicability.</p>
<p>The idea of preventing co-adaptation of feature detectors to improve generalization is an elegant solution to a longstanding problem in neural network training. By ensuring that each neuron must work independently, dropout forces the model to learn more robust features that generalize well to unseen data.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>This paper is a highly influential paper that introduced a novel technique for improving the generalization of deep learning models. The results speak for themselves, with dropout achieving state-of-the-art performance across multiple datasets and tasks. The technique has since become a standard part of neural network training, revolutionizing the field and contributing to the success of deep learning in real-world applications.</p>
</section>
<section id="the-paper" class="level2">
<h2 class="anchored" data-anchor-id="the-paper">The paper</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="./paper.pdf" class="col-page" width="800" height="1000"></p>
<figcaption>paper</figcaption>
</figure>
</div>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-hinton2012improvingneuralnetworkspreventing" class="csl-entry">
Hinton, Geoffrey E., Nitish Srivastava, Alex Krizhevsky, Ilya Sutskever, and Ruslan R. Salakhutdinov. 2012. <span>“Improving Neural Networks by Preventing Co-Adaptation of Feature Detectors.”</span> <a href="https://arxiv.org/abs/1207.0580">https://arxiv.org/abs/1207.0580</a>.
</div>
</div></section></div> ]]></description>
  <guid>https://orenbochman.github.io/reviews/2012/dropout/</guid>
  <pubDate>Thu, 26 Sep 2024 14:07:51 GMT</pubDate>
</item>
<item>
  <title>ImageNet Classification with Deep Convolutional Neural Networks</title>
  <link>https://orenbochman.github.io/reviews/2012/imagenet/</link>
  <description><![CDATA[ 




<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">TL;DR</h2>
<p><span class="citation" data-cites="krizhevsky2012imagenet">(Krizhevsky, Sutskever, and Hinton 2012)</span> is a seminal paper in the field of deep learning. It introduced the AlexNet architecture, which won the ImageNet Large Scale Visual Recognition Challenge in 2012. The paper is a great starting point for anyone interested in deep learning, as it provides a detailed explanation of the architecture and training process of the network.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="./paper.pdf" class="col-page" width="800" height="1000"></p>
<figcaption>paper</figcaption>
</figure>
</div>
<p>In <span class="citation" data-cites="krizhevsky2012imagenet">(Krizhevsky, Sutskever, and Hinton 2012)</span> titled “ImageNet Classification with Deep Convolutional Neural Networks”, the authors Alex Krizhevsky, Ilya Sutskever, and Geoffrey Hinton presents the development and training of a large deep convolutional neural network (CNN) for image classification using the ImageNet dataset.</p>
<p>Thus paper marks a pivotal point in the development of deep learning, particularly in the realm of computer vision. The authors introduced a large convolutional neural network (CNN) trained on the ImageNet dataset, which significantly outperformed previous models, winning the <a href="https://www.image-net.org/challenges/LSVRC">ImageNet Large Scale Visual Recognition Challenge</a> (ILSVRC) in 2012 with a top-5 test error rate of 15.3%.</p>
<section id="key-contributions" class="level3">
<h3 class="anchored" data-anchor-id="key-contributions">Key Contributions:</h3>
<ul>
<li><p><strong>Architecture</strong>: The CNN consists of five convolutional layers and three fully connected layers, with the final layer being a softmax classifier that distinguishes between 1000 categories. This architecture involves a total of 60 million parameters and 650,000 neurons.</p></li>
<li><p><strong>GPU Utilization</strong>: Training was performed on two GTX 580 GPUs to speed up the process, allowing them to handle the large network size and dataset. This took approximately 5-6 days to complete.</p></li>
<li><p><strong>Techniques to Improve Performance</strong>: The network used a variety of novel techniques to improve both performance and training time:</p>
<ul>
<li><strong>Rectified Linear Units</strong> (ReLUs): These non-saturating neurons were employed to speed up training, which was crucial for dealing with such a large model.</li>
<li><strong>Dropout</strong>: A regularization method was used in fully connected layers to prevent overfitting by randomly dropping some neurons during training.</li>
<li><strong>Data Augmentation</strong>: The authors employed various forms of data augmentation, including random crops, horizontal flips, and color variation via principal component analysis (PCA), which greatly expanded the size of the training set and further reduced overfitting.</li>
</ul></li>
</ul>
<p>overfitting.</p>
</section>
</section>
<section id="results-and-impact" class="level2">
<h2 class="anchored" data-anchor-id="results-and-impact">Results and Impact</h2>
<p>The network trained for the ILSVRC 2010 and 2012 challenges achieved top-1 and top-5 error rates of 37.5% and 17.0%, respectively, for ILSVRC 2010, far surpassing previous methods based on feature extraction and boosting. In the ILSVRC 2012 competition, the network reduced the top-5 error to 15.3%, compared to the 26.2% achieved by the second-best entry. This result not only established CNNs as the state-of-the-art model for image classification tasks but also cemented the importance of deep learning in the broader machine learning community.</p>
</section>
<section id="challenges-and-limitations" class="level2">
<h2 class="anchored" data-anchor-id="challenges-and-limitations">Challenges and Limitations</h2>
<p>The authors acknowledge that their network size was constrained by the available GPU memory and that improvements in both hardware and larger datasets could potentially improve the performance of such models in the future.</p>
<p>The CNN’s architecture and optimization techniques pioneered by this paper have set a foundation for subsequent advances in deep learning, particularly in image recognition tasks.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>The paper demonstrated the feasibility and efficacy of training deep networks on large-scale datasets and provided key insights into architectural choices, regularization, and optimization. This work has since inspired a plethora of follow-up research, leading to advancements such as transfer learning, fine-tuning on smaller datasets, and the further development of GPU-based training methods. The innovations introduced in this paper laid the groundwork for the modern AI revolution in image recognition and beyond.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-krizhevsky2012imagenet" class="csl-entry">
Krizhevsky, Alex, Ilya Sutskever, and Geoffrey E Hinton. 2012. <span>“Imagenet Classification with Deep Convolutional Neural Networks.”</span> <em>Advances in Neural Information Processing Systems</em> 25.
</div>
</div></section></div> ]]></description>
  <guid>https://orenbochman.github.io/reviews/2012/imagenet/</guid>
  <pubDate>Thu, 26 Sep 2024 14:07:51 GMT</pubDate>
</item>
<item>
  <title>Handwriting beautification using token means</title>
  <link>https://orenbochman.github.io/reviews/2013/HandwritingBeautification/</link>
  <description><![CDATA[ 




<div id="fig-1" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://orenbochman.github.io/reviews/2013/HandwritingBeautification/fig_1.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: beautification
</figcaption>
</figure>
</div>
<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">TL;DR</h2>
<p>In <span class="citation" data-cites="Zitnick2013Beautification">(Zitnick 2013)</span> the author shows how we can use a model for beautifying handwriting. The problem raised is that there is lots of variation in handwriting for a single individual and come up this a method to reduce this by a clever form of avaraging.</p>
<p>The data is captured from a tablet and thus had a three dimensional structure. Central to this paper is are two ideas:</p>
<ol type="1">
<li>How to effectively average similar tokens to get a suitable mean token.
<ul>
<li>they use a moving window</li>
<li>the sample using a curvature based sampling
<ul>
<li><span class="citation" data-cites="Whitney1937Regular">(Whitney 1937)</span></li>
<li><span class="citation" data-cites="mokhtarian1992theory">(Mokhtarian and Mackworth 1992)</span></li>
<li><span class="citation" data-cites="dudek1997shape">(Dudek and Tsotsos 1997)</span></li>
</ul></li>
<li>they use a fine alignment using
<ul>
<li>affinity matrix</li>
<li>dynamic programming to find the best warping between two sequences.</li>
</ul></li>
<li>they also use a visual similarity metric to make the model more <strong>robust</strong> to graphemes with similar strokes but different shapes.</li>
</ul></li>
<li>How to decide which tokens are similar.</li>
</ol>
<p>Once these are solved, it becomes a matter of clustering tokens by similarity and then averaging the tokens in each cluster to get a mean token.</p>
<p>The mean token are then used to replace the original token in the handwriting data. The authors show that this method can be used to improve the quality of handwriting data.</p>
<p>Q. As time goes by there is more data and the replacements pool towards the cluster avarage. It seems that replacement might be more uniform if the earlier replacements were updated as their cluster avarage drifts…</p>
<p>This naturally leads to a kind of time series.</p>
<p>Perhaps the key idea is how the authors convert the text to a sequence of vectors use a token mean to represent the data. This is a simple idea but</p>
</section>
<section id="the-approach" class="level2">
<h2 class="anchored" data-anchor-id="the-approach">3. The approach</h2>
<p>We represent the stylus’s samples by storing the difference vectors between the stylus positions</p>
<p>i.e.&nbsp;<img src="https://latex.codecogs.com/png.latex?%5CPhi%20=%20%5C%7B%5Cphi_1,%20%5Cldots%20,%20%5Cphi_a%5C%7D"> with</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cphi_i%20=%20%5C%7Bx_i,%20y_i,%20p_i%5C%7D"></p>
<p>where <img src="https://latex.codecogs.com/png.latex?(x_i,%20y_i)"> is the difference in the stylus’s pixel position between samples i − 1 and i.</p>
<p><img src="https://latex.codecogs.com/png.latex?p_i"> is the stylus’s pressure.</p>
</section>
<section id="stroke-resampling" class="level2">
<h2 class="anchored" data-anchor-id="stroke-resampling">3.1 Stroke resampling</h2>
<p>As I understand it data is captured uniformly from a tablet and thus had a three dimensional structure. The authors then to resample the data to more faithfully represent the the curvature that is the building block of strokes within the handwriting.</p>
<div id="fig-2" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://orenbochman.github.io/reviews/2013/HandwritingBeautification/fig_2.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: stroke resampling - uniform v.s. curvature based
</figcaption>
</figure>
</div>
<p>They represent samples taken at regular distance intervals using <img src="https://latex.codecogs.com/png.latex?%5CPhi%5Ed%20=%20%5C%7B%20%5Cphi%5Ed%20_1%20,%20%5Cldots,%20%5Cphi%5Ed_n%20%5C%7D"> where the sample magnitude <img src="https://latex.codecogs.com/png.latex?r_i"> is constant for all samples. c.f. Figure&nbsp;2</p>
<p>Curvature based sampling:</p>
<p>We compute a stroke representation <img src="https://latex.codecogs.com/png.latex?%CE%A6%5Ec%20=%20%5C%7B%5Cphi%5Ec_1,%20%5Cldots%20,%20%5Cphi%5Ec_n%5C%7D"> with the same parameterization as <img src="https://latex.codecogs.com/png.latex?%CE%A6">, i.e.&nbsp;<img src="https://latex.codecogs.com/png.latex?%CF%86%5Ec_i%20=%5C%7Bx_i,%20y_i,%20p_i%20%5C%7D"></p>
<p><span id="eq-stroke"><img src="https://latex.codecogs.com/png.latex?%0Az_i=z_%7Bi-1%7D+min(1,%20%5Cfrac%7B%5Calpha%20%5CDelta_%5Ctheta%20%5Cbeta_j%7D%7B2%5Cpi%7D)%20%5Cqquad%0A%5Ctag%7B1%7D"></span></p>
<p>where:</p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?z_i"> is the point on the curve.</li>
<li><img src="https://latex.codecogs.com/png.latex?z_%7Bi-1%7D"> is the previous point on the curve.</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Calpha"> is the sampling density parameter (minimum value = 24)</li>
<li><img src="https://latex.codecogs.com/png.latex?%5CDelta_%5Ctheta%20%5Cin%20(0,%5Cpi%5D"> is the angle between samples <img src="https://latex.codecogs.com/png.latex?%CF%86_%7Bi%E2%88%921%7D"> and <img src="https://latex.codecogs.com/png.latex?%CF%86_i"></li>
<li><img src="https://latex.codecogs.com/png.latex?r_j"> is the stroke magnitude.</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Cbeta_j%20=%20max(0,%20min(1,%20r_j%20%E2%88%92%20%5Csqrt%7B2%7D))."> is a parameter that controls for discretization of the stylus.</li>
</ul>
<!-- todo try to understand this better find/create an implementation -->
</section>
<section id="refining-strokes" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="refining-strokes">3.2 Refining strokes</h2>
<p>When a user writes they generate a large set of stroke samples, denoted <img src="https://latex.codecogs.com/png.latex?%CE%A6"> (for the rest of the paper we assume a curvature-based sampling and drop the superscript c.) From <img src="https://latex.codecogs.com/png.latex?%CE%A6"> we create overlapping fixed length sequences of stroke samples called tokens c.f. Figure&nbsp;1. Each token contains n stroke samples.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
matrix profiles
</div>
</div>
<div class="callout-body-container callout-body">
<p>Using matrix profiles math behind stumpy might be usefull in making this work faster and better, not sure about real time.</p>
</div>
</div>
<section id="fine-scale-alignment" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="fine-scale-alignment">Fine-scale alignment</h3>

<div class="no-row-height column-margin column-container"><div id="fig-3" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://orenbochman.github.io/reviews/2013/HandwritingBeautification/fig_3.png" class="img-fluid figure-img" width="250">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: fine alignment
</figcaption>
</figure>
</div></div><p>The <strong>match cost</strong> <img src="https://latex.codecogs.com/png.latex?%5Cbeta_%7Bk,l%7D"> is found using a linear combination of three features,</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbeta_%7Bk,l%7D%20=%20%5CDelta_%7B%5Chat%20r%7D%20+%20%5CDelta_%5Ctheta%20+%20%5Cdelta_p%20%5Cqquad%0A"></p>
<p>computed from:</p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?t_%7Bi,k%7D"> and <img src="https://latex.codecogs.com/png.latex?t_%7Bj,l%7D">.</li>
<li><img src="https://latex.codecogs.com/png.latex?%5CDelta%20%5Chat%20r"> is the absolute difference between <img src="https://latex.codecogs.com/png.latex?%5Chat%20r_k"> and <img src="https://latex.codecogs.com/png.latex?%5Chat%20r_l">.</li>
<li><img src="https://latex.codecogs.com/png.latex?%5CDelta_%5Ctheta"> is the absolute angular distance between <img src="https://latex.codecogs.com/png.latex?%CE%B8_k"> and <img src="https://latex.codecogs.com/png.latex?%CE%B8_l">.</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Cdelta_p"> measures if both strokes have consistent visibility. That is, <img src="https://latex.codecogs.com/png.latex?%5Cdelta_p%20=%201"> if <img src="https://latex.codecogs.com/png.latex?p_k%20=%200"> and <img src="https://latex.codecogs.com/png.latex?p_l%20=%200">, or <img src="https://latex.codecogs.com/png.latex?p_k%20%3E%200"> and <img src="https://latex.codecogs.com/png.latex?p_l%20%3E%200">, and <img src="https://latex.codecogs.com/png.latex?%5Cdelta_p%20=%200"> otherwise.</li>
</ul>
</section>
<section id="merging-stroke-sets" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="merging-stroke-sets">Merging stroke sets</h3>
<blockquote class="blockquote">
<p>Once two or more tokens are aligned, we can merge them by averaging the stroke samples.</p>
</blockquote>

<div class="no-row-height column-margin column-container"><div id="fig-4" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://orenbochman.github.io/reviews/2013/HandwritingBeautification/fig_4.png" class="img-fluid figure-img" width="250">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: matches
</figcaption>
</figure>
</div></div></section>
</section>
<section id="the-paper" class="level2">
<h2 class="anchored" data-anchor-id="the-paper">The paper</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="./paper.pdf" class="col-page" width="800" height="1000"></p>
<figcaption>paper</figcaption>
</figure>
</div>
</section>
<section id="see-also" class="level2">
<h2 class="anchored" data-anchor-id="see-also">See also</h2>
<ul>
<li>http://larryzitnick.org/</li>
</ul>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-dudek1997shape" class="csl-entry">
Dudek, Gregory, and John K Tsotsos. 1997. <span>“Shape Representation and Recognition from Multiscale Curvature.”</span> <em>Computer Vision and Image Understanding</em> 68 (2): 170–89.
</div>
<div id="ref-mokhtarian1992theory" class="csl-entry">
Mokhtarian, Farzin, and Alan K Mackworth. 1992. <span>“A Theory of Multiscale, Curvature-Based Shape Representation for Planar Curves.”</span> <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em> 14 (8): 789–805.
</div>
<div id="ref-Whitney1937Regular" class="csl-entry">
Whitney, Hassler. 1937. <span>“On Regular Closed Curves in the Plane.”</span> <em>Compositio Mathematica</em> 4: 276–84. <a href="http://www.numdam.org/item/CM_1937__4__276_0/">http://www.numdam.org/item/CM_1937__4__276_0/</a>.
</div>
<div id="ref-Zitnick2013Beautification" class="csl-entry">
Zitnick, C. Lawrence. 2013. <span>“Handwriting Beautification Using Token Means.”</span> <em>ACM Trans. Graph.</em> 32 (4). <a href="https://doi.org/10.1145/2461912.2461985">https://doi.org/10.1145/2461912.2461985</a>.
</div>
</div></section></div> ]]></description>
  <guid>https://orenbochman.github.io/reviews/2013/HandwritingBeautification/</guid>
  <pubDate>Thu, 26 Sep 2024 14:07:51 GMT</pubDate>
</item>
<item>
  <title>NIN — Network in Network</title>
  <link>https://orenbochman.github.io/reviews/2013/NIN/</link>
  <description><![CDATA[ 




<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">TL;DR</h2>
<p>In <span class="citation" data-cites="lin2014networknetwork">(Lin, Chen, and Yan 2014)</span> the authors, Lin, Min, Qiang Chen, and Shuicheng Yan, of this paper titled “Network in Network” paper came up with a way of connencting somee ideas on improving CNNs which had been mostly getting bigger <img src="https://latex.codecogs.com/png.latex?(VGG%20%3E%20AlexNet%20%3E%20LeNet)"> . They replaced traditional linear filters in convolutional neural networks (CNNs) with multilayer perceptrons (MLPs) to enhance local feature abstraction. <mark>This new architecture, called NIN, also introduces <strong>global average pooling</strong> in place of <em>fully connected layers</em> thus reducing overfitting, improving model interpretability and more significantly reducing the size of the network.</mark></p>
<p>It took a while for the idea to catch on, but in computer vision, most of the parameters are in the fully connected layers, and the NIN architecture enables us to to reduce the number of parameters in the fully connected layers thereby <mark>breaking the curse of dimensionality in CNN</mark>. Once people realized this the NIN architecture became more widely adopted and influenced the development of more sophisticated deep learning architectures like the <mark>Inception architecture</mark> and further refined into the Resnet architecture</p>
<p>The NIN architecture has a significant impact on the design of CNNs by demonstrating that local feature abstraction can be enhanced with MLPs, leading to better performance with fewer parameters. Global average pooling, which replaces fully connected layers, makes the architecture more robust to overfitting and spatial translations, making it a powerful tool for image classification tasks. This combination of techniques has influenced the development of more sophisticated deep learning architectures, particularly in domains where model interpretability and reduced overfitting are critical.</p>
</section>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<blockquote class="blockquote">
<p>We propose a novel deep network structure called “Network In Network” (NIN) to enhance model discriminability for local patches within the receptive field. The conventional convolutional layer uses linear filters followed by a nonlinear activation function to scan the input. Instead, we build micro neural networks with more complex structures to abstract the data within the receptive field. We instantiate the micro neural network with a multilayer perceptron, which is a potent function approximator. The feature maps are obtained by sliding the micro networks over the input in a similar manner as CNN; they are then fed into the next layer. Deep NIN can be implemented by stacking multiple of the above described structure. With enhanced local modeling via the micro network, we are able to utilize global average pooling over feature maps in the classification layer, which is easier to interpret and less prone to overfitting than traditional fully connected layers. We demonstrated the state-of-the-art classification performances with NIN on CIFAR-10 and CIFAR-100, and reasonable performances on SVHN and MNIST datasets.</p>
<p>– <span class="citation" data-cites="lin2014networknetwork">(Lin, Chen, and Yan 2014)</span></p>
</blockquote>
</section>
<section id="review" class="level2">
<h2 class="anchored" data-anchor-id="review">Review</h2>
<p>In <span class="citation" data-cites="lin2014networknetwork">(Lin, Chen, and Yan 2014)</span> the authors introduced a novel deep learning architecture that aims to improve the abstraction capabilities of convolutional neural networks (CNNs) by incorporating multilayer perceptrons (MLPs) into the convolution layers. This approach, termed “Network in Network,” replaces the conventional linear filters used in CNNs with small neural networks, allowing for better local feature modeling. The NIN architecture also introduces global average pooling as a substitute for traditional fully connected layers to reduce overfitting and improve the interpretability of the model.</p>
</section>
<section id="key-contributions" class="level2">
<h2 class="anchored" data-anchor-id="key-contributions">Key Contributions</h2>
<p>The NIN paper makes several key contributions to the deep learning landscape:</p>
<ol type="1">
<li><p><strong>Mlpconv Layer</strong>: Instead of using traditional linear filters, NIN proposes the use of multilayer perceptrons (MLPs) within the convolutional layers (termed mlpconv layers). These layers act as universal function approximators, capable of modeling more complex representations within local receptive fields. This structure allows for better abstraction of non-linear latent concepts, overcoming the limitations of traditional linear filters in CNNs.</p>
<p><img src="https://orenbochman.github.io/reviews/2013/NIN/fig1.png" class="img-fluid"> <img src="https://orenbochman.github.io/reviews/2013/NIN/fig2.png" class="img-fluid"></p></li>
<li><p><strong>Global Average Pooling</strong>: NIN introduces global average pooling as an alternative to fully connected layers in the final classification stage. This technique computes the spatial average of each feature map, feeding the result directly into a softmax layer for classification. By avoiding fully connected layers, the model becomes less prone to overfitting, thus improving generalization performance. Furthermore, this method provides more interpretable results by establishing a direct correspondence between feature maps and class labels.</p></li>
<li><p><strong>State-of-the-Art Performance</strong>: The authors demonstrate that NIN achieves state-of-the-art performance on several benchmark datasets, including CIFAR-10, CIFAR-100, and SVHN, without the need for extensive data augmentation or model ensembling. The architecture consistently outperforms other methods, such as maxout networks and CNNs with dropout regularization, especially in terms of classification accuracy.</p></li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://orenbochman.github.io/reviews/2013/NIN/results.png" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>Cifar-10 error rates</figcaption>
</figure>
</div>
</section>
<section id="strengths" class="level2">
<h2 class="anchored" data-anchor-id="strengths">Strengths</h2>
<ul>
<li><p><strong>Innovative Architecture</strong>: The introduction of MLPs into convolutional layers is a simple yet effective modification that significantly enhances the representational power of the model. This makes NIN a powerful alternative to traditional CNNs, especially for tasks that require fine-grained feature extraction and abstraction.</p></li>
<li><p><strong>Reduced Overfitting</strong>: The use of global average pooling not only replaces the computationally expensive fully connected layers but also serves as a built-in regularizer, reducing the need for additional techniques like dropout. This structural regularization helps to prevent overfitting, particularly on datasets with limited training examples, such as CIFAR-100.</p></li>
<li><p><strong>Better Interpretability</strong>: The global average pooling layer allows for easier interpretation of the learned feature maps, as each map is directly associated with a class. This increases the transparency of the network’s the decision-making process compared to conventional CNNs.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://orenbochman.github.io/reviews/2013/NIN/fig4.png" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>Visulization</figcaption>
</figure>
</div>
</section>
<section id="limitations" class="level2">
<h2 class="anchored" data-anchor-id="limitations">Limitations</h2>
<ul>
<li><p><strong>Limited Novelty in Pooling</strong>: While global average pooling is effective, the concept is not entirely new, and its novelty is limited. Previous works have proposed similar techniques for specific tasks. However NIN certainly demonstrates the concepts efficacy.</p></li>
<li><p><strong>Scalability</strong>: The paper focuses primarily on relatively small datasets like CIFAR-10, CIFAR-100, SVHN, and MNIST. While NIN excels in these scenarios, it would be interesting to see how the architecture performs on larger, more complex datasets such as ImageNet, where the size and variety of the data might pose additional challenges.</p></li>
<li><p><strong>Lack of Depth Exploration</strong>: While the architecture consists of three stacked mlpconv layers, the paper does not deeply explore the impact of adding more layers or experimenting with deeper NIN networks. Such exploration could provide insight into how well the architecture scales with increased model depth.</p></li>
</ul>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>NIN architecture is an elegant and effective solution to improving feature abstraction and reducing overfitting in CNNs. By embedding MLPs within convolutional layers and using global average pooling for classification, NIN achieves state-of-the-art performance across a variety of tasks. NIN presented a strong case for the importance of local feature modeling and interpretable classification mechanisms in modern deep learning.</p>
</section>
<section id="the-paper" class="level2">
<h2 class="anchored" data-anchor-id="the-paper">The paper</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="./paper.pdf" class="col-page" width="800" height="1000"></p>
<figcaption>paper</figcaption>
</figure>
</div>
<ul>
<li><a href="https://www.youtube.com/watch?v=QfNvhP6k6ZM">Alex Smola Course Video on NIN</a>, his <a href="https://c.d2l.ai/stanford-cs329p/">course</a> and <a href="https://www.d2l.ai/">book</a></li>
</ul>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-lin2014networknetwork" class="csl-entry">
Lin, Min, Qiang Chen, and Shuicheng Yan. 2014. <span>“Network in Network.”</span> <a href="https://arxiv.org/abs/1312.4400">https://arxiv.org/abs/1312.4400</a>.
</div>
</div></section></div> ]]></description>
  <guid>https://orenbochman.github.io/reviews/2013/NIN/</guid>
  <pubDate>Thu, 26 Sep 2024 14:07:51 GMT</pubDate>
</item>
<item>
  <title>Dropout: A Simple Way to Prevent Neural Networks from Overfitting</title>
  <link>https://orenbochman.github.io/reviews/2014/Dropout/</link>
  <description><![CDATA[ 




<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">TL;DR</h2>
<p>In <span class="citation" data-cites="JMLR:v15:srivastava14a">(Srivastava et al. 2014)</span> the authors, present a novel regularization technique for deep neural networks called “dropout.” The key idea behind dropout is to randomly drop units (along with their connections) from the neural network during training. This prevents units from co-adapting too much and significantly reduces overfitting. The authors show that dropout improves the performance of neural networks on supervised learning tasks in vision, speech recognition, document classification, and computational biology, obtaining state-of-the-art results on many benchmark data sets.</p>
<p>The technique had been in use in some earlier works, but this paper popularized it and showed its effectiveness on a wide range of tasks. The idea behind drop out is pretty simple and people have since come up with many variations of it. It has become a standard technique in the deep learning toolbox.</p>
</section>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<blockquote class="blockquote">
<p>Deep neural nets with a large number of parameters are very powerful machine learning systems. However, overfitting is a serious problem in such networks. Large networks are also slow to use, making it difficult to deal with overfitting by combining the predictions of many different large neural nets at test time. Dropout is a technique for addressing this problem. The key idea is to randomly drop units (along with their connections) from the neural network during training. This prevents units from co-adapting too much. During training, dropout samples from an exponential number of different thinned networks. At test time, it is easy to approximate the effect of averaging the predictions of all these thinned networks by simply using a single unthinned network that has smaller weights. This significantly reduces overfitting and gives major improvements over other regularization methods. We show that dropout improves the performance of neural networks on supervised learning tasks in vision, speech recognition, document classification and computational biology, obtaining state-of-the-art results on many benchmark data sets.</p>
<p>– <span class="citation" data-cites="JMLR:v15:srivastava14a">(Srivastava et al. 2014)</span></p>
</blockquote>
</section>
<section id="review" class="level2">
<h2 class="anchored" data-anchor-id="review">Review</h2>
<p>In <span class="citation" data-cites="JMLR:v15:srivastava14a">(Srivastava et al. 2014)</span> the authors presents a regularization technique called Dropout, aimed at addressing the critical problem of overfitting in deep neural networks (DNNs). Dropout randomly drops units (neurons) during training to prevent co-adaptation of units, which can lead to overfitting. This novel technique is demonstrated to significantly improve the performance of neural networks across a wide range of tasks, including computer vision, speech recognition, and natural language processing.</p>
</section>
<section id="core-idea" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="core-idea">Core Idea</h2>

<div class="no-row-height column-margin column-container"><div class="">
<p><img src="https://orenbochman.github.io/reviews/2014/Dropout/fig1.png" class="img-fluid" width="640"></p>
</div></div><p>Dropout works by randomly removing units from the network during each training iteration. This prevents the network from becoming overly reliant on specific units, thus reducing overfitting. During testing, all units are used, but their weights are scaled to account for the dropout during training. This approximates the averaging of an exponential number of thinned networks that would otherwise be computationally infeasible.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p><img src="https://orenbochman.github.io/reviews/2014/Dropout/fig2.png" class="img-fluid" width="640"></p>
</div></div></section>
<section id="methodology-and-theoretical-motivation" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="methodology-and-theoretical-motivation">Methodology and Theoretical Motivation</h2>
<p>Dropout’s theoretical foundation stems from biological principles, specifically the idea of genetic robustness in sexual reproduction. In the analogy, a network’s hidden units act like genes that must learn to function independently of one another, preventing complex co-adaptations that may not generalize well to unseen data. The stochastic nature of dropout introduces noise during training, which acts as a form of model averaging and regularization.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p><img src="https://orenbochman.github.io/reviews/2014/Dropout/fig3.png" class="img-fluid" width="640"></p>
</div></div></section>
<section id="key-contributions" class="level2">
<h2 class="anchored" data-anchor-id="key-contributions">Key Contributions</h2>
<ul>
<li>Model Averaging: Dropout enables the training of many subnetworks (thinned networks) simultaneously, which leads to a more robust model.</li>
<li>Regularization Effect: Dropout reduces overfitting more effectively than other methods such as L1/L2 regularization or early stopping.</li>
<li>Efficiency: Dropout provides a computationally feasible approximation of model averaging by scaling weights at test time, as opposed to maintaining an ensemble of networks.</li>
</ul>
</section>
<section id="experimental-results" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="experimental-results">Experimental Results</h2>
<p>The authors demonstrate the efficacy of dropout across several benchmark datasets:</p>

<div class="no-row-height column-margin column-container"><div class="">
<p><img src="https://orenbochman.github.io/reviews/2014/Dropout/fig4.png" class="img-fluid" width="640"></p>
</div></div><ul>
<li>MNIST: Error rates are reduced from 1.60% (standard neural network) to 0.95% using dropout with additional max-norm regularization.</li>
<li>CIFAR-10 and CIFAR-100: Dropout networks outperform previous methods, with an error reduction to 12.6% on CIFAR-10 and 37.2% on CIFAR-100.</li>
<li>TIMIT (Speech Data): Dropout reduces the phone error rate from 23.4% to 21.8%, showing significant improvements over non-dropout models.</li>
<li>ImageNet: Dropout helps achieve state-of-the-art results in image classification tasks, significantly lowering the top-5 error rate.</li>
</ul>

<div class="no-row-height column-margin column-container"><div class="">
<p><img src="https://orenbochman.github.io/reviews/2014/Dropout/fig5.png" class="img-fluid" width="640"></p>
</div></div></section>
<section id="advantages-of-dropout" class="level2">
<h2 class="anchored" data-anchor-id="advantages-of-dropout">Advantages of Dropout</h2>
<ul>
<li>Generality: Dropout works across a variety of architectures, including fully connected, convolutional, and recurrent neural networks.</li>
<li>Ease of Use: Dropout is simple to implement, requiring only one additional hyperparameter (the dropout rate, typically 0.5 for hidden layers).</li>
<li>Compatibility with Other Methods: Dropout can be combined with techniques like unsupervised pretraining, max-norm regularization, and momentum, further improving model performance.</li>
</ul>
</section>
<section id="limitations" class="level2">
<h2 class="anchored" data-anchor-id="limitations">Limitations</h2>
<ul>
<li>Increased Training Time: Dropout can significantly slow down training, typically requiring 2-3 times more iterations to converge.</li>
<li>Tuning of Hyperparameters: While simple, the dropout rate must be carefully selected, and higher learning rates and momentum are generally required for optimal performance.</li>
<li>Application-Specific Benefits: Although dropout improves performance in vision and speech recognition tasks, the improvements in certain domains like text classification (e.g., Reuters RCV1 dataset) are less pronounced. <sup>1</sup></li>
</ul>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>The paper introduces dropout as a powerful and simple regularization technique that significantly reduces overfitting in deep neural networks. Dropout provides a computationally efficient method to approximate model averaging and works across a range of architectures and tasks, achieving state-of-the-art results on several benchmarks. However, it comes at the cost of increased training time, and some tuning is required for optimal performance.</p>
<p>Dropout represents a substantial advancement in neural network training, and its adoption has since become widespread in the deep learning community.</p>
</section>
<section id="the-paper" class="level2">
<h2 class="anchored" data-anchor-id="the-paper">The paper</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="./paper.pdf" class="col-page" style="width:8.5in;height:11in"></p>
<figcaption>paper</figcaption>
</figure>
</div>



</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-JMLR:v15:srivastava14a" class="csl-entry">
Srivastava, Nitish, Geoffrey Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. 2014. <span>“Dropout: A Simple Way to Prevent Neural Networks from Overfitting.”</span> <em>Journal of Machine Learning Research</em> 15 (56): 1929–58. <a href="http://jmlr.org/papers/v15/srivastava14a.html">http://jmlr.org/papers/v15/srivastava14a.html</a>.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>I think this is because if we drop a few words from a sentence a reader can often guess them from the context and redundancy in natural languages.↩︎</p></li>
</ol>
</section></div> ]]></description>
  <guid>https://orenbochman.github.io/reviews/2014/Dropout/</guid>
  <pubDate>Thu, 26 Sep 2024 14:07:51 GMT</pubDate>
</item>
<item>
  <title>Learning a manifold of fonts</title>
  <link>https://orenbochman.github.io/reviews/2014/learning-font-manifold/</link>
  <description><![CDATA[ 




<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">TL;DR</h2>
<p>This paper presents a method for learning a manifold of fonts. The manifold is a generative model that can be used to interpolate between existing fonts and generate new ones. The authors show that the manifold can be used to edit fonts in a way that preserves the overall style of the font.</p>
</section>
<section id="questions" class="level2">
<h2 class="anchored" data-anchor-id="questions">Questions</h2>
<ul>
<li>Can we make aspects of the manifold interpretable?</li>
<li>Can we make the specific aspects of the manifold parametrize?
<ul>
<li>weights</li>
<li>serif style (slab, old style, transitional, didone, hairline, decorative, wedge etc)</li>
</ul></li>
<li>has there been follow up work on this?
<ul>
<li>handling outliers better</li>
<li>finding and matching motifs</li>
</ul></li>
<li>can we use this to generate new fonts?</li>
<li>is the code available?</li>
<li>Can I think of a generative model with low and high level features?
<ul>
<li>low level features are the points, lines, splines, strokes, glyph topology.</li>
<li>mid level features are the combine geometry and style like cross bars, stems risers, descenders,<br>
</li>
<li>high level features are typographic motifs, serif style, and weight, and thier parameters.</li>
</ul></li>
<li>Can we use a parametric prior to cluster glyphs before constructing the manifold?</li>
<li>Can we indeed use priors for different levels of the generative model, thier parameters, and certain constraints?</li>
<li>Can we detect outliers glyphs and map them to</li>
<li>Can we learn priors for hinting and other typographic features?</li>
</ul>
</section>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<blockquote class="blockquote">
<p>The design and manipulation of typefaces and fonts is an area requiring substantial expertise; it can take many years of study to become a proficient typographer. At the same time, the use of typefaces is ubiquitous; there are many users who, while not experts, would like to be more involved in tweaking or changing existing fonts without suffering the learning curve of professional typography packages. Given the wealth of fonts that are available today, we would like to exploit the expertise used to produce these fonts, and to enable everyday users to create, explore, and edit fonts. To this end, we build a generative manifold of standard fonts. Every location on the manifold corresponds to a unique and novel typeface, and is obtained by learning a non-linear mapping that intelligently interpolates and extrapolates existing fonts. Using the manifold, we can smoothly interpolate and move between existing fonts. We can also use the manifold as a constraint that makes a variety of new applications possible. For instance, when editing a single character, we can update all the other glyphs in a font simultaneously to keep them compatible with our changes.</p>
<p>– <span class="citation" data-cites="Campbell2014ManifoldFonts">(Campbell and Kautz 2014)</span></p>
</blockquote>
<ul>
<li>There is an a good bibliography.</li>
<li>There is an excellent presentation</li>
<li>There is a great demo of the system in action online.</li>
<li>The computational load for this work isn’t as bad as many other deep learning tasks.</li>
<li>Can we rethink this via a skeleton path tracing curve with a pen on and off and then each segment is expanded to an outline and mapped via a poly line? -c.f. <span class="citation" data-cites="suveeranont2010example">(Suveeranont and Igarashi 2010)</span> takes a single example +</li>
<li>can abstract the line to a grammar of elements see <span class="citation" data-cites="shamir1998Feature">(<strong>shamir1998Feature?</strong>)</span>
<ul>
<li>key point</li>
<li>topology</li>
<li>branching and merging points</li>
</ul></li>
<li>Can we use a normalizing flow to map each glyph to a more basic shape like a line segment or a circle?</li>
</ul>
</section>
<section id="the-problem" class="level2">
<h2 class="anchored" data-anchor-id="the-problem">The problem</h2>
<ul>
<li>Designing and editing fonts requires mastery of the rules of typography and the use of professional typography software packages and is a highly labour intensive task. How can we use unsupervised learning simplify font design?</li>
</ul>
</section>
<section id="prior-work" class="level2">
<h2 class="anchored" data-anchor-id="prior-work">Prior work</h2>
<ul>
<li>Metafont by Donald Knuth</li>
<li>Multiple Masters by Adobe</li>
</ul>
</section>
<section id="main-ideas" class="level2">
<h2 class="anchored" data-anchor-id="main-ideas">Main ideas</h2>
<ul>
<li><p>all closed 2d shapes consist in a big manifold</p></li>
<li><p>a polyline<sup>1</sup> representation of a font is a much smaller manifold</p></li>
<li><p>used a <strong>Gaussian Process Latent Variable</strong> Model (GP-LVM) to map high-dimensional font data into a lower-dimensional manifold that allows smooth interpolation and extrapolation</p></li>
<li><p>Err what are GP-LVMs? &gt; The GP-LVM is a nonlinear dimensionality reduction technique that uses Gaussian Processes to learn a low-dimensional latent space representation of high-dimensional data. It provides a probabilistic framework, meaning it doesn’t just give a point estimate for the latent representation, but also an uncertainty measure on the mappings. &gt; Unlike PCA which finds a linear mapping from high-dimensional to low-dimensional space, GP-LVM finds a nonlinear mapping due to the flexibility of Gaussian Processes. This makes GP-LVM much more powerful for capturing complex data relationships.</p>
<ul>
<li>see <a href="https://www.cs.toronto.edu/~duvenaud/cookbook/">The Kernel Cookbook: Advice on Covariance functions fir GPML</a></li>
<li><a href="lawrence2003gaussian">Gaussian Process Latent Variable Models for Visualisation of High Dimensional Data</a> -<a href="https://www.cs.toronto.edu/~duvenaud/thesis.pdf">Automatic Model Construction with Gaussian Processes</a> c.f. <span class="citation" data-cites="duvenaud2014automatic">(Duvenaud 2014)</span></li>
<li>A tensorfow implementation of a GP-LVM is available <a href="https://www.tensorflow.org/probability/examples/Gaussian_Process_Latent_Variable_Model">here</a></li>
</ul></li>
<li><p>a energy model specifically designed to provide dense correspondences between character outlines across multiple fonts.</p></li>
</ul>
<!-- add a mermaid polyline mind map -->
<ul>
<li>poly line
<ul>
<li><a href="https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm">Ramer–Douglas–Peucker_algorithm</a> simplification of a polyline by removing points</li>
<li>non-parametric version</li>
<li><a href="https://en.wikipedia.org/wiki/Visvalingam%E2%80%93Whyatt_algorithm">Visvalingam–Whyatt algorithm</a></li>
</ul></li>
<li>bezier curve</li>
</ul>
</section>
<section id="the-magic" class="level2">
<h2 class="anchored" data-anchor-id="the-magic">The magic</h2>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>The design of fonts is typically complex and requires significant expertise. However, with access to many existing fonts, a generative model can help everyday users create, explore, and manipulate fonts by learning a low-dimensional manifold. The key contribution of this paper is a probabilistic font manifold that interpolates and extrapolates between existing fonts to generate new typefaces.</p>
</section>
<section id="font-manifold" class="level2">
<h2 class="anchored" data-anchor-id="font-manifold">Font Manifold</h2>
<p>The paper presents a <strong>Gaussian Process Latent Variable Model (GP-LVM)</strong> to map high-dimensional font data into a lower-dimensional manifold that allows smooth interpolation and extrapolation.</p>
<p>Given an input space <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BX%7D"> and output space <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BY%7D">, the GP models the probability distribution of outputs:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AP(%5Cmathbf%7BY%7D%7C%5Cmathbf%7BX%7D)%20=%20%5Cmathcal%7BN%7D(%5Cmathbf%7BY%7D%20%7C%20%5Cmathbf%7BM%7D(%5Cmathbf%7BX%7D),%20%5Cmathbf%7BC%7D(%5Cmathbf%7BX%7D,%20%5Cmathbf%7BX%7D%7C%5Ctheta))%0A"></p>
<p>Where <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BC%7D"> is a covariance function dependent on hyperparameters <img src="https://latex.codecogs.com/png.latex?%5Ctheta">. The manifold is trained using existing fonts, and the GP-LVM finds the optimal mapping that generates fonts by maximizing the likelihood:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AX%5E*,%20%5Ctheta%5E*%20=%20%5Carg%5Cmax_%7BX,%20%5Ctheta%7D%20%5Clog%20P(%5Cmathbf%7BY%7D%7C%20%5Cmathbf%7BX%7D,%20%5Ctheta)%0A"></p>
</section>
<section id="character-matching" class="level2">
<h2 class="anchored" data-anchor-id="character-matching">Character Matching</h2>
<p>To create a font manifold, character outlines are matched across different fonts. This involves optimizing an energy model that encourages consistent curvature and normal variations. The energy model is:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AE(t)%20=%20E_%7B%5Ckappa%7D(t)%20+%20%5Clambda_%7B%5Ctext%7Bel%7D%7D%20E_%7B%5Ctext%7Bel%7D%7D(t)%20+%20%5Clambda_%7B%5Ceta%7D%20E_%7B%5Ceta%7D%5E%7B%5Ctext%7Bup%7D%7D(t)%20+%20%5Clambda_%7B%5Ceta%7D%20E_%7B%5Ceta%7D%5E%7B%5Ctext%7Bdown%7D%7D(t)%0A"></p>
<p>Where <img src="https://latex.codecogs.com/png.latex?E_%7B%5Ckappa%7D"> represents curvature variation and <img src="https://latex.codecogs.com/png.latex?E_%7B%5Ceta%7D"> enforces normal matching.</p>
<section id="elastic-regularization" class="level3">
<h3 class="anchored" data-anchor-id="elastic-regularization">Elastic Regularization</h3>
<p>To ensure smooth correspondence between characters, an elastic regularization term prevents the optimization from collapsing the characters into regions of low curvature:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AE_%7B%5Ctext%7Bel%7D%7D(t)%20=%20%5Csum_%7Bi=1%7D%5E%7BN%7D%20%5Csum_%7Bm=1%7D%5E%7BM%7D%20%5Cleft(t_%7B(i+1)%20%5Cmod%20N,%20m%7D%20-%20t_%7Bi,%20m%7D%20-%20%5Cfrac%7B1%7D%7BN%7D%5Cright)%5E2%0A"></p>
</section>
</section>
<section id="generating-new-fonts" class="level2">
<h2 class="anchored" data-anchor-id="generating-new-fonts">Generating New Fonts</h2>
<p>Once the manifold is trained, a new font can be generated by projecting a new location <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bx%7D"> in the latent space back to the high-dimensional font space:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbf%7By%7D%20=%20%5Cmathbf%7BC%7D(%5Cmathbf%7Bx%7D,%20%5Cmathbf%7BX%5E*%7D%7C%5Ctheta%5E*)%20%5Cleft%5B%5Cmathbf%7BC%7D(%5Cmathbf%7BX%5E*%7D,%20%5Cmathbf%7BX%5E*%7D%7C%5Ctheta%5E*)%5Cright%5D%5E%7B-1%7D%20%5Cmathbf%7BY%7D%0A"></p>
<p>This approach allows users to explore the manifold and discover novel fonts, as shown in the example of interpolation between serif and sans-serif regions.</p>
<p><img src="https://orenbochman.github.io/reviews/2014/learning-font-manifold/fig_1.png" class="img-fluid"></p>
</section>
<section id="applications" class="level2">
<h2 class="anchored" data-anchor-id="applications">Applications</h2>
<p>Several applications arise from this framework:</p>
<ul>
<li><strong>Interactive Editing</strong>: Users can edit one character, and the changes propagate to the entire font family.</li>
<li><strong>Smooth Interpolation</strong>: New fonts are created by interpolating between two existing fonts.</li>
</ul>
<p><img src="https://orenbochman.github.io/reviews/2014/learning-font-manifold/fig_2.png" class="img-fluid"></p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>The paper introduces a novel, unsupervised learning method for generating fonts, offering smooth interpolation and the ability for users to edit fonts interactively without formal typographic knowledge.</p>
</section>
<section id="the-paper" class="level2">
<h2 class="anchored" data-anchor-id="the-paper">The paper</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="./paper.pdf" class="col-page" style="width:8.5in;height:11in"></p>
<figcaption>paper</figcaption>
</figure>
</div>



</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-Campbell2014ManifoldFonts" class="csl-entry">
Campbell, Neill D. F., and Jan Kautz. 2014. <span>“Learning a Manifold of Fonts.”</span> <em>ACM Trans. Graph.</em> 33 (4). <a href="https://doi.org/10.1145/2601097.2601212">https://doi.org/10.1145/2601097.2601212</a>.
</div>
<div id="ref-duvenaud2014automatic" class="csl-entry">
Duvenaud, David. 2014. <span>“Automatic Model Construction with Gaussian Processes.”</span> PhD thesis.
</div>
<div id="ref-suveeranont2010example" class="csl-entry">
Suveeranont, Rapee, and Takeo Igarashi. 2010. <span>“Example-Based Automatic Font Generation.”</span> In <em>International Symposium on Smart Graphics</em>, 127–38. Springer.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>what is this?↩︎</p></li>
</ol>
</section></div> ]]></description>
  <category>paper-review</category>
  <category>neural-networks</category>
  <category>typography</category>
  <category>manifold-learning</category>
  <guid>https://orenbochman.github.io/reviews/2014/learning-font-manifold/</guid>
  <pubDate>Thu, 26 Sep 2024 14:07:51 GMT</pubDate>
</item>
<item>
  <title>ViT — An Image is worth 16x16 words: Transformers for Image Recognition at scale</title>
  <link>https://orenbochman.github.io/reviews/2020/ViT/</link>
  <description><![CDATA[ 




<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<blockquote class="blockquote">
<p>While the Transformer architecture has become the de-facto standard for natural language processing tasks, its applications to computer vision remain limited. In vision, attention is either applied in conjunction with convolutional networks, or used to replace certain components of convolutional networks while keeping their overall structure in place. We show that this reliance on CNNs is not necessary and a pure transformer applied directly to sequences of image patches can perform very well on image classification tasks. When pre-trained on large amounts of data and transferred to multiple mid-sized or small image recognition benchmarks (ImageNet, CIFAR-100, VTAB, etc.), Vision Transformer (ViT) attains excellent results compared to state-of-the-art convolutional networks while requiring substantially fewer computational resources to train.</p>
<p>— <span class="citation" data-cites="DBLP:journals/corr/abs-2010-11929">(Dosovitskiy et al. 2020)</span></p>
</blockquote>
</section>
<section id="see-also" class="level2">
<h2 class="anchored" data-anchor-id="see-also">See also</h2>
<ul>
<li><a href="https://arxiv.org/abs/2010.11929">Paper</a></li>
<li><a href="https://github.com/google-research/vision_transformer">Code - Vision Transformer and MLP-Mixer Architectures</a></li>
<li><a href="https://iclr.cc/virtual/2021/oral/3458">ICLR - Video &amp; Slides</a></li>
<li><a href="https://research.google/pubs/an-image-is-worth-16x16-words-transformers-for-image-recognition-at-scale/">Blog post</a></li>
<li>Third-party reviews:
<ul>
<li><a href="https://www.youtube.com/@YannicKilcher">Review by Yannic Kilcher</a></li>
<li><a href="https://www.youtube.com/watch?v=aD-D8-D-ZyY">Sahil Khose</a></li>
<li><a href="https://www.youtube.com/watch?v=DVoHvmww2lQ">AI Coffee Break with Letitia</a></li>
<li><a href="https://medium.com/@ManishChablani/vision-transformer-vit-an-image-is-worth-16x16-words-transformers-for-image-recognition-at-a4bd5c6f17a7">Manish Chablani — Review</a></li>
</ul></li>
</ul>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-DBLP:journals/corr/abs-2010-11929" class="csl-entry">
Dosovitskiy, Alexey, Lucas Beyer, Alexander Kolesnikov, Dirk Weissenborn, Xiaohua Zhai, Thomas Unterthiner, Mostafa Dehghani, et al. 2020. <span>“An Image Is Worth 16x16 Words: Transformers for Image Recognition at Scale.”</span> <em>CoRR</em> abs/2010.11929. <a href="https://arxiv.org/abs/2010.11929">https://arxiv.org/abs/2010.11929</a>.
</div>
</div></section></div> ]]></description>
  <guid>https://orenbochman.github.io/reviews/2020/ViT/</guid>
  <pubDate>Thu, 26 Sep 2024 14:07:51 GMT</pubDate>
  <media:content url="https://orenbochman.github.io/reviews/2020/ViT/cover.jpg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>FontCLIP: A Semantic Typography Visual-Language Model for Multilingual Font Applications</title>
  <link>https://orenbochman.github.io/reviews/2024/FontCLIP/</link>
  <description><![CDATA[ 




<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<blockquote class="blockquote">
<p>Acquiring the desired font for various design tasks can be challenging and requires professional typographic knowledge. While previous font retrieval or generation works have alleviated some of these difficulties, they often lack support for multiple languages and semantic attributes beyond the training data domains. To solve this problem, we present FontCLIP: a model that connects the semantic understanding of a large vision-language model with typographical knowledge. We integrate typography-specific knowledge into the comprehensive vision-language knowledge of a pretrained CLIP model through a novel finetuning approach. We propose to use a compound descriptive prompt that encapsulates adaptively sampled attributes from a font attribute dataset focusing on Roman alphabet characters. FontCLIP’s semantic typographic latent space demonstrates two unprecedented generalization abilities. First, FontCLIP generalizes to different languages including Chinese, Japanese, and Korean (CJK), capturing the typographical features of fonts across different languages, even though it was only finetuned using fonts of Roman characters. Second, FontCLIP can recognize the semantic attributes that are not presented in the training data. FontCLIP’s dual-modality and generalization abilities enable multilingual and cross-lingual font retrieval and letter shape optimization, reducing the burden of obtaining desired fonts.</p>
<p>— <span class="citation" data-cites="Tatsukawa2024Fontclip">(Tatsukawa et al. 2024)</span></p>
</blockquote>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-Tatsukawa2024Fontclip" class="csl-entry">
Tatsukawa, Yuki, I‐Chao Shen, Anran Qi, Yuki Koyama, Takeo Igarashi, and Ariel Shamir. 2024. <span>“FontCLIP: A Semantic Typography Visual‐language Model for Multilingual Font Applications.”</span> <em>Computer Graphics Forum</em> 43 (2). <a href="https://doi.org/10.1111/cgf.15043">https://doi.org/10.1111/cgf.15043</a>.
</div>
</div></section></div> ]]></description>
  <category>paper-review</category>
  <category>typography</category>
  <category>vision-language-model</category>
  <category>CLIP</category>
  <category>multilingual</category>
  <category>cross-lingual</category>
  <category>semantic attributes</category>
  <guid>https://orenbochman.github.io/reviews/2024/FontCLIP/</guid>
  <pubDate>Thu, 26 Sep 2024 14:07:51 GMT</pubDate>
  <media:content url="https://orenbochman.github.io/reviews/2024/FontCLIP/cover.jpg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>LLM2Vec: Large Language Models Are Secretly Powerful Text Encoders</title>
  <link>https://orenbochman.github.io/reviews/2024/LLM2Vec/</link>
  <description><![CDATA[ 




<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">TL;DR</h2>
<p>In <span class="citation" data-cites="behnamghader2024llm2veclargelanguagemodels">(BehnamGhader et al. 2024)</span> the authors consider using LLMs which are mostly decoder only transformers as text encoders. This allows them to use the LLMs for NLP tasks like chunking, NEW and POS. Recall that T5 <span class="citation" data-cites="raffel2020exploring">(Raffel et al. 2020)</span> can do this is a decoder encode model.</p>
</section>
<section id="tricks" class="level2 callout-info">
<h2 class="anchored" data-anchor-id="tricks">Tricks</h2>
<ol type="1">
<li>enabling bidirectional attention,</li>
<li>masked next token prediction, and</li>
<li>unsupervised contrastive learning.</li>
</ol>
</section>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<blockquote class="blockquote">
<p>Large decoder-only language models (LLMs) are the state-of-the-art models on most of today’s NLP tasks and benchmarks. Yet, the community is only slowly adopting these models for text embedding tasks, which require rich contextualized representations. In this work, we introduce LLM2Vec, a simple unsupervised approach that can transform any decoder-only LLM into a strong text encoder. LLM2Vec consists of three simple steps: 1) enabling bidirectional attention, 2) masked next token prediction, and 3) unsupervised contrastive learning. We demonstrate the effectiveness of LLM2Vec by applying it to 4 popular LLMs ranging from 1.3B to 8B parameters and evaluate the transformed models on English word- and sequence-level tasks. We outperform encoder-only models by a large margin on word-level tasks and reach a new unsupervised state-of-the-art performance on the Massive Text Embeddings Benchmark (MTEB). Moreover, when combining LLM2Vec with supervised contrastive learning, we achieve state-of-the-art performance on MTEB among models that train only on publicly available data (as of May 24, 2024). Our strong empirical results and extensive analysis demonstrate that LLMs can be effectively transformed into universal text encoders in a parameter-efficient manner without the need for expensive adaptation or synthetic GPT-4 generated data.</p>
</blockquote>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://orenbochman.github.io/reviews/2024/LLM2Vec/fig1.png" class="img-fluid figure-img"></p>
<figcaption>The 3 steps of LLM2Vec</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://orenbochman.github.io/reviews/2024/LLM2Vec/fig2.png" class="img-fluid figure-img"></p>
<figcaption>Evaluation on word level tasks</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://orenbochman.github.io/reviews/2024/LLM2Vec/fig3.png" class="img-fluid figure-img"></p>
<figcaption>Unsupervised results</figcaption>
</figure>
</div>
</section>
<section id="the-paper" class="level2">
<h2 class="anchored" data-anchor-id="the-paper">The paper</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="paper.pdf" class="col-page" width="800"></p>
<figcaption>paper</figcaption>
</figure>
</div>
</section>
<section id="resources" class="level2">
<h2 class="anchored" data-anchor-id="resources">Resources</h2>
<ul>
<li><a href="https://github.com/McGill-NLP/llm2vec">code</a></li>
</ul>
<div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/44OukEJyRsU" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-behnamghader2024llm2veclargelanguagemodels" class="csl-entry">
BehnamGhader, Parishad, Vaibhav Adlakha, Marius Mosbach, Dzmitry Bahdanau, Nicolas Chapados, and Siva Reddy. 2024. <span>“LLM2Vec: Large Language Models Are Secretly Powerful Text Encoders.”</span> <a href="https://arxiv.org/abs/2404.05961">https://arxiv.org/abs/2404.05961</a>.
</div>
<div id="ref-raffel2020exploring" class="csl-entry">
Raffel, Colin, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi Zhou, Wei Li, and Peter J Liu. 2020. <span>“Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer.”</span> <em>Journal of Machine Learning Research</em> 21 (140): 1–67.
</div>
</div></section></div> ]]></description>
  <guid>https://orenbochman.github.io/reviews/2024/LLM2Vec/</guid>
  <pubDate>Thu, 26 Sep 2024 14:07:51 GMT</pubDate>
  <media:content url="https://orenbochman.github.io/reviews/2024/LLM2Vec/cover.jpg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>MambaVision A Hybrid Mamba-Transformer Vision Backbone</title>
  <link>https://orenbochman.github.io/reviews/2024/mamba-vision/</link>
  <description><![CDATA[ 




<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In <span class="citation" data-cites="hatamizadeh2024mambavision">(Hatamizadeh and Kautz 2024)</span>, the authors apply the State Space Model (SSM) inherent in recently introduced Mamba architecture, <span class="citation" data-cites="gu2023mamba">(Gu and Dao 2023)</span>, for vision tasks. They point out that prior work on using the Mamba architecture for vision was ill-suited these tasks and propose a remedy in the form of a hybrid Mamba-Transformer architecture which they call MambaVision. Thier experiment show that MambaVision outperforms other vision architectures on ImageNet-1K, MS COCO and ADE20K datasets.</p>
<p>The paper’s main innovation is <mark>more self-attention blocks in the final layers of the transformer which improves the models ability to capture long-range spatial dependencies</mark>.</p>
</section>
<section id="the-problems-with-mamba-for-vision-tasks" class="level2">
<h2 class="anchored" data-anchor-id="the-problems-with-mamba-for-vision-tasks">The problems with Mamba for vision tasks</h2>
<p>A <em>dilettante reader</em> like myself might be interested in the author’s outline of the shortcomings of the Mamba architecture for vision tasks and earlier attempt in <span class="citation" data-cites="zhu2024vision">(Zhu et al. 2024)</span> <em>vision mamba</em> model which directed thier efforts the right direction.</p>
<blockquote class="blockquote">
<p>… the Mamba’s autoregressive formulation, while effective for tasks requiring sequential data processing, faces limitations in computer vision tasks that benefit from a <strong>full receptive field</strong><sup>1</sup>:</p>
<ol type="1">
<li><p>Unlike sequences where order matters, image pixels do not have a sequential dependency in the same way. Instead, spatial relationships are often local and need to be considered in a more parallel and integrated manner. Hence, this results in inefficiency for processing spatial data</p></li>
<li><p>an autoregressive model like Mamba processes data step-by-step, limiting its ability to capture and utilize global context in one forward pass. In contrast, vision tasks often require understanding the global context to make accurate predictions about local regions</p></li>
</ol>
</blockquote>
<blockquote class="blockquote">
<p>Vision Mamba (Vim) and others have proposed modifications such as bidirectional SSMs to address lack of global context and spatial understanding. While bidirectional SSMs have the potential to capture more comprehensive context, they introduce significant latency due to the need to process the entire sequence before making predictions. Additionally, the increased complexity can lead to challenges in training, risk of overfitting, and may not always result in better accuracy. Due to these pitfalls, backbones with Vision Transformer (ViT) and Convolutional Neural Network (CNN) architectures still outperform best Mamba-based vision models on different vision tasks. — <span class="citation" data-cites="hatamizadeh2024mambavision">(Hatamizadeh and Kautz 2024, 2)</span></p>
</blockquote>
<p>To sum all this up - Mamba’s auto regressive nature is well suited to temporal and sequential data like text and speech but is ill suited to handle spatial data like images where order manifests as a hierarchy of spatial neighborhoods which should be processed in parallel. Thus for vision, mamba suffer a loss in the efficiency of the flow of information both locally and globally. As such pre mamba vision models fare better.</p>
<p>The next section outlines the ideas espoused in prior work both pre and post mamba. This section summarizes both the earlier work on computer vision models since the introduction of Transformers and some results since the introduction of the Mamba architecture.</p>
<ul>
<li>Vision Transformer (ViT) <span class="citation" data-cites="dosovitskiy2021imageworth16x16words">(Dosovitskiy et al. 2021)</span> showed that CNNs can be replaced with self-attention, but wasn’t data efficient.</li>
<li>Data-efficient Image Transformer (DeiT) <span class="citation" data-cites="touvron2021training">(Touvron et al. 2021)</span> used distillation to train ViT more efficient.</li>
<li>LeViT model <span class="citation" data-cites="graham2021levit">(Graham et al. 2021)</span> introduced a redesign for MLP and self-attention with a Lenet like pyramid pooling structure.</li>
<li>Cross-covariance Image Transformer (XCiT) <span class="citation" data-cites="ali2021xcit">(Ali et al. 2021)</span> introduced transposed self-attention mechanism more effectively modeling interactions between feature channels.</li>
<li>The Pyramid Vision Transformer (PVT) <span class="citation" data-cites="wang2021pyramid">(Wang et al. 2021)</span> improving efficiency by adopting a hierarchical structure with patch embedding at the start of each stage and spatial dimension reduction.</li>
<li>Swin Transformer <span class="citation" data-cites="liu2021swin">(Liu et al. 2021)</span> used shifted windows to improve the efficiency of self-attention computation.</li>
<li>Twins Transformer <span class="citation" data-cites="chu2021twins">(Chu et al. 2021)</span> featured spatially separable self-attention that significantly enhanced efficiency.</li>
<li>Focal Transformer <span class="citation" data-cites="yang2021focal">(Yang et al. 2021)</span> used a focal mechanism to improve the efficiency of self-attention computation for capturing long-range interactions.</li>
</ul>
</section>
<section id="the-mambavision-architecture---macro" class="level2">
<h2 class="anchored" data-anchor-id="the-mambavision-architecture---macro">3.1 The MambaVision Architecture - Macro</h2>
<p>MambaVision has a hierarchical architecture consisting of 4 different stages. The first two stages consist of CNN-based layers for fast feature extraction at higher input resolutions, while stage 3 and 4 include the proposed MambaVision and Transformer blocks.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://orenbochman.github.io/reviews/2024/mamba-vision/fig2.png" class="img-fluid figure-img"></p>
<figcaption>Architecture of hierarchical MambaVision</figcaption>
</figure>
</div>
<p>The first two blocks in stages 1 and 2</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Chat%20z%20=%20GELU(BN(Conv_%7B3%C3%973%7D(z)))%0A"></p>
<p><img src="https://latex.codecogs.com/png.latex?%0Az%20=%20BN(Conv_%7B3%C3%973%7D(%5Chat%20z))%20+%20z%0A"></p>
<p>Where GELU is the Gaussian Error Linear Unit activation function, a modern alternative to the rectified linear unit (ReLU) function, and BN is good old batch normalization layer which transforms the inputs to have zero mean and unit variance which speeds up training.</p>
</section>
<section id="the-mambavision-architecture---micro" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="the-mambavision-architecture---micro">3.2 The MambaVision Architecture - Micro</h2>

<div class="no-row-height column-margin column-container"><div id="fig-micro" class="quarto-float quarto-figure quarto-figure-left anchored" data-group="my-gallery" data-fig-align="left">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-micro-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://orenbochman.github.io/reviews/2024/mamba-vision/fig3.png" class="img-fluid quarto-figure quarto-figure-left figure-img" data-group="my-gallery" width="300">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-micro-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Architecture of MambaVision block
</figcaption>
</figure>
</div></div><p>The authors redesigned the original Mamba mixer to make it more suitable for vision tasks.</p>
<ol type="1">
<li>regular convolution replaces causal convolution</li>
<li>added a symmetric branch without SSM , consisting of an additional convolution and SiLU activation, to compensate for any content lost due to the sequential constraints of SSMs.</li>
<li>These branches are concatenated and project via a final linear layer.</li>
</ol>
<p>This combination ensures that the final feature representation incorporates both the sequential and spatial information, leveraging the strengths of both branches.</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Balign*%7D%0AX_1%20&amp;=%20Scan(%CF%83(Conv(Linear(C,%20%5Cfrac%7BC%7D%7B2%7D%20)(X_%7Bin%7D))))%20%5C%5C%0AX_2%20&amp;=%20%CF%83(Conv(Linear(C,%20%5Cfrac%7BC%7D%7B2%7D%20)(X_%7Bin%7D)))%20%5C%5C%0AX_%7Bout%7D%20&amp;=%20Linear(%20%5Cfrac%7BC%7D%7B2%7D%20,%20C)(Concat(X_1,%20X_2))%20%5C%5C%0A%5Cend%7Balign*%7D%0A"></p>
</section>
<section id="ablation-studies" class="level2">
<h2 class="anchored" data-anchor-id="ablation-studies">Ablation Studies</h2>
<p>Section 4 the experiment looks at MambaVision’s performance in image classification as well as other downstream tasks like, object detection, instance segmentation and semantic segmentation tasks. The authors note that the model was equipped with the model with specialized heads for different tasks and required fine tuning the original model. I am a somewhat critical of calling this the performance on downstream tasks when we are talking about models with different layers that were fine tuned using different optimizers on task specific datasets.</p>
<p>The results section outline an <strong>ablation study</strong><sup>2</sup> used to identify the optimal way to integrate the Vision Transformer (ViT) with the Mamba architecture.</p>
<p>As usual, the authors provide a family of models with different sizes to gauge the performance characteristics for scaling the model.</p>
<p>The various models</p>
</section>
<section id="resources" class="level2">
<h2 class="anchored" data-anchor-id="resources">Resources</h2>
<ul>
<li><a href="https://arxiv.org/pdf/2407.08083">paper</a></li>
<li><a href="https://github.com/NVlabs/MambaVision">code</a></li>
</ul>



</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-ali2021xcit" class="csl-entry">
Ali, Alaaeldin, Hugo Touvron, Mathilde Caron, Piotr Bojanowski, Matthijs Douze, Armand Joulin, Ivan Laptev, et al. 2021. <span>“Xcit: Cross-Covariance Image Transformers.”</span> <em>Advances in Neural Information Processing Systems</em> 34: 20014–27.
</div>
<div id="ref-chu2021twins" class="csl-entry">
Chu, Xiangxiang, Zhi Tian, Yuqing Wang, Bo Zhang, Haibing Ren, Xiaolin Wei, Huaxia Xia, and Chunhua Shen. 2021. <span>“Twins: Revisiting the Design of Spatial Attention in Vision Transformers.”</span> <em>Advances in Neural Information Processing Systems</em> 34: 9355–66.
</div>
<div id="ref-dosovitskiy2021imageworth16x16words" class="csl-entry">
Dosovitskiy, Alexey, Lucas Beyer, Alexander Kolesnikov, Dirk Weissenborn, Xiaohua Zhai, Thomas Unterthiner, Mostafa Dehghani, et al. 2021. <span>“An Image Is Worth 16x16 Words: Transformers for Image Recognition at Scale.”</span> <a href="https://arxiv.org/abs/2010.11929">https://arxiv.org/abs/2010.11929</a>.
</div>
<div id="ref-graham2021levit" class="csl-entry">
Graham, Benjamin, Alaaeldin El-Nouby, Hugo Touvron, Pierre Stock, Armand Joulin, Hervé Jégou, and Matthijs Douze. 2021. <span>“Levit: A Vision Transformer in Convnet’s Clothing for Faster Inference.”</span> In <em>Proceedings of the IEEE/CVF International Conference on Computer Vision</em>, 12259–69.
</div>
<div id="ref-gu2023mamba" class="csl-entry">
Gu, Albert, and Tri Dao. 2023. <span>“Mamba: Linear-Time Sequence Modeling with Selective State Spaces.”</span> <em>arXiv Preprint arXiv:2312.00752</em>.
</div>
<div id="ref-hatamizadeh2024mambavision" class="csl-entry">
Hatamizadeh, Ali, and Jan Kautz. 2024. <span>“MambaVision: A Hybrid Mamba-Transformer Vision Backbone.”</span> <em>arXiv Preprint arXiv:2407.08083</em>.
</div>
<div id="ref-liu2021swin" class="csl-entry">
Liu, Ze, Yutong Lin, Yue Cao, Han Hu, Yixuan Wei, Zheng Zhang, Stephen Lin, and Baining Guo. 2021. <span>“Swin Transformer: Hierarchical Vision Transformer Using Shifted Windows.”</span> In <em>Proceedings of the IEEE/CVF International Conference on Computer Vision</em>, 10012–22.
</div>
<div id="ref-touvron2021training" class="csl-entry">
Touvron, Hugo, Matthieu Cord, Matthijs Douze, Francisco Massa, Alexandre Sablayrolles, and Hervé Jégou. 2021. <span>“Training Data-Efficient Image Transformers &amp; Distillation Through Attention.”</span> In <em>International Conference on Machine Learning</em>, 10347–57. PMLR.
</div>
<div id="ref-wang2021pyramid" class="csl-entry">
Wang, Wenhai, Enze Xie, Xiang Li, Deng-Ping Fan, Kaitao Song, Ding Liang, Tong Lu, Ping Luo, and Ling Shao. 2021. <span>“Pyramid Vision Transformer: A Versatile Backbone for Dense Prediction Without Convolutions.”</span> In <em>Proceedings of the IEEE/CVF International Conference on Computer Vision</em>, 568–78.
</div>
<div id="ref-yang2021focal" class="csl-entry">
Yang, Jianwei, Chunyuan Li, Pengchuan Zhang, Xiyang Dai, Bin Xiao, Lu Yuan, and Jianfeng Gao. 2021. <span>“Focal Attention for Long-Range Interactions in Vision Transformers.”</span> <em>Advances in Neural Information Processing Systems</em> 34: 30008–22.
</div>
<div id="ref-zhu2024vision" class="csl-entry">
Zhu, Lianghui, Bencheng Liao, Qian Zhang, Xinlong Wang, Wenyu Liu, and Xinggang Wang. 2024. <span>“Vision Mamba: Efficient Visual Representation Learning with Bidirectional State Space Model.”</span> <em>arXiv Preprint arXiv:2401.09417</em>.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>seeing the full picture or at least big parts of it↩︎</p></li>
<li id="fn2"><p>investigating the effects of removing parts of a model↩︎</p></li>
</ol>
</section></div> ]]></description>
  <guid>https://orenbochman.github.io/reviews/2024/mamba-vision/</guid>
  <pubDate>Thu, 26 Sep 2024 14:07:51 GMT</pubDate>
  <media:content url="https://orenbochman.github.io/reviews/2024/mamba-vision/cover.jpg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>Q*: Improving Multi-step Reasoning for LLMs with Deliberative Planning</title>
  <link>https://orenbochman.github.io/reviews/2024/q-star/</link>
  <description><![CDATA[ 




<p>The announcement of the GPT-5 strawberry model has sparked a lot of interest in this paper which seems to be the theory behind Open.ai’s new model.</p>
<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">TLDR</h2>
<p>In <span class="citation" data-cites="wang2024qimprovingmultistepreasoning">(Wang et al. 2024)</span>, titled “Q*: Improving Multi-step Reasoning for LLMs with Deliberative Planning,” the authors propose a new framework called Q* to improve the multi-step reasoning capabilities of Large Language Models (LLMs). The authors identify a key issue with LLMs: their auto-regressive nature often leads to errors, hallucinations, and inconsistencies in multi-step reasoning tasks.</p>
<div class="callout-info">
<p>some questions to consider:</p>
<ol type="1">
<li>In the Q* MDP what are the states, <strong>actions</strong>, rewards, and transition probabilities?</li>
<li>The idea of a utility function is central to the Q* framework. How is the utility function defined in this context?</li>
</ol>
</div>
</section>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<blockquote class="blockquote">
<p>Large Language Models (LLMs) have demonstrated impressive capability in many natural language tasks. However, the auto-regressive generation process makes LLMs prone to produce errors, hallucinations and inconsistent statements when performing multi-step reasoning. In this paper, by casting multi-step reasoning of LLMs as a heuristic search problem, we aim to alleviate the pathology by introducing Q*, a general, versatile and agile framework for guiding LLMs decoding process with deliberative planning. By learning a plug-and-play Q-value model as heuristic function for estimating expected future rewards, our Q* can effectively guide LLMs to select the most promising next reasoning step without fine-tuning LLMs for the current task, which avoids the significant computational overhead and potential risk of performance degeneration on other tasks. Extensive experiments on GSM8K, MATH and MBPP demonstrate the superiority of our method, contributing to improving the reasoning performance of existing open-source LLMs.</p>
<p>— <span class="citation" data-cites="wang2024qimprovingmultistepreasoning">(Wang et al. 2024)</span></p>
</blockquote>
</section>
<section id="the-problem" class="level2">
<h2 class="anchored" data-anchor-id="the-problem">The Problem</h2>
<p>LLMs face challenges in multi-step reasoning tasks, frequently producing errors due to their auto-regressive generation process. While previous efforts have tried to enhance LLMs’ “System 1” capabilities (fast but less accurate), complex reasoning requires “System 2” processes—more deliberative and logical thinking.</p>
</section>
<section id="the-q-framework" class="level2">
<h2 class="anchored" data-anchor-id="the-q-framework">The Q* Framework</h2>
<ul>
<li>The authors cast multi-step reasoning as a Markov Decision Process (MDP) and introduce the Q* framework. The framework uses a Q-value model as a heuristic function to guide LLMs during the decoding process.</li>
<li>Q* operates without the need for fine-tuning LLMs for each task, avoiding computational overhead and the risk of performance degradation in other tasks.</li>
<li>Q* leverages A* search to select the most promising next reasoning step, using a proxy Q-value model to guide this process.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://orenbochman.github.io/reviews/2024/q-star/figure1.png" class="img-fluid figure-img"></p>
<figcaption>Q* framework overview</figcaption>
</figure>
</div>
</section>
<section id="key-contributions" class="level2">
<h2 class="anchored" data-anchor-id="key-contributions">Key Contributions</h2>
<ul>
<li><mark>Formalizing multi-step reasoning of LLMs as an MDP</mark></li>
<li>Introducing general approaches to estimate the optimal Q-value of state-action pairs, including offline reinforcement learning, rollouts, and completion with stronger LLMs.</li>
<li>Casting multi-step reasoning tasks as a <strong>heuristic search problem</strong> to find the optimal reasoning trace with maximum utility.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://orenbochman.github.io/reviews/2024/q-star/algorithm.png" class="img-fluid figure-img"></p>
<figcaption>Deliberative planning Algorithm for LLMs with A*</figcaption>
</figure>
</div>
</section>
<section id="estimation-of-optimal-q-value" class="level2">
<h2 class="anchored" data-anchor-id="estimation-of-optimal-q-value">Estimation of Optimal Q-value</h2>
<p>The authors present several ways to estimate the optimal Q-value:</p>
<ul>
<li>Offline Reinforcement Learning: Using Fitted Q-iteration to update the Q-value model iteratively.</li>
<li>Learning from Rollout: Performing random rollouts or Monte Carlo Tree Search (MCTS) to identify the best reasoning sequence.</li>
<li>Completion with Stronger LLMs: Using a stronger LLM to complete the trajectory and estimate the optimal Q-value.</li>
</ul>
</section>
<section id="experiments" class="level2">
<h2 class="anchored" data-anchor-id="experiments">Experiments</h2>
<p>The framework was tested on math reasoning (GSM8K, MATH) and code generation (MBPP) tasks. Results showed that:</p>
<ul>
<li>Q* improves the reasoning capability of existing open-source LLMs.</li>
<li>Q* outperforms traditional Best-of-N methods and existing LLMs enhanced with alignment techniques like PPO (Proximal Policy Optimization).</li>
</ul>
</section>
<section id="conclusions" class="level2">
<h2 class="anchored" data-anchor-id="conclusions">Conclusions</h2>
<p>Q* provides an agile deliberation framework for LLMs, improving their multi-step reasoning ability without the need for extensive fine-tuning. It is generalizable across various reasoning tasks, making it a versatile tool for enhancing LLM performance.</p>
</section>
<section id="strengths" class="level2">
<h2 class="anchored" data-anchor-id="strengths">Strengths</h2>
<ul>
<li><p><strong>Novel Framework</strong>: Introducing Q* as a deliberative planning framework is a novel approach to improving multi-step reasoning.</p></li>
<li><p><strong>Versatility</strong>: Q* can be applied to various reasoning tasks without task-specific modifications.</p></li>
<li><p><strong>Extensive Evaluation</strong>: The authors conducted experiments across multiple datasets, demonstrating the efficacy of their approach.</p></li>
</ul>
</section>
<section id="weaknesses-and-areas-for-improvement" class="level2">
<h2 class="anchored" data-anchor-id="weaknesses-and-areas-for-improvement">Weaknesses and Areas for Improvement</h2>
<ul>
<li><p><strong>Complexity</strong>: The paper introduces a relatively complex framework, which might present challenges in understanding and implementing the approach.</p></li>
<li><p><strong>Dependency on Q-value Estimation</strong>: The performance of Q* is heavily reliant on the accuracy of the Q-value model, which might be sensitive to the chosen estimation method.</p></li>
<li><p><strong>Limited Exploration of Alternatives</strong>: While the paper focuses on Q*<em>, there could be a discussion on how this method compares with other deliberative planning methods in more depth.</em></p></li>
</ul>
</section>
<section id="overall-impression" class="level2">
<h2 class="anchored" data-anchor-id="overall-impression"><em>Overall Impression</em></h2>
<p><em>The paper presents a solid contribution to improving multi-step reasoning in LLMs. The Q*</em> framework is a promising approach, particularly in its ability to generalize across different reasoning tasks. However, its complexity and the reliance on accurate Q-value estimation are potential hurdles that might need further exploration.</p>
</section>
<section id="the-paper" class="level2">
<h2 class="anchored" data-anchor-id="the-paper">The paper</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="./paper.pdf" class="col-page" width="800" height="1000"></p>
<figcaption>paper</figcaption>
</figure>
</div>
</section>
<section id="resources" class="level2">
<h2 class="anchored" data-anchor-id="resources">Resources</h2>
<ul>
<li><a href="https://arxiv.org/abs/2406.14283#">paper</a></li>
<li><a href="https://github.com/NVlabs/MambaVision">code</a></li>
</ul>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-wang2024qimprovingmultistepreasoning" class="csl-entry">
Wang, Chaojie, Yanchen Deng, Zhiyi Lyu, Liang Zeng, Jujie He, Shuicheng Yan, and Bo An. 2024. <span>“Q*: Improving Multi-Step Reasoning for LLMs with Deliberative Planning.”</span> <a href="https://arxiv.org/abs/2406.14283">https://arxiv.org/abs/2406.14283</a>.
</div>
</div></section></div> ]]></description>
  <guid>https://orenbochman.github.io/reviews/2024/q-star/</guid>
  <pubDate>Thu, 26 Sep 2024 14:07:51 GMT</pubDate>
  <media:content url="https://orenbochman.github.io/reviews/2024/q-star/cover.jpg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>Smaller, Weaker, Yet Better: Training LLM Reasoners via Compute-Optimal Sampling</title>
  <link>https://orenbochman.github.io/reviews/2024/smaller-weaker-yet-better/</link>
  <description><![CDATA[ 




<p>in <span class="citation" data-cites="bansal2024smallerweakerbettertraining">(Bansal et al. 2024)</span> the authors consider the trade-offs between generating synthetic data using a stronger but more expensive (SE) model versus a weaker but cheaper (WC) model. They evaluate the generated data across three key metrics: coverage, diversity, and false positive rate, and show that the data from WC models may have higher coverage and diversity, but also exhibit higher false positive rates. They then finetune LMs on data from SE and WC models in different settings: knowledge distillation, self-improvement, and a novel weak-to-strong improvement setup where a weaker LM teaches reasoning to a stronger LM. Their findings reveal that models finetuned on WC-generated data consistently outperform those trained on SE-generated data across multiple benchmarks and multiple choices of WC and SE models. These results challenge the prevailing practice of relying on SE models for synthetic data generation, suggesting that WC may be the compute-optimal approach for training advanced LM reasoners.</p>
<p>Training on high-quality synthetic data from strong language models (LMs) is a common strategy to improve the reasoning performance of LMs. In this work, we revisit whether this strategy is compute-optimal under a fixed inference budget (e.g., FLOPs). To do so, we investigate the trade-offs between generating synthetic data using a stronger but more expensive (SE) model versus a weaker but cheaper (WC) model. We evaluate the generated data across three key metrics: coverage, diversity, and false positive rate, and show that the data from WC models may have higher coverage and diversity, but also exhibit higher false positive rates. We then finetune LMs on data from SE and WC models in different settings: knowledge distillation, self-improvement, and a novel weak-to-strong improvement setup where a weaker LM teaches reasoning to a stronger LM. Our findings reveal that models finetuned on WC-generated data consistently outperform those trained on SE-generated data across multiple benchmarks and multiple choices of WC and SE models. These results challenge the prevailing practice of relying on SE models for synthetic data generation, suggesting that WC may be the compute-optimal approach for training advanced LM reasoners.</p>




<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-bansal2024smallerweakerbettertraining" class="csl-entry">
Bansal, Hritik, Arian Hosseini, Rishabh Agarwal, Vinh Q. Tran, and Mehran Kazemi. 2024. <span>“Smaller, Weaker, yet Better: Training LLM Reasoners via Compute-Optimal Sampling.”</span> <a href="https://arxiv.org/abs/2408.16737">https://arxiv.org/abs/2408.16737</a>.
</div>
</div></section></div> ]]></description>
  <guid>https://orenbochman.github.io/reviews/2024/smaller-weaker-yet-better/</guid>
  <pubDate>Thu, 26 Sep 2024 14:07:51 GMT</pubDate>
  <media:content url="https://orenbochman.github.io/reviews/2024/smaller-weaker-yet-better/cover.jpg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>TheoremLlama An End-To-End Framework to Train a General-Purpose Large Language Model to Become a Lean4 Expert</title>
  <link>https://orenbochman.github.io/reviews/2024/theorem-llama/</link>
  <description><![CDATA[ 




<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<blockquote class="blockquote">
<p>Proving mathematical theorems using computer-verifiable formal languages like Lean significantly impacts mathematical reasoning. One approach to formal theorem proving involves generating complete proofs using Large Language Models (LLMs) based on Natural Language (NL) proofs. Similar methods have shown promising results in code generation. However, most modern LLMs exhibit suboptimal performance due to the scarcity of aligned NL and Formal Language (FL) theorem-proving data. This scarcity results in a paucity of methodologies for training LLMs and techniques to fully utilize their capabilities in composing formal proofs. To address the challenges, this paper proposes TheoremLlama, an end-to-end framework to train a general-purpose LLM to become a Lean4 expert. This framework encompasses NL-FL aligned dataset generation methods, training approaches for the LLM formal theorem prover, and techniques for LLM Lean4 proof writing. Using the dataset generation method, we provide <a href="https://huggingface.co/datasets/RickyDeSkywalker/OpenBootstrappedTheorem">Open Bootstrapped Theorems</a> (OBT), an NL-FL aligned and bootstrapped dataset. A key innovation in this framework is the NL-FL bootstrapping method, where NL proofs are integrated into Lean4 code for training datasets, leveraging the NL reasoning ability of LLMs for formal reasoning. The TheoremLlama framework achieves cumulative accuracies of 36.48% and 33.61% on MiniF2F-Valid and Test datasets respectively, surpassing the GPT-4 baseline of 22.95% and 25.41%. We have also open-sourced our model checkpoints and generated dataset1, and will soon make all the code publicly available2.</p>
</blockquote>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p><span class="citation" data-cites="wang2024theoremllamatransforminggeneralpurposellms">(Wang et al. 2024)</span> the authors present an end-to-end framework to train a Large Language Model (LLM) to become a <a href="https://github.com/leanprover/lean4">Lean4</a> expert. <sup>1</sup> <mark>The framework includes NL-FL aligned dataset generation methods, training approaches for the LLM formal theorem prover, and techniques for LLM Lean4 proof writing.</mark> The authors demonstrate the effectiveness of TheoremLlama by achieving cumulative accuracies of 36.48% and 33.61% on MiniF2F-Valid and Test datasets respectively, surpassing the GPT-4 baseline of 22.95% and 25.41%.<sup>2</sup></p>
<p>TheoremLlama is a significant step towards using LLMs’ natural language abilities to formalize theorem proving in Lean4, improving mathematical reasoning, and tackling major issues with data alignment and training approaches.</p>
<p>However, <mark>the lack of aligned NL and Formal Language (FL) theorem-proving data frequently makes it difficult for contemporary LLMs to operate efficiently.</mark> The lack of available resources impedes the advancement of efficient training approaches and strategies to fully utilize LLMs’ potential in creating formal mathematical proofs. In order to overcome these limitations, a team of researchers from The Hong Kong University of Science and Technology and the University of Illinois Urban-Champagin has introduced TheoremLlama, an end-to-end framework created to specialize a general-purpose LLM in Lean4 theorem proving.</p>
<p>TheoremLlama is made up of various important parts, which are as follows:</p>
<ul>
<li><p>NL-FL Aligned Dataset Generation: TheoremLlama presents techniques for creating an NL-FL-aligned dataset in order to get over data shortage. This dataset, called Open Bootstrapped Theorems (OBT), uses a bootstrapping technique to include NL proofs into Lean4 code. By integrating NL reasoning into Lean4 scenarios, the framework improves LLMs’ comprehension and execution of formal reasoning.</p></li>
<li><p>Formal Training for LLM Theorem Provers: The system applies new training strategies to help LLMs become successful Lean4 theorem provers. Methods like block training and curriculum data sorting have been utilized to enhance the LLM’s in-context learning and guarantee reliable training on the OBT dataset. LLM Lean4 Proof Writing: This part is about improving the LLM’s capacity to write formal proofs in Lean4 on its own. The LLM refines its formal reasoning abilities iteratively by using correctly generated proofs as examples.</p></li>
<li><p>TheoremLlama’s NL-FL bootstrapping approach is a significant invention that enables efficient training by coordinating natural language reasoning with formal mathematical language constraints. The framework’s efficiency has been demonstrated by experimental findings, which on the MiniF2F-Valid and Test datasets, respectively, yielded cumulative accuracies of 36.48% and 33.61%. These outcomes outperformed GPT-4’s baseline findings, which on the same datasets yielded accuracies of 22.95% and 25.41%.</p></li>
</ul>
<p>In conclusion, TheoremLlama is an important step towards using LLMs’ natural language abilities to formalize theorem proving in Lean4, improving mathematical reasoning, and tackling major issues with data alignment and training approaches</p>
</section>
<section id="see-also" class="level2">
<h2 class="anchored" data-anchor-id="see-also">See also:</h2>
<ul>
<li><a href="https://arxiv.org/abs/2407.03203">paper</a></li>
<li>https://www.marktechpost.com/2024/07/10/theoremllama-an-end-to-end-framework-to-train-a-general-purpose-large-language-model-to-become-a-lean4-expert/</li>
</ul>



</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-wang2024theoremllamatransforminggeneralpurposellms" class="csl-entry">
Wang, Ruida, Jipeng Zhang, Yizhen Jia, Rui Pan, Shizhe Diao, Renjie Pi, and Tong Zhang. 2024. <span>“TheoremLlama: Transforming General-Purpose LLMs into Lean4 Experts.”</span> <a href="https://arxiv.org/abs/2407.03203">https://arxiv.org/abs/2407.03203</a>.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Note: lean has a serious learning curve and is used in many current mathematics research projects.↩︎</p></li>
<li id="fn2"><p>But is this sufficient to make a difference in the real world? GPT-4 isn’t expected to do well on lean…. ↩︎</p></li>
</ol>
</section></div> ]]></description>
  <guid>https://orenbochman.github.io/reviews/2024/theorem-llama/</guid>
  <pubDate>Thu, 26 Sep 2024 14:07:51 GMT</pubDate>
  <media:content url="https://orenbochman.github.io/reviews/2024/theorem-llama/cover.jpg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>Tree Attention: Topology-Aware Decoding for Long-Context Attention on GPU Clusters</title>
  <link>https://orenbochman.github.io/reviews/2024/tree-attention/</link>
  <description><![CDATA[ 




<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">TL;DR</h2>
<p>in <span class="citation" data-cites="shyam2024treeattn">(Shyam et al. 2024)</span> the authors propose a new algorithm for parallelizing attention computation across multiple GPUs. This enables cross-device decoding to be performed asymptotically faster (up to 8 x faster in our experiments) than alternative approaches such as Ring Attention, while also requiring significantly less communication volume and incurring 2 x less peak memory.</p>
</section>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<blockquote class="blockquote">
<p><mark>Self-attention is the core mathematical operation of modern transformer architectures and is also a significant computational bottleneck due to its quadratic complexity in the sequence length</mark>. In this work, we derive the scalar energy function whose gradient computes the self-attention block, thus elucidating the theoretical underpinnings of self-attention, providing a Bayesian interpretation of the operation and linking it closely with energy-based models such as Hopfield Networks. Our formulation reveals that the reduction across the sequence axis can be efficiently computed in parallel through a tree reduction. Our algorithm, for parallelizing attention computation across multiple GPUs enables cross-device decoding to be performed asymptotically faster (up to 8× faster in our experiments) than alternative approaches such as Ring Attention, while also requiring significantly less communication volume and incurring 2 x less peak memory.</p>
<p>— <span class="citation" data-cites="shyam2024treeattn">(Shyam et al. 2024)</span></p>
</blockquote>
</section>
<section id="resources" class="level2">
<h2 class="anchored" data-anchor-id="resources">Resources</h2>
<p><a href="https://github.com/Zyphra/tree_attention">code</a></p>
</section>
<section id="softmax" class="level2 callout-info">
<h2 class="anchored" data-anchor-id="softmax">Softmax</h2>
<p>The softmax operation can be derived as the gradient of the following scalar function:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cdelta%20z_i%20%5Csum_%7Ba=1%7D%5En%20exp(z_a)%20=%20%5Cfrac%7Be%5E%7Bz_j%7D%7D%7B%5Csum%5En_%7Ba=1%7D%20e%5E%7Bz_j%7D%7D%20=%20%5Ctext%7Bsoftmax%7D(z_j)%0A"></p>
</section>




<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-shyam2024treeattn" class="csl-entry">
Shyam, Vasudev, Jonathan Pilault, Emily Shepperd, Quentin Anthony, and Beren Millidge. 2024. <span>“Tree Attention: Topology-Aware Decoding for Long-Context Attention on GPU Clusters.”</span> <a href="https://arxiv.org/abs/2408.04093">https://arxiv.org/abs/2408.04093</a>.
</div>
</div></section></div> ]]></description>
  <guid>https://orenbochman.github.io/reviews/2024/tree-attention/</guid>
  <pubDate>Thu, 26 Sep 2024 14:07:51 GMT</pubDate>
</item>
<item>
  <title>2BP: 2-Stage Backpropagation</title>
  <link>https://orenbochman.github.io/reviews/2024/two-stage-backpropagation/</link>
  <description><![CDATA[ 




<p>in <span class="citation" data-cites="shyam2024treeattentiontopologyawaredecoding">(Shyam et al. 2024)</span> the authors …</p>
<p>As Deep Neural Networks (DNNs) grow in size and complexity, they often exceed the memory capacity of a single accelerator, necessitating the sharding of model parameters across multiple accelerators. Pipeline parallelism is a commonly used sharding strategy for training large DNNs. However, current implementations of pipeline parallelism are being unintentionally bottlenecked by the automatic differentiation tools provided by ML frameworks. This paper introduces 2-stage backpropagation (2BP). By splitting the backward propagation step into two separate stages, we can reduce idle compute time. We tested 2BP on various model architectures and pipelining schedules, achieving increases in throughput in all cases. Using 2BP, we were able to achieve a 1.70x increase in throughput compared to traditional methods when training a LLaMa-like transformer with 7 billion parameters across 4 GPUs.</p>




<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-shyam2024treeattentiontopologyawaredecoding" class="csl-entry">
Shyam, Vasudev, Jonathan Pilault, Emily Shepperd, Quentin Anthony, and Beren Millidge. 2024. <span>“Tree Attention: Topology-Aware Decoding for Long-Context Attention on GPU Clusters.”</span> <a href="https://arxiv.org/abs/2408.04093">https://arxiv.org/abs/2408.04093</a>.
</div>
</div></section></div> ]]></description>
  <guid>https://orenbochman.github.io/reviews/2024/two-stage-backpropagation/</guid>
  <pubDate>Thu, 26 Sep 2024 14:07:51 GMT</pubDate>
</item>
<item>
  <title>Why bother reviewing papers?</title>
  <link>https://orenbochman.github.io/reviews/meta/meta.html</link>
  <description><![CDATA[ 




<p>Why bother reviewing papers?</p>
<section id="ground-breaking-v.s.-record-breaking" class="level2">
<h2 class="anchored" data-anchor-id="ground-breaking-v.s.-record-breaking">Ground Breaking v.s. Record Breaking</h2>
<p>While all papers should have break new ground, I follow <span class="citation" data-cites="Kuhn1962">(Kuhn 1962)</span> in differentiating between what in … considered a jump and a gradual improvement. Most papers that announce a new SOTA results are gradual improvements - essentially tweaks to well understood experiments while the truly ground-breaking papers are rare. Often, we see the authors taking an innovation from another field (perhaps a theoretical result) and applying it to a new domain. Less frequently, the author connects several previously unrelated results or techniques and does something considered impossible. Finally, there are papers where the authors ignore prior art and develop several original ideas, creating a new field. (Like Nash did with non-cooperative game theory)</p>
<p>They introduce new capabilities that aren’t widely used. e.g.&nbsp;in<span class="citation" data-cites="arora2018linearalgebraicstructureword">(Arora et al. 2018)</span> the authors introduce sparse coding to embeddings. However, research from information science indicates that it can take a few years for results to circulate, become cited, and adopted. This paper often seems irrelevant later on when there is new research that can get more powerful results. Record-breaking papers (most common) beat the SOTAs by a few fractions of a point and typically arrive in black-box models, and their ‘black magic’ is neither fully understood nor transferable and hard to apply. So, going back to the paper that broke the ground, I find it interesting.</p>
</section>
<section id="learning-to-think-like-a-researcher" class="level2">
<h2 class="anchored" data-anchor-id="learning-to-think-like-a-researcher">Learning to think like a researcher</h2>
<p>The way top-tier researchers like Christopher Manning, Geoffrey Hinton, Christopher Bishop and David MacKay came up with their breakthroughs is frequently motivated and outlined in their papers. These can be as simple as making a PCA that works on Neural Networks for TSNE <sup>1</sup>. In <span class="citation" data-cites="pennington-etal-2014-glove">(Pennington, Socher, and Manning 2014)</span> such as getting embedding to work using a covariance matrix rather than a moving window. Or as complicated as introducing causal regret for credit assignment for agents solving social dilemmas. In many ways, the intellectual journey is more fascinating than any specific magic trick.</p>
<p>Reviewing paper it not as good as taking a class with them. If you can do that. However, but teaching is often not the forte for most gifted researchers - sometimes their finest hours are when writing papers. Another point is that in the class teachers are very much limited by the material they can present - the students can only cover so much new mathematics in a class. In a paper they are writing to their peers so that all bets are off and the material can be as advanced as needed and touch on many disparate fields. In Skrym’s book on the evolution of signaling systems routinely touch on game theory, evolution, information theory, sociology, and classical philosophy. The reader left to catch up on their own if they can and to dive into the literature if they are dissatisfied with some of the the author’s claim. but most courses are not as advanced as most papers. I took courses by Christopher Manning or Geoffrey Hinton. However And yet, most of their publications are just as useful to review. It is not enough to read them if you want to assimilate some of their creativity or problem solving approaches. away in the sense that they provide a unique insight into the workings of their minds. It’s fascinating and inspiring to see how these influential figures think about problems and how they approach them. Their papers offer a valuable perspective that can’t be found elsewhere, and this understanding can be a great source of motivation for your own research. What I like about these two authors is that they can take some old ideas/techniques and figure out how to use them in new settings. T-SNE came from PCA, and GLOVE came from Topic Modelling.</p>
<p>I won’t say that ground-breaking papers are easy to read—yet some are written with great clarity, and others, like the LSTM papers, are notoriously difficult to understand. But you may discover that reading through the paper beats watching videos or blog posts by others.</p>
<p>Some points to consider when reviewing the paper.</p>
<ol type="1">
<li>the big picture</li>
<li>what is the main innovation</li>
<li>what is new for you as a reader</li>
<li>anything you feel left out.</li>
<li>anything you disagree with or would have done differently.</li>
</ol>
</section>
<section id="literature-reviews" class="level2">
<h2 class="anchored" data-anchor-id="literature-reviews">Literature Reviews</h2>
<p>Reading some papers in fast-moving areas like ML or deep learning can provide a good overview of recent developments. These tell how the field has changed and delineate the landmark approaches and the papers in which they arrived.</p>
</section>
<section id="more-techniques" class="level2">
<h2 class="anchored" data-anchor-id="more-techniques">More Techniques</h2>
<p>Some talented authors come with diverse backgrounds. They will list many fascinating ideas, algorithms and techniques. Taking a few minutes to check these out Another interesting aspect of many papers is use of algorithms or techniques that I am unfamiliar with.</p>
</section>
<section id="list-of-papers-i-want-to-look-at" class="level2">
<h2 class="anchored" data-anchor-id="list-of-papers-i-want-to-look-at">List of Papers I want to look at</h2>
<section id="wordsense-disambiguation" class="level3">
<h3 class="anchored" data-anchor-id="wordsense-disambiguation">WordSense Disambiguation</h3>
<ul>
<li>GlossBERT
<ul>
<li><a href="https://arxiv.org/abs/1908.07245v4">GlossBERT</a></li>
<li><a href="https://github.com/HSLCY/GlossBERT">Code</a></li>
<li><a href="https://www.youtube.com/watch?v=EMDax4OH_ps">Video</a></li>
</ul></li>
<li><a href="https://arxiv.org/abs/2206.14486">Beyond neural scaling laws: beating power law scaling via data pruning</a></li>
<li><a href="https://arxiv.org/abs/2409.05746">LLMs Will Always Hallucinate, and We Need to Live With This</a></li>
<li><a href="https://www.arxiv.org/abs/2409.04109"><del>Can LLMs Generate Novel Research Ideas? A Large-Scale Human Study with 100+ NLP Researchers</del></a></li>
<li><a href="https://arxiv.org/pdf/1910.10683">Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer</a></li>
<li><a href="https://arxiv.org/abs/2408.16967v1">MemLong: Memory-Augmented Retrieval for Long Text Modeling</a>
<ul>
<li><a href="https://github.com/Bui1dMySea/MemLong">code</a></li>
</ul></li>
<li><a href="https://arxiv.org/abs/2402.05290">Do Transformer World Models Give Better Policy Gradients?</a> RL</li>
<li><a href="https://arxiv.org/abs/2408.15496">ReMamba: Equip Mamba with Effective Long-Sequence Modeling</a></li>
<li><a href="https://www.cv-foundation.org/openaccess/content_cvpr_2014/papers/Sun_Deep_Learning_Face_2014_CVPR_paper.pdf">Deep Learning Face Representation from Predicting 10,000 Classes</a></li>
<li><a href="https://scontent.ftlv16-1.fna.fbcdn.net/v/t39.8562-6/240890413_887772915161178_4705912772854439762_n.pdf?_nc_cat=109&amp;ccb=1-7&amp;_nc_sid=e280be&amp;_nc_ohc=aQZ764jfMEsQ7kNvgEMjdLY&amp;_nc_ht=scontent.ftlv16-1.fna&amp;_nc_gid=AQHSCUGR6sPg45J9npX7vvA&amp;oh=00_AYAYrYM-JUDLmyXIPxiZF8socGVHbEzCDSEFD7_vszSuag&amp;oe=66EE737F">DeepFace: Closing the Gap to Human-Level Performance in Face Verification</a></li>
<li><a href="https://arxiv.org/pdf/1406.4773">Deep Learning Face Representation by Joint Identification-Verification</a></li>
<li><a href="https://www.robots.ox.ac.uk/~vgg/publications/2015/Parkhi15/parkhi15.pdf">Deep Face Recognition</a></li>
<li><a href="https://arxiv.org/pdf/2401.15077">EAGLE: Speculative Sampling Requires Rethinking Feature Uncertainty</a></li>
<li><a href="https://arxiv.org/pdf/2406.16858">EAGLE-2: Faster Inference of Language Models with Dynamic Draft Trees</a></li>
<li><a href="https://arxiv.org/pdf/2408.14837">DIFFUSION MODELS ARE REAL-TIME GAME ENGINES</a> RL Image c.f. <a href="https://gamengen.github.io/">demos</a></li>
<li><a href="https://arxiv.org/abs/2408.14805">Platypus: A Generalized Specialist Model for Reading Text in Various Forms</a></li>
<li><a href="https://arxiv.org/abs/2408.11804">Approaching Deep Learning through the Spectral Dynamics of Weights</a></li>
<li><a href="https://arxiv.org/abs/2408.04093">Tree Attention: Topology-aware Decoding for Long-Context Attention on GPU clusters</a></li>
<li><a href="https://proceedings.mlr.press/v162/nguyen22c.html">Improving Transformers with Probabilistic Attention Keys</a></li>
<li><a href="file:///home/oren/Pictures/4333-Article%20Text-7381-1-10-20190706.pdf">SepNE: Bringing Separability to Network Embedding</a></li>
</ul>



</section>
</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-arora2018linearalgebraicstructureword" class="csl-entry">
Arora, Sanjeev, Yuanzhi Li, Yingyu Liang, Tengyu Ma, and Andrej Risteski. 2018. <span>“Linear Algebraic Structure of Word Senses, with Applications to Polysemy.”</span> <a href="https://arxiv.org/abs/1601.03764">https://arxiv.org/abs/1601.03764</a>.
</div>
<div id="ref-Kuhn1962" class="csl-entry">
Kuhn, Thomas S. 1962. <em>The Structure of Scientific Revolutions</em>. Chicago: University of Chicago Press.
</div>
<div id="ref-pennington-etal-2014-glove" class="csl-entry">
Pennington, Jeffrey, Richard Socher, and Christopher Manning. 2014. <span>“<span>G</span>lo<span>V</span>e: Global Vectors for Word Representation.”</span> In <em>Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (<span>EMNLP</span>)</em>, edited by Alessandro Moschitti, Bo Pang, and Walter Daelemans, 1532–43. Doha, Qatar: Association for Computational Linguistics. <a href="https://doi.org/10.3115/v1/D14-1162">https://doi.org/10.3115/v1/D14-1162</a>.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>you do know how regular PCA work right↩︎</p></li>
</ol>
</section></div> ]]></description>
  <guid>https://orenbochman.github.io/reviews/meta/meta.html</guid>
  <pubDate>Thu, 26 Sep 2024 14:07:51 GMT</pubDate>
  <media:content url="https://orenbochman.github.io/reviews/meta/cover.jpg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>Dependency Parsing using Deep Learning</title>
  <link>https://orenbochman.github.io/reviews/parsing/parsing.html</link>
  <description><![CDATA[ 




<section id="questions" class="level2">
<h2 class="anchored" data-anchor-id="questions">Questions</h2>
<div id="rem-transition-based-approach" class="proof remark">
<p><span class="proof-title"><em>Remark 2</em>. </span>Explina the two approches to parsing</p>
<ol type="1">
<li><p>Constituency Grammar uses phrase structure grammar to organize words into nested constituents.</p></li>
<li><p>Dependency structure of sentences shows which words depend on (modify or are arguments of) which other words. These binary asymmetric relations between the words are called dependencies and are depicted as arrows going from the head (or governor, superior, regent) to the dependent (or modifier, inferior, subordinate)</p></li>
</ol>
<p>Mathematicaly hhis means that there is an preorder relation on the words of a sentence. If needed we add a <mark>fake root element</mark> which makes the relation a tree.</p>
<p>Also from a category theory point of view we are subordinate the the more specific Linguisticaly relations unifing them under the ageis of order to get a more homogenious view of the sentence</p>
<p>Understainng this definition:</p>
<ol type="1">
<li><p>Can there be more than one relation between two words?</p></li>
<li><p>Are there cases where a word has the same relations with multiple parents?</p></li>
<li><p>Can words modify multiple words ? &gt; [[Jack [and Jill]] ascended] here we resolve this issue by</p></li>
<li><p>How do we choose the root of a sentence or decicide to add a fake one?</p></li>
<li></li>
</ol>
</div>
<div id="rem-transition-based-approach" class="proof remark">
<p><span class="proof-title"><em>Remark 2</em>. </span>what is the transition based approach from Nivre 2003</p>
</div>
<div id="rem-key-challenges" class="proof remark">
<p><span class="proof-title"><em>Remark 3</em>. </span></p>
</div>
<p>can we visualize the textual parse tree as a tree</p>
<p>(went (nsubj (Jack) (cc and) (conj Jill)) (prep up (pobj (det the) (hill))))</p>
<p>(S (NP (NP (NNP Jack)) (CC and) (NP (NNP Jill))) (VP (VBD went) (PP (IN up) (NP (DT the) (NN hill)))))</p>
<ol type="1">
<li><p><strong>Learning</strong>: Given a training set D of sentences annotated with dependency graphs, induce a parsing model M that can be used to parse new sentences.ven a training set D of sentences annotated with dependency graphs, induce a parsing model M that can be used to parse new sentences.</p></li>
<li><p><strong>Parsing</strong>: Given a parsing model <img src="https://latex.codecogs.com/png.latex?M"> and a sentence <img src="https://latex.codecogs.com/png.latex?S">, derive the optimal dependency graph <img src="https://latex.codecogs.com/png.latex?D"> for <img src="https://latex.codecogs.com/png.latex?S"> according to <img src="https://latex.codecogs.com/png.latex?M">. :::</p></li>
</ol>


</section>

 ]]></description>
  <guid>https://orenbochman.github.io/reviews/parsing/parsing.html</guid>
  <pubDate>Thu, 26 Sep 2024 14:07:51 GMT</pubDate>
</item>
<item>
  <title>Why Overfitting Isn’t Always Bad: Retrofitting Cross-Lingual Word Embeddings to Dictionaries</title>
  <link>https://orenbochman.github.io/reviews/2020/Why Overfitting Isn’t Always Bad/</link>
  <description><![CDATA[ 




<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">TL;DR</h2>
<p>This paper, “Why Overfitting Isn’t Always Bad: Retrofitting Cross-Lingual Word Embeddings to Dictionaries,” challenges the traditional view that overfitting is inherently detrimental when developing cross-lingual word embeddings (CLWE)<sup>1</sup> and that the evaluation of CLWE using Bilingual Lexicon Induction (BLI) is flawed.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Cross Language Word Embeddings (CLWE) in a nutshell
</div>
</div>
<div class="callout-body-container callout-body">
<p>Since I have not looked into CLWE before I add this outline on how CLWE are being learned from in the video lined below.</p>
<ol type="1">
<li>embeddings are learned for each language</li>
<li>a Bilingual dictionary provides a mapping from word pairs which is used to tweak the embeddings so they align across languages.</li>
</ol>
</div>
</div>
</section>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<blockquote class="blockquote">
<p>Cross-lingual word embeddings (CLWE) are often evaluated on bilingual lexicon induction (BLI). Recent CLWE methods use linear projections, which underfit the training dictionary, to generalize on BLI. However, underfitting can hinder generalization to other downstream tasks that rely on words from the training dictionary. We address this limitation by retrofitting CLWE to the training dictionary, which pulls training translation pairs closer in the embedding space and overfits the training dictionary. This simple post-processing step often improves accuracy on two downstream tasks, despite lowering BLI test accuracy. We also retrofit to both the training dictionary and a synthetic dictionary induced from CLWE, which sometimes generalizes even better on downstream tasks. Our results confirm the importance of fully exploiting the training dictionary in downstream tasks and explains why BLI is a flawed CLWE evaluation.computational resources to train.</p>
<p>— <span class="citation" data-cites="Zhang2020XLingEmbedd">(Zhang et al. 2020)</span></p>
</blockquote>
</section>
<section id="key-points" class="level2">
<h2 class="anchored" data-anchor-id="key-points">Key Points:</h2>
<ol type="1">
<li><strong>Traditional Evaluation of CLWE</strong>:
<ul>
<li>Cross-lingual word embeddings (CLWE) typically aim to map words from different languages into a shared vector space.</li>
<li>They are commonly evaluated using Bilingual Lexicon Induction (BLI), which tests the model’s ability to translate words based on a set of test words.</li>
</ul></li>
<li><strong>Underfitting in Projection-Based CLWE</strong>:
<ul>
<li>Current CLWE methods, particularly linear projection-based ones, underfit the training dictionary. This means they don’t perfectly align all translation pairs in the training data.</li>
<li>The paper argues that this underfitting, while beneficial for BLI test accuracy, can hinder performance on downstream tasks where words from the training dictionary play a critical role.</li>
</ul></li>
<li><strong>Retrofitting Approach</strong>:
<ul>
<li>The authors propose retrofitting as a post-processing step to bring training translation pairs closer in the embedding space, essentially overfitting the training dictionary.</li>
<li>This retrofitting involves modifying the embeddings to minimize distances between training translation pairs while retaining as much of the original structure as possible.</li>
</ul></li>
<li>Retrofitting to Synthetic Dictionaries:
<ul>
<li>In addition to the training dictionary, the paper introduces retrofitting to a synthetic dictionary induced from the original CLWE using the Cross-Domain Similarity Local Scaling (CSLS) heuristic.</li>
<li>This helps balance the need to fit the training dictionary while maintaining some generalization capability for unseen words.</li>
</ul></li>
</ol>
</section>
<section id="experimental-results" class="level2">
<h2 class="anchored" data-anchor-id="experimental-results">Experimental Results:</h2>
<ol type="1">
<li><strong>BLI Accuracy</strong>:
<ul>
<li>Retrofitting the embeddings to the training dictionary results in perfect alignment of training pairs, leading to decreased BLI test accuracy since the embeddings overfit the training data.</li>
<li>However, retrofitting to a synthetic dictionary can achieve a balance, improving BLI test accuracy somewhat while still fitting the training data better.</li>
</ul></li>
<li><strong>Downstream Tasks</strong>:
<ul>
<li>The authors evaluates the retrofitted embeddings on two downstream tasks: <strong>document classification</strong> and <strong>dependency parsing</strong>.</li>
<li>Despite lower BLI test accuracy, retrofitted embeddings often lead to improved performance on these tasks. This underscores the importance of fully exploiting the training dictionary for downstream performance.</li>
</ul></li>
</ol>
</section>
<section id="main-contributions" class="level2">
<h2 class="anchored" data-anchor-id="main-contributions">Main Contributions:</h2>
<ol type="1">
<li><strong>Challenge to BLI as a Sole Metric</strong>:
<ul>
<li>The authors argues that BLI accuracy does not always correlate with downstream task performance, revealing the limitations of relying solely on BLI for evaluating CLWE.</li>
</ul></li>
<li><strong>Retrofitting as a Beneficial Overfitting</strong>:
<ul>
<li>It shows that overfitting to the training dictionary through retrofitting can be beneficial, enhancing the performance of downstream tasks even if it harms BLI test accuracy.</li>
</ul></li>
<li>Synthetic Dictionary for Balance:
<ul>
<li>Introducing the use of a synthetic dictionary for retrofitting provides a middle ground, balancing the need to fit the training dictionary while retaining some generalization ability.</li>
</ul></li>
</ol>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion:</h2>
<p>The authors suggest that the overemphasis on BLI as an evaluation metric for CLWE should be reconsidered, advocating instead for a focus on downstream tasks that better reflect the utility of the embeddings. They propose that future work might explore more complex non-linear projections to better fit the dictionary without compromising on generalization.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion:</h2>
<p>The paper’s main takeaway is that overfitting to the training dictionary via retrofitting is not inherently harmful. In fact, it can lead to better performance on downstream NLP tasks. This insight invites a reconsideration of the evaluation metrics for cross-lingual word embeddings and opens the door for future work on more sophisticated retrofitting and projection methods.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
overfitting
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>It is not surprising that the authors ‘discovered’ that fitting the model on <code>test</code> + <code>train</code> + <code>validation</code> gives better results then fitting on <code>train</code> part only. After all the best way to reduce overfitting is to give it more data.</li>
<li>This is a common practice in machine learning to train on the full dataset once we have used to get the best results when the model is deployed to production.</li>
<li>Bayesian LOO Cross validation also allows one to measure the generalization error of the model without having to make the sacrifice of a train/test split.</li>
<li>Considering that the dataset is a dictionary means there is probably little noise to overfit on.</li>
</ul>
<p>On the other hand their criticism of BLI as a metric is valid. There are lots of bad metrics and it is more so when we wish to use it to estimate performance on a different task. In RL one uses importance sampling to make the correction between on policy and off policy - perhaps this is something to look into, though it would be easier to do this if this was a RL problem rather than supervised ML.</p>
<p>It is a common practice in machine learning to use a proxy metric to evaluate the model. The problem is that the proxy metric is not always a good indicator of the model’s performance on the real task. This is why it is important to evaluate the model on the real task as well.</p>
</div>
</div>
</section>
<section id="see-also" class="level2">
<h2 class="anchored" data-anchor-id="see-also">See also</h2>
<ul>
<li><a href="http://users.umiacs.umd.edu/~jbg/docs/2020_acl_refine.pdf">Paper</a></li>
<li><a href="https://www.youtube.com/watch?v=yVN47wGkCko">Video</a></li>
<li><a href="https://github.com/zhangmozhi/retrofit_clwe">Code</a></li>
</ul>



</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-Zhang2020XLingEmbedd" class="csl-entry">
Zhang, Mozhi, Yoshinari Fujinuma, Michael J. Paul, and Jordan Boyd-Graber. 2020. <span>“Why Overfitting Isn’t Always Bad: Retrofitting Cross-Lingual Word Embeddings to Dictionaries.”</span> In <em>Association for Computational Linguistics</em>. The Cyberverse Simulacrum of Seattle. <a href="http://umiacs.umd.edu/~jbg//docs/2020_acl_refine.pdf">http://umiacs.umd.edu/~jbg//docs/2020_acl_refine.pdf</a>.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>see my note below regarding this point.↩︎</p></li>
</ol>
</section></div> ]]></description>
  <guid>https://orenbochman.github.io/reviews/2020/Why Overfitting Isn’t Always Bad/</guid>
  <pubDate>Tue, 11 Jun 2024 00:00:00 GMT</pubDate>
</item>
<item>
  <title>sense2vec - A Fast and Accurate Method for Word Sense Disambiguation In Neural Word Embeddings</title>
  <link>https://orenbochman.github.io/reviews/2015/sense2vec/</link>
  <description><![CDATA[ 




<p><strong>Sense2Vec</strong> <span class="citation" data-cites="trask2015sense2vecfastaccurate">(Trask, Michalak, and Liu 2015)</span> is an interesting deep learning model based on word2vec that can learn more interesting and detailed word vectors from large corpora. Sense2Vec embeddings are for word senses rather than for tokens.</p>
<p>The shortcoming of word2vec is that it only learns one vector per word, which is not enough to capture the multiple meanings of a word. Sense2Vec addresses this issue by learning multiple embeddings for each word based on supervised disambiguation. This allows a consuming NLP model to select a sense-disambiguated embedding quickly and accurately.</p>
<p>I thought that the next step would be to cluster these embeddings by contexts and thus arrive at a wordsense version - however it turns out this was computationally expensive and difficult to apply in a scalable fashion. The idea of this paper is to use a supervised approach to disambiguate the senses of words. This means that the words need to be tagged using thier part-of-speech (POS) tags or named entity resolution. This approach is faster and more accurate than the clustering approach. However there is a limitation that the supervised labels are required and there can be multiple wordsenses within a signle POS tag.</p>
<p>Abstract</p>
<blockquote class="blockquote">
<p>Neural word representations have proven useful in Natural Language Processing (NLP) tasks due to their ability to efficiently model complex semantic and syntactic word relationships. However, most techniques model only one representation per word, despite the fact that a single word can have multiple meanings or “senses”. Some techniques model words by using multiple vectors that are clustered based on context. However, recent neural approaches rarely focus on the application to a consuming NLP algorithm. Furthermore, the training process of recent word-sense models is expensive relative to single-sense embedding processes. This paper presents a novel approach which addresses these concerns by modeling multiple embeddings for each word based on supervised disambiguation, which provides a fast and accurate way for a consuming NLP model to select a sense-disambiguated embedding. We demonstrate that these embeddings can disambiguate both contrastive senses such as nominal and verbal senses as well as nuanced senses such as sarcasm. We further evaluate Part-of-Speech disambiguated embeddings on neural dependency parsing, yielding a greater than 8% average error reduction in unlabeled attachment scores across 6 languages.</p>
<p>— <span class="citation" data-cites="trask2015sense2vecfastaccurate">(Trask, Michalak, and Liu 2015)</span></p>
</blockquote>
<section id="review" class="level2">
<h2 class="anchored" data-anchor-id="review">Review</h2>
<p>The paper <span class="citation" data-cites="trask2015sense2vecfastaccurate">(Trask, Michalak, and Liu 2015)</span> the autors introduced a novel method for word sense disambiguation in neural word embeddings. Traditional word embedding techniques such as Word2Vec represent each word by a single vector, regardless of its multiple meanings or senses, which often leads to ambiguities. This challenge is known as the “superposition” problem, where multiple meanings of a word are combined into a single vector, potentially leading to suboptimal performance in downstream NLP tasks. SENSE2VEC addresses this limitation by generating multiple embeddings for each word, effectively disambiguating different senses.</p>
</section>
<section id="motivation-and-related-work" class="level2">
<h2 class="anchored" data-anchor-id="motivation-and-related-work">Motivation and Related Work</h2>
<p>The motivation behind SENSE2VEC stems from the shortcomings of earlier models like Word2Vec and Wang2Vec. Word2Vec, while highly successful, does not consider the order of words in a sentence and struggles with polysemy—the phenomenon where a single word can have multiple meanings. Wang2Vec improves upon Word2Vec by incorporating word order, making it more suitable for syntactic tasks, yet still relies on single embeddings per word, making it less effective for handling polysemic words.</p>
<p>Other approaches, such as multi-prototype vector-space models by Reisinger and Mooney (2010), attempt to tackle polysemy by clustering the contexts in which a word appears and generating different embeddings for each cluster. However, these methods often require unsupervised clustering, making the process computationally expensive and difficult to apply in a scalable fashion. SENSE2VEC circumvents these challenges by leveraging supervised learning with part-of-speech (POS) tagging or named entity resolution, reducing the computational overhead while providing more accurate disambiguation.</p>
</section>
<section id="the-sense2vec-model" class="level2">
<h2 class="anchored" data-anchor-id="the-sense2vec-model">The SENSE2VEC Model</h2>
<p>The core innovation of SENSE2VEC lies in its use of supervised labels, such as POS tags, to disambiguate the senses of words. Unlike previous models that rely on unsupervised clustering methods, SENSE2VEC uses these labels to generate separate embeddings for each sense of a word. For example, the word “bank” can have distinct embeddings for its noun and verb forms.</p>
<p>The model can be trained using traditional methods like Continuous Bag of Words (CBOW) or Skip-gram, with a key difference: instead of predicting words given surrounding words, SENSE2VEC predicts word senses given surrounding senses. This approach leads to more accurate representations of polysemic words in context, reducing the negative impact of superposition.</p>
</section>
<section id="evaluation-and-results" class="level2">
<h2 class="anchored" data-anchor-id="evaluation-and-results">Evaluation and Results</h2>
<p>The authors evaluated SENSE2VEC on various NLP tasks, including dependency parsing and named entity resolution (NER). Notably, the disambiguation achieved by SENSE2VEC led to significant improvements in performance. For example, in dependency parsing across six languages (Bulgarian, German, English, French, Italian, and Swedish), SENSE2VEC embeddings resulted in an average error reduction of over 8% compared to the Wang2Vec baseline.</p>
<p>The model also demonstrated its effectiveness in handling sentiment disambiguation, as shown in Table 5 of the paper, where the word “bad” was successfully disambiguated into a negative and positive sentiment sense. The positive sense captured sarcastic uses of “bad,” which is often interpreted as “good” in informal language, while the negative sense retained the more classical meaning of “bad.”</p>
</section>
<section id="strengths-and-contributions" class="level2">
<h2 class="anchored" data-anchor-id="strengths-and-contributions">Strengths and Contributions</h2>
<p>SENSE2VEC’s strengths lie in its efficiency and accuracy. By utilizing supervised labels, the model eliminates the need for expensive clustering algorithms, making it both faster and easier to scale. The ability to disambiguate nuanced senses of words, such as sentiment and named entities, showcases the flexibility and robustness of the approach.</p>
<p>Additionally, the model’s performance improvements in downstream tasks like dependency parsing and NER demonstrate its practical applicability in real-world NLP systems. The fact that SENSE2VEC outperforms earlier models like Wang2Vec and other clustering-based approaches highlights its contribution to the field of word sense disambiguation.</p>
</section>
<section id="limitations-and-future-work" class="level2">
<h2 class="anchored" data-anchor-id="limitations-and-future-work">Limitations and Future Work</h2>
<p>One potential limitation of SENSE2VEC is its reliance on labeled data. While supervised learning offers many advantages in terms of accuracy, it also introduces a dependency on the availability of high-quality labels. For languages or domains where such labels are scarce, applying SENSE2VEC may be more challenging.</p>
<p>The authors acknowledge this limitation and suggest that future work could explore the use of other types of supervised labels or investigate ways to combine both supervised and unsupervised methods to further enhance word sense disambiguation.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Overall, SENSE2VEC presents a compelling and efficient solution to the problem of word sense disambiguation in neural word embeddings. By leveraging supervised NLP labels, the model significantly improves the accuracy of embeddings for polysemic words, leading to better performance in NLP tasks like dependency parsing and NER. Its contribution to the field is clear, and it paves the way for future advancements in sense-disambiguated word embeddings.</p>
</section>
<section id="see-also" class="level2">
<h2 class="anchored" data-anchor-id="see-also">See also:</h2>
<ul>
<li><a href="https://arxiv.org/abs/1511.06388">paper</a></li>
<li><a href="https://github.com/explosion/sense2vec">code</a> by Explosion AI</li>
<li><a href="https://demos.explosion.ai/sense2vec">demo</a></li>
</ul>
</section>
<section id="the-paper" class="level2">
<h2 class="anchored" data-anchor-id="the-paper">The paper</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="./paper.pdf" class="col-page" width="800" height="1000"></p>
<figcaption>paper</figcaption>
</figure>
</div>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> sense2vec <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> Sense2Vec</span>
<span id="cb1-2"></span>
<span id="cb1-3">s2v <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Sense2Vec().from_disk(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"/path/to/s2v_reddit_2015_md"</span>)</span>
<span id="cb1-4">query <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"natural_language_processing|NOUN"</span></span>
<span id="cb1-5"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">assert</span> query <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> s2v</span>
<span id="cb1-6">vector <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> s2v[query]</span>
<span id="cb1-7">freq <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> s2v.get_freq(query)</span>
<span id="cb1-8">most_similar <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> s2v.most_similar(query, n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>)</span>
<span id="cb1-9"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [('machine_learning|NOUN', 0.8986967),</span></span>
<span id="cb1-10"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#  ('computer_vision|NOUN', 0.8636297),</span></span>
<span id="cb1-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#  ('deep_learning|NOUN', 0.8573361)]</span></span></code></pre></div>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> sense2vec <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> Sense2Vec</span>
<span id="cb2-2">s2v <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Sense2Vec().from_disk(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"./s2v_reddit_2015_md"</span>)</span>
<span id="cb2-3">vector <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> s2v[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"natural_language_processing|NOUN"</span>]</span>
<span id="cb2-4">most_similar <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> s2v.most_similar(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"duck|VERB"</span>, n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span>)</span>
<span id="cb2-5"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(most_similar)</span></code></pre></div>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-trask2015sense2vecfastaccurate" class="csl-entry">
Trask, Andrew, Phil Michalak, and John Liu. 2015. <span>“Sense2vec - a Fast and Accurate Method for Word Sense Disambiguation in Neural Word Embeddings.”</span> <a href="https://arxiv.org/abs/1511.06388">https://arxiv.org/abs/1511.06388</a>.
</div>
</div></section></div> ]]></description>
  <guid>https://orenbochman.github.io/reviews/2015/sense2vec/</guid>
  <pubDate>Sun, 26 Jun 2022 00:00:00 GMT</pubDate>
</item>
</channel>
</rss>
